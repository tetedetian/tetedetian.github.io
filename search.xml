<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模拟空调遥控器代码</title>
      <link href="/2021/01/21/%E6%A8%A1%E6%8B%9F%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/01/21/%E6%A8%A1%E6%8B%9F%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<div align="center">基于C51单片机的模拟空调遥控器代码</div><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg51.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD1602_DB P0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code led_mod[<span class="number">10</span>]=&#123;<span class="number">0x28</span>, <span class="number">0x7E</span>, <span class="number">0xA2</span>,<span class="number">0x62</span>,<span class="number">0x74</span>, <span class="number">0x61</span>, <span class="number">0x21</span>,<span class="number">0x7A</span>, <span class="number">0x20</span>,<span class="number">0x60</span>&#125;;</span><br><span class="line">sbit RS=P2^<span class="number">0</span>;</span><br><span class="line">sbit RW=P2^<span class="number">1</span>;</span><br><span class="line">sbit E=P2^<span class="number">2</span>;</span><br><span class="line">sbit <span class="built_in">beep</span>=P3^<span class="number">5</span>;</span><br><span class="line">sbit speed_led=P3^<span class="number">7</span>; <span class="comment">//⻛风速灯接⼝口</span></span><br><span class="line">uchar k=<span class="number">1</span>;<span class="comment">//按键1控制变量量</span></span><br><span class="line">uchar m=<span class="number">0</span>;<span class="comment">//按键4(模式)控制变量量</span></span><br><span class="line">uchar temperature=<span class="number">27</span>; <span class="comment">//温度变量量</span></span><br><span class="line">uchar speed_num=<span class="number">1</span>; <span class="comment">//⻛风速控制变量量</span></span><br><span class="line">uint high,low;</span><br><span class="line">uchar a=<span class="number">1</span>; <span class="comment">//步进电机⾥里里⾯面控制正转反转的变量量</span></span><br><span class="line">uint motor_contrl_1=<span class="number">0</span>; <span class="comment">//计算步进电机转动次数的变量量(6次⼀一反转)</span></span><br><span class="line">uchar motor_contrl_2=<span class="number">0</span>; <span class="comment">//实现步进电机⻓长按功能的辅助变量量</span></span><br><span class="line">uchar hour=<span class="number">1</span>,<span class="built_in">min</span>=<span class="number">59</span>; <span class="comment">//倒计时⼩小时和分钟变量量</span></span><br><span class="line">uchar bell_num=<span class="number">0</span>,bell_hour=<span class="number">0</span>,bell_min=<span class="number">0</span>; <span class="comment">//bell_num记录按了了⼏几次， bell_hour， bell_min⽤用来实现闪烁功能的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">延时函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(uint z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; z; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">125</span>; j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">计时器器初始化</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EA = <span class="number">1</span>;</span><br><span class="line">TR0 = <span class="number">1</span>;</span><br><span class="line">ET0 = <span class="number">1</span>;</span><br><span class="line">TMOD = <span class="number">0x11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">变量量初始化函数，终于倒计时结束后的初始化</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">all_initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line">temperature = <span class="number">27</span>;</span><br><span class="line">speed_num = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">motor_contrl_1 = <span class="number">0</span>;</span><br><span class="line">motor_contrl_2 = <span class="number">0</span>;</span><br><span class="line">hour = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">min</span> = <span class="number">59</span>;</span><br><span class="line">bell_num = <span class="number">0</span>;</span><br><span class="line">bell_hour = <span class="number">0</span>;</span><br><span class="line">bell_min = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">按键扫描函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">uchar <span class="title">KeyScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar i;</span><br><span class="line">uchar h, l; <span class="comment">//⾏值和列值存储变量量</span></span><br><span class="line">P1 = <span class="number">0xf0</span>; <span class="comment">//给P1置初值11110000</span></span><br><span class="line"><span class="keyword">if</span> ((P1 &amp; <span class="number">0xf0</span>) != <span class="number">0xf0</span>) <span class="comment">//检测是否有按键按下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">40</span>); <span class="comment">//延时消抖</span></span><br><span class="line"><span class="keyword">if</span> ((P1 &amp; <span class="number">0xf0</span>) != <span class="number">0xf0</span>) <span class="comment">//再次检测</span></span><br><span class="line">&#123;</span><br><span class="line">l = P1 &amp; <span class="number">0xf0</span>; <span class="comment">//存列列值</span></span><br><span class="line">P1 = l | <span class="number">0x0f</span>;</span><br><span class="line">h = P1 &amp; <span class="number">0x0f</span>; <span class="comment">//存⾏行行值</span></span><br><span class="line"><span class="keyword">while</span> ((P1 &amp; <span class="number">0x0f</span> != <span class="number">0x0f</span>)); <span class="comment">//等待按键提起</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) <span class="comment">//蜂鸣器器响</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">beep</span> = ~<span class="built_in">beep</span>;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(l + h); <span class="comment">//返回键值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">1602写数据函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LcdWriteData</span><span class="params">(uchar dat)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RS = <span class="number">1</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">LCD1602_DB = dat;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">1</span>);</span><br><span class="line">E = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">2</span>);</span><br><span class="line">E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">1602写指令函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LcdWriteCmd</span><span class="params">(uchar cmd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RS = <span class="number">0</span>;</span><br><span class="line">RW = <span class="number">0</span>;</span><br><span class="line">LCD1602_DB = cmd;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">1</span>);</span><br><span class="line">E = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">2</span>);</span><br><span class="line">E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">指针函数，控制写入位置</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cursor_pos</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> x, <span class="keyword">unsigned</span> <span class="keyword">char</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LcdWriteCmd(<span class="number">0x80</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LcdWriteCmd(<span class="number">0xc0</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">按键1函数，利用变量k，实现开显示与关显示</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">LcdWriteCmd(<span class="number">0x0c</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LcdWriteCmd(<span class="number">0x08</span>);</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">2</span>) k = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">温度写入函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Temp</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set_cursor_pos(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">LcdWriteData(temperature / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(temperature % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(<span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">模式写⼊函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar n;</span><br><span class="line">uchar mode[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="string">'A'</span>,<span class="string">'U'</span>,<span class="string">'T'</span>,<span class="string">'O'</span>&#125;,&#123;<span class="string">'C'</span>,<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'L'</span>&#125;,&#123;<span class="string">'H'</span>,<span class="string">'O'</span>,<span class="string">'T'</span>,<span class="string">' '</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">if</span> (m &gt; <span class="number">2</span>) m = <span class="number">0</span>;</span><br><span class="line">set_cursor_pos(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">4</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line">LcdWriteData(mode[m][n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">风速显示写⼊函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speed</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar i;</span><br><span class="line">uchar speed = <span class="string">'&lt;'</span>;</span><br><span class="line"><span class="keyword">if</span> (speed_num &gt; <span class="number">3</span>) <span class="comment">//按3次后清屏回到⼀一档</span></span><br><span class="line">&#123;</span><br><span class="line">speed_num = <span class="number">1</span>;</span><br><span class="line">LcdWriteCmd(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line">set_cursor_pos(<span class="number">11</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; speed_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">LcdWriteData(speed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">步进电机控制函数， angle为⻆角度， dir控制正转或反转</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Motor</span><span class="params">(uchar angle, uchar dir)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uchar i;</span><br><span class="line">uchar tmp; <span class="comment">//临时变量量，存储P3的中间变量量uchar index=0; //节拍输出索引</span></span><br><span class="line">uint beats = <span class="number">0</span>; <span class="comment">//电机转动节拍数</span></span><br><span class="line">uchar code beatcode[<span class="number">8</span>] = &#123; <span class="number">0x0e</span>,<span class="number">0x0c</span>,<span class="number">0x0d</span>,<span class="number">0x09</span>,<span class="number">0x0b</span>,<span class="number">0x03</span>,<span class="number">0x07</span>,<span class="number">0x06</span> &#125;; <span class="comment">//节拍控制代码</span></span><br><span class="line">beats = angle * <span class="number">4096</span> / <span class="number">360</span>;</span><br><span class="line"><span class="keyword">if</span> (dir == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; beats; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = P3;</span><br><span class="line">tmp = tmp &amp; <span class="number">0xf0</span>; <span class="comment">//为了了不不影响P3另外四个接⼝口</span></span><br><span class="line">tmp = tmp | beatcode[index];</span><br><span class="line">P3 = tmp;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">10</span>); <span class="comment">//延迟，给步进电机⾜足够时间</span></span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">8</span>) index = <span class="number">0</span>; <span class="comment">//到8归0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; beats; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = P3;</span><br><span class="line">tmp = tmp &amp; <span class="number">0xf0</span>;</span><br><span class="line">tmp = tmp | beatcode[index];</span><br><span class="line">P3 = tmp;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">index--;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">-1</span>) index = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">风速led亮度调节函数， f为频率， p为占空⽐</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWM</span><span class="params">(uint f, uchar p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line">tmp = <span class="number">1000000</span> / f; <span class="comment">//⼀一个周期所需要的计数值</span></span><br><span class="line">low = (tmp*(p)) / <span class="number">100</span>; <span class="comment">//低电平需要的计数值</span></span><br><span class="line">high = tmp - low;</span><br><span class="line">TH0 = (<span class="number">65536</span> - high) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65536</span> - high) % <span class="number">256</span>;</span><br><span class="line">speed_led = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">按键6函数，实现步进电机3个功能</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_6</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">delay</span>(<span class="number">200</span>); <span class="comment">//⻓长按延时</span></span><br><span class="line"><span class="keyword">if</span> (KeyScan() == <span class="number">0xdd</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (KeyScan() != <span class="number">0xdd</span> || motor_contrl_2++ &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span>motor_contrl_2++; <span class="comment">//⻓长按辅助变量量</span></span><br><span class="line"><span class="keyword">if</span> (motor_contrl_2 % <span class="number">6</span> == <span class="number">0</span>) <span class="comment">//实现⾃自动转6次后反转</span></span><br><span class="line">&#123;</span><br><span class="line">a = ~a;</span><br><span class="line">&#125;</span><br><span class="line">Motor(<span class="number">1</span>, a);</span><br><span class="line">&#125;</span><br><span class="line">motor_contrl_2 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (motor_contrl_1 % <span class="number">6</span> == <span class="number">0</span>) <span class="comment">//独⽴立按6次后反转⽅方向</span></span><br><span class="line">&#123;</span><br><span class="line">a = ~a;</span><br><span class="line">&#125;</span><br><span class="line">motor_contrl_1++;</span><br><span class="line">Motor(<span class="number">1</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">倒计时函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bell</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (bell_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//按键7第⼀一次</span></span><br><span class="line">&#123;</span><br><span class="line">ET1 = <span class="number">1</span>;</span><br><span class="line">TR1 = <span class="number">1</span>;</span><br><span class="line">set_cursor_pos(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(hour / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(hour % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(<span class="string">':'</span>);</span><br><span class="line">LcdWriteData(<span class="built_in">min</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(<span class="built_in">min</span> % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//按键7第⼆二次</span></span><br><span class="line">&#123;</span><br><span class="line">ET1 = <span class="number">0</span>;</span><br><span class="line">TR1 = <span class="number">0</span>;</span><br><span class="line">set_cursor_pos(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(hour / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(hour % <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">//写⼊入⼩小时部分</span></span><br><span class="line">LcdWriteData(<span class="string">':'</span>);</span><br><span class="line"><span class="keyword">if</span> (bell_min == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">set_cursor_pos(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(<span class="built_in">min</span> / <span class="number">10</span> + <span class="number">0x30</span>); <span class="comment">//写⼊入分钟部分</span></span><br><span class="line">LcdWriteData(<span class="built_in">min</span> % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">set_cursor_pos(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(<span class="string">' '</span>); <span class="comment">//对⼩小时部分⽤用空格进⾏行行清屏</span></span><br><span class="line">摆⻛风部分LcdWriteData(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//按键7第三次</span></span><br><span class="line">&#123;</span><br><span class="line">set_cursor_pos(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(<span class="string">':'</span>);</span><br><span class="line">LcdWriteData(<span class="built_in">min</span> / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(<span class="built_in">min</span> % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line"><span class="keyword">if</span> (bell_hour == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">set_cursor_pos(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(hour / <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">LcdWriteData(hour % <span class="number">10</span> + <span class="number">0x30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">set_cursor_pos(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">LcdWriteData(<span class="string">' '</span>);</span><br><span class="line">LcdWriteData(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bell_num == <span class="number">4</span>) bell_num = <span class="number">1</span>; <span class="comment">//第四次直接回到第⼀一次，利利⽤用第⼀一次功能实现开始倒计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">按键8实现函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_8</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bell_num == <span class="number">2</span>) <span class="comment">//bell_num为2说明在调整分钟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span>--;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span>) <span class="built_in">min</span> = <span class="number">59</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bell_num == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">hour++;</span><br><span class="line"><span class="keyword">if</span> (hour == <span class="number">12</span>) hour = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">主函数</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">time_initialize(); <span class="comment">//计时器器初始化</span></span><br><span class="line">LcdWriteCmd(<span class="number">0x01</span>);</span><br><span class="line">LcdWriteCmd(<span class="number">0x08</span>);</span><br><span class="line">LcdWriteCmd(<span class="number">0x38</span>); <span class="comment">//1602初始化</span></span><br><span class="line">LcdWriteCmd(<span class="number">0x06</span>); <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PWM(<span class="number">100</span>, <span class="number">30</span> * speed_num); <span class="comment">//点亮⻛风速⼩小灯，并按照⻛风速调节亮度</span></span><br><span class="line"><span class="keyword">switch</span> (KeyScan())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xee</span>:key_1(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xde</span>:temperature++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xbe</span>:temperature--; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x7e</span>: m++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xed</span>:speed_num++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xdd</span>: key_6(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0xbd</span>: bell_num++; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x7d</span>:key_8(); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Temp(); <span class="comment">//显示温度</span></span><br><span class="line">Mode(); <span class="comment">//显示模式</span></span><br><span class="line">Speed(); <span class="comment">//显示⻛风速</span></span><br><span class="line">bell(); <span class="comment">//显示倒计时</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">中断函数1，⽤用来实现pwm和调节倒计时时间的闪烁功能</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_0</span><span class="params">()</span> interrupt 1 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> uchar count0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (speed_led == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">TH0 = (<span class="number">65536</span> - low) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65536</span> - low) % <span class="number">256</span>;</span><br><span class="line">speed_led = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TH0 = (<span class="number">65536</span> - high) / <span class="number">256</span>;</span><br><span class="line">TL0 = (<span class="number">65536</span> - high) % <span class="number">256</span>;</span><br><span class="line">speed_led = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">count0++;</span><br><span class="line"><span class="keyword">if</span> (count0 == <span class="number">70</span>) <span class="comment">//70⽤用来控制闪烁频率</span></span><br><span class="line">&#123;</span><br><span class="line">count0 = <span class="number">0</span>;</span><br><span class="line">bell_hour = ~bell_hour;</span><br><span class="line">bell_min = ~bell_min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">中断函数2</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_1</span><span class="params">()</span> interrupt 3 </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> uchar count1 = <span class="number">0</span>;</span><br><span class="line">TH1 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">TL1 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>; <span class="comment">//设置初值</span></span><br><span class="line">count1++; <span class="keyword">if</span> (count1 == <span class="number">2</span>) <span class="comment">//每2次50ms， min变化⼀一次</span></span><br><span class="line">&#123;</span><br><span class="line">count1 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">min</span>--;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">//倒计时结束</span></span><br><span class="line"><span class="keyword">if</span> (hour == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ET1 = <span class="number">0</span>;</span><br><span class="line">TR1 = <span class="number">0</span>; <span class="comment">//关闭计时</span></span><br><span class="line">all_initialize(); <span class="comment">//把所有变量量初始化</span></span><br><span class="line">LcdWriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">LcdWriteCmd(<span class="number">0x08</span>); <span class="comment">//关显示</span></span><br><span class="line">&#125;</span><br><span class="line">hour--;</span><br><span class="line"><span class="built_in">min</span> = <span class="number">59</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机房预约系统模拟展示</title>
      <link href="/2021/01/16/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%B1%95%E7%A4%BA/"/>
      <url>/2021/01/16/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<div align="center"> 此博客展示了一个基于C++控制台的机房预约模拟系统的代码以及运行结果 <div/><a id="more"></a><h1 id="一、头文件"><a href="#一、头文件" class="headerlink" title="一、头文件"></a>一、头文件</h1><p><strong>1.computer.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">不止一个机房，所以这个头文件是声明一个机房类，可供定义机房对象时使用</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerRoom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_ComId; <span class="comment">//机房Id号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.globalFile.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">对存储数据的文本文件进行宏定义，方便其他文件调用</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADMIN_FILE     <span class="meta-string">"admin.txt"</span></span></span><br><span class="line"><span class="comment">//学生信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_FILE   <span class="meta-string">"student.txt"</span></span></span><br><span class="line"><span class="comment">//教师信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_FILE   <span class="meta-string">"teacher.txt"</span></span></span><br><span class="line"><span class="comment">//机房信息文件（机器数量，机房号等）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER_FILE  <span class="meta-string">"computerRoom.txt"</span></span></span><br><span class="line"><span class="comment">//预约信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_FILE     <span class="meta-string">"order.txt"</span></span></span><br></pre></td></tr></table></figure><p><strong>3.Identity.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">这个头文件定义了一个身份父类，声明了一些身份认证必须的成员变量和方法，可供管理员、教师、学生类继承。</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">//防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象父类（基类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作菜单，用到了纯虚函数。（virtual是虚函数标志，“=0”则表示是纯虚函数）</span></span><br><span class="line"><span class="comment">//如果父类中有纯虚函数，子类继承父类，就必须实现纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="comment">//密码</span></span><br><span class="line"><span class="built_in">string</span> m_Pwd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.manager.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">声明管理员类</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Identity.h"</span><span class="comment">//管理员也要身份认证，肯定得用到身份类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;//写入txt文件需要用到的一个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"globalFile.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;//vertor容器头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;//&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"computerRoom.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员类设计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager(<span class="built_in">string</span> name ,<span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测重复 参数1:检测学号/职工号  参数2:检测类型</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="keyword">int</span> id , <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt;vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Teacher&gt;vTea;</span><br><span class="line"></span><br><span class="line"><span class="comment">//机房信息容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt;vCom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>5.orderFile.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">声明预约类</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"globalFile.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;//对txt文件读写需要用到</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;//map容器头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">OrderFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录预约条数</span></span><br><span class="line"><span class="keyword">int</span> m_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录所有预约信息的容器(map容器)  key记录条数   value 具体记录键值对信息</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>6.student.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Identity.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"computerRoom.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"globalFile.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"orderFile.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student();</span><br><span class="line"><span class="comment">//有参构造  参数：学号、姓名、密码</span></span><br><span class="line">Student(<span class="keyword">int</span> id,<span class="built_in">string</span> name,<span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看自身预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生学号</span></span><br><span class="line"><span class="keyword">int</span> m_Id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>7.teacher.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Identity.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"orderFile.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//教师类设计</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职工号</span></span><br><span class="line"><span class="keyword">int</span> m_EmpId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、源文件"><a href="#二、源文件" class="headerlink" title="二、源文件"></a>二、源文件</h1><p><strong>1.manager.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"manager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::Manager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化管理员信息</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化容器 获取到所有文件中 学生、老师信息</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom com;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; com.m_ComId &amp;&amp; ifs &gt;&gt; com.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(com);</span><br><span class="line">&#125;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "机房的数量为：" &lt;&lt; vCom.size() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎管理员："</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">"登录！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ---------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          1.添加账号            |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          2.查看账号            |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          3.查看机房            |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          4.清空预约            |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          0.注销登录            |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ---------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择您的操作： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入添加账号类型"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1、添加学生"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2、添加老师"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fileName; <span class="comment">//操作文件名</span></span><br><span class="line"><span class="built_in">string</span> tip;  <span class="comment">//提示id号</span></span><br><span class="line"><span class="built_in">string</span> errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line">ofstream ofs;<span class="comment">//文件操作对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户的选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加的是学生</span></span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">"请输入学号："</span>;</span><br><span class="line">errorTip = <span class="string">"学号重复，请重新输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">"请输入职工编号："</span>;</span><br><span class="line">errorTip = <span class="string">"职工号重复，请重新输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用追加的方式 写文件</span></span><br><span class="line">ofs.<span class="built_in">open</span>(fileName, ios::out | ios::app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id; <span class="comment">//学号 /职工号</span></span><br><span class="line"><span class="built_in">string</span> name; <span class="comment">//姓名</span></span><br><span class="line"><span class="built_in">string</span> pwd; <span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"><span class="keyword">bool</span> ret = checkRepeat(id, select);</span><br><span class="line"><span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; errorTip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入姓名： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入密码： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向文件中添加数据</span></span><br><span class="line">ofs &lt;&lt; id &lt;&lt; <span class="string">" "</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; pwd &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"添加成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用初始化容器接口，从新获取文件中的数据</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"学号： "</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">" 密码："</span> &lt;&lt; s.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"职工号： "</span> &lt;&lt; s.m_EmpId &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">" 密码："</span> &lt;&lt; s.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择查看内容："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1、查看所有学生"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2、查看所有老师"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>; <span class="comment">//接受用户选择</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看学生</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"所有学生信息如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vStu.<span class="built_in">begin</span>(), vStu.<span class="built_in">end</span>(), printStudent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看老师</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"所有老师信息如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vTea.<span class="built_in">begin</span>(), vTea.<span class="built_in">end</span>(), printTeacher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"机房信息如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;ComputerRoom&gt;::iterator it = vCom.<span class="built_in">begin</span>(); it != vCom.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"机房编号： "</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">" 机房最大容量： "</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"清空成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//确保容器清空状态</span></span><br><span class="line">vStu.<span class="built_in">clear</span>();</span><br><span class="line">vTea.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取信息   学生</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(STUDENT_FILE, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"文件读取失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student s;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp; ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vStu.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "当前学生数量为： " &lt;&lt; vStu.size() &lt;&lt; endl;</span></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取信息   老师</span></span><br><span class="line">ifs.<span class="built_in">open</span>(TEACHER_FILE, ios::in);</span><br><span class="line">Teacher t;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp; ifs &gt;&gt;t.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vTea.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "当前老师数量为： " &lt;&lt; vTea.size() &lt;&lt; endl;</span></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测重复 参数1 检测学号/职工号  参数2  检测类型</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测学生</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = vStu.<span class="built_in">begin</span>(); it != vStu.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测老师</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Teacher&gt;::iterator it = vTea.<span class="built_in">begin</span>(); it != vTea.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.orderFile.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"orderFile.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">OrderFile::OrderFile()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> date;    <span class="comment">// 日期</span></span><br><span class="line"><span class="built_in">string</span> interval;<span class="comment">//时间段</span></span><br><span class="line"><span class="built_in">string</span> stuId;   <span class="comment">//学生编号</span></span><br><span class="line"><span class="built_in">string</span> stuName; <span class="comment">//学生姓名</span></span><br><span class="line"><span class="built_in">string</span> roomId;  <span class="comment">//机房编号</span></span><br><span class="line"><span class="built_in">string</span> status;  <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//记录条数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs </span><br><span class="line">&gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp; ifs &gt;&gt; status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//date:11111</span></span><br><span class="line"><span class="built_in">string</span> key;</span><br><span class="line"><span class="built_in">string</span> value;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = date.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = date.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = date.substr(pos + <span class="number">1</span>, date.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line"></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; "key = " &lt;&lt; key &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "value = " &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//截取时间段</span></span><br><span class="line">pos = interval.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = interval.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = interval.substr(pos + <span class="number">1</span>, interval.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取学号</span></span><br><span class="line">pos = stuId.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuId.substr(pos + <span class="number">1</span>, stuId.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取姓名</span></span><br><span class="line">pos = stuName.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuName.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuName.substr(pos + <span class="number">1</span>, stuName.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取机房号</span></span><br><span class="line">pos = roomId.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = roomId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = roomId.substr(pos + <span class="number">1</span>, roomId.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取预约状态</span></span><br><span class="line">pos = status.<span class="built_in">find</span>(<span class="string">":"</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = status.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = status.substr(pos + <span class="number">1</span>, status.<span class="built_in">size</span>() - pos - <span class="number">1</span>);  <span class="comment">// size = 10  pos = 4  size - pos  - 1 = 6 - 1</span></span><br><span class="line">m.insert(make_pair(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将小map容器放入到大的map容器中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_orderData.insert(make_pair(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试最大map容器</span></span><br><span class="line"><span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "条数为： " &lt;&lt; it-&gt;first &lt;&lt; " value = " &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (map&lt;string, string&gt;::iterator mit = (*it).second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; " key = " &lt;&lt; mit-&gt;first &lt;&lt; " value = " &lt;&lt; mit-&gt;second &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//预约记录0条，直接return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; <span class="string">"date:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"date"</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"interval:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"interval"</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"stuId:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"stuId"</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"stuName:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"stuName"</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"roomId:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"roomId"</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"status:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">"status"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.student.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::Student()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造  参数：学号、姓名、密码</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom com;</span><br><span class="line"><span class="keyword">while</span> ( ifs &gt;&gt; com.m_ComId &amp;&amp; ifs &gt;&gt; com.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将读取的信息放入到 容器中</span></span><br><span class="line">vCom.push_back(com);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎学生代表："</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">"登录！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ----------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          1.申请预约              |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          2.查看我的预约          |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          3.查看所有预约          |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          4.取消预约              |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          0.注销登录              |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ----------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择您的操作： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"机房开放时间为周一至周五!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入申请预约的时间："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1、周一"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2、周二"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"3、周三"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"4、周四"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5、周五"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> date = <span class="number">0</span>;   <span class="comment">//日期</span></span><br><span class="line"><span class="keyword">int</span> interval = <span class="number">0</span>; <span class="comment">//时间段</span></span><br><span class="line"><span class="keyword">int</span> room = <span class="number">0</span>; <span class="comment">//机房编号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line"><span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入申请预约时间段："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1、上午"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2、下午"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; interval;</span><br><span class="line"><span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择机房："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vCom.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; vCom[i].m_ComId &lt;&lt; <span class="string">"号机房容量为： "</span> &lt;&lt; vCom[i].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; room;</span><br><span class="line"><span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约成功！审核中"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(ORDER_FILE, ios::app);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">"date:"</span> &lt;&lt; date &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"interval:"</span> &lt;&lt; interval &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"stuId:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"stuName:"</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"roomId:"</span> &lt;&lt; room &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">"status:"</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看自身预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无预约记录！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// string  转 int</span></span><br><span class="line"><span class="comment">// string 利用 .c_str() 转 const char *</span></span><br><span class="line"><span class="comment">//利用 atoi ( const char *) 转 int</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Id == atoi(of.m_orderData[i][<span class="string">"stuId"</span>].c_str())) <span class="comment">//找到自身预约</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约日期： 周"</span> &lt;&lt; of.m_orderData[i][<span class="string">"date"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 时间段： "</span> &lt;&lt; (of.m_orderData[i][<span class="string">"interval"</span>] == <span class="string">"1"</span> ? <span class="string">"上午"</span> : <span class="string">"下午"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 机房号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"roomId"</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">"状态： "</span>;</span><br><span class="line"><span class="comment">// 1 审核中  2 已预约  -1 预约失败  0 取消预约</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"审核中"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"-1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约失败，审核未通过"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约已取消"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无预约记录"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pasue"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"、 "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约日期： 周"</span> &lt;&lt; of.m_orderData[i][<span class="string">"date"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 时间段： "</span> &lt;&lt; (of.m_orderData[i][<span class="string">"interval"</span>] == <span class="string">"1"</span> ? <span class="string">"上午"</span> : <span class="string">"下午"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuId"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuName"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 机房编号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"roomId"</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">" 状态："</span>;</span><br><span class="line"><span class="comment">// 1 审核中 2 已预约  -1预约失败  0 取消预约</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"审核中"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"-1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约失败，审核未通过"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约已取消"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无预约记录"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"审核中或预约成功的记录可以取消，请输入取消的记录"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v; <span class="comment">//存放在最大容器中的下标编号</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先判断是自身学号</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Id == atoi(of.m_orderData[i][<span class="string">"stuId"</span>].c_str()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//再筛选状态  审核中或预约成功</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span> || of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index++ &lt;&lt; <span class="string">"、 "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约日期： 周"</span> &lt;&lt; of.m_orderData[i][<span class="string">"date"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 时间段： "</span> &lt;&lt; (of.m_orderData[i][<span class="string">"interval"</span>] == <span class="string">"1"</span> ? <span class="string">"上午"</span> : <span class="string">"下午"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 机房编号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"roomId"</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">" 状态： "</span>;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"审核中"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入取消的记录，0代表返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">"status"</span>] = <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">of.updateOrder();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"已取消预约"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.teacher.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎教师："</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">"登录！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ----------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          1.查看所有预约          |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          2.审核预约              |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          0.注销登录              |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                                  |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t ----------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择您的操作： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无预约记录"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"、 "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约日期： 周"</span> &lt;&lt; of.m_orderData[i][<span class="string">"date"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 时间段： "</span> &lt;&lt; (of.m_orderData[i][<span class="string">"interval"</span>] == <span class="string">"1"</span> ? <span class="string">"上午"</span> : <span class="string">"下午"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuId"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 姓名： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuName"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 机房编号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"roomId"</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">" 状态： "</span>;</span><br><span class="line"><span class="comment">//1 审核中 2 已预约 -1 预约失败  0 取消预约</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"审核中"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"2"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"-1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约失败，审核未通过"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">"预约已取消"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无预约记录"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"待审核的预约记录如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">"status"</span>] == <span class="string">"1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++index &lt;&lt; <span class="string">"、 "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"预约日期： 周"</span> &lt;&lt; of.m_orderData[i][<span class="string">"date"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 时间段： "</span> &lt;&lt; (of.m_orderData[i][<span class="string">"interval"</span>] == <span class="string">"1"</span> ? <span class="string">"上午"</span> : <span class="string">"下午"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学生编号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuId"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 学生姓名： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"stuName"</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 机房编号： "</span> &lt;&lt; of.m_orderData[i][<span class="string">"roomId"</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">" 状态：审核中 "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入审核的预约记录，0代表返回"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>; <span class="comment">//接受用户选择的预约记录</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;  <span class="comment">//接受预约结果记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入审核结果"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1、通过"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2、不通过"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ret;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//通过情况</span></span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">"status"</span>] = <span class="string">"2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不通过情况</span></span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">"status"</span>] = <span class="string">"-1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">of.updateOrder(); <span class="comment">// 更新预约记录</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"审核完毕"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新输入！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.机房预约系统.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Identity.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"globalFile.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"manager.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入学生子菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">studentMenu</span><span class="params">(Identity* &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用学生子菜单</span></span><br><span class="line">student-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Student * stu = (Student *)student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;applyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showMyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有人预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;cancelOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注销登录</span></span><br><span class="line"><span class="keyword">delete</span> student;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"注销成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入教师子菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用子菜单界面</span></span><br><span class="line">teacher-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Teacher * tea = (Teacher*)teacher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">&#123;</span><br><span class="line">tea-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//审核预约</span></span><br><span class="line">&#123;</span><br><span class="line">tea-&gt;validOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> teacher;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"注销成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入管理员子菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//调用管理员子菜单</span></span><br><span class="line">manager-&gt;operMenu();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将父类指针 转为子类指针，调用子类里其他接口</span></span><br><span class="line">Manager * man = (Manager*)manager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//接受用户选项</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//添加账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "添加账号" &lt;&lt; endl;</span></span><br><span class="line">man-&gt;addPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "查看账号" &lt;&lt; endl;</span></span><br><span class="line">man-&gt;showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "查看机房" &lt;&lt; endl;</span></span><br><span class="line">man-&gt;showComputer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "清空预约" &lt;&lt; endl;</span></span><br><span class="line">man-&gt;cleanFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注销</span></span><br><span class="line"><span class="keyword">delete</span> manager; <span class="comment">//销毁掉堆区对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"注销成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能   参数1：操作文件名   参数2：操作身份类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginIn</span><span class="params">(<span class="built_in">string</span> fileName, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//父类指针 ，用于指向子类对象</span></span><br><span class="line">Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(fileName, ios::in);<span class="comment">//打开文件名为filename的文件用于其他变量的输入（也就是从文件中读取数据到其他变量）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())<span class="comment">//is_open就是用来判断文件是否成功打开，打开了返回1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"文件不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备接受用户的信息</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断身份</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) <span class="comment">//学生身份</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入你的学号："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入您的职工号： "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入用户名："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入密码："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生身份验证</span></span><br><span class="line"><span class="keyword">int</span> fId; <span class="comment">//从文件中读取的id号</span></span><br><span class="line"><span class="built_in">string</span> fName; <span class="comment">//从文件中获取的姓名</span></span><br><span class="line"><span class="built_in">string</span> fPwd; <span class="comment">//从文件中获取密码</span></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd )<span class="comment">//（ifs.open(fileName, ios::in);），文本文件“filename”作为输入源</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//与用户输入的信息做对比</span></span><br><span class="line"><span class="keyword">if</span> (fId == id &amp;&amp; fName == name &amp;&amp; fPwd == pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"学生验证登录成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">person = <span class="keyword">new</span> Student(id, name, pwd);<span class="comment">//</span></span><br><span class="line"><span class="comment">//进入学生身份的子菜单</span></span><br><span class="line">studentMenu(person);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师身份验证</span></span><br><span class="line"><span class="keyword">int</span> fId; <span class="comment">//从文件中获取的id号</span></span><br><span class="line"><span class="built_in">string</span> fName; <span class="comment">//从文件中获取的姓名</span></span><br><span class="line"><span class="built_in">string</span> fPwd; <span class="comment">//从文件中获取的密码</span></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fId == id &amp;&amp; fName == name &amp;&amp; fPwd == pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"教师验证登录成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line">person = <span class="keyword">new</span> Teacher(id, name, pwd);</span><br><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line">teacherMenu(person);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员身份验证</span></span><br><span class="line"><span class="built_in">string</span> fName; <span class="comment">//从文件中获取姓名</span></span><br><span class="line"><span class="built_in">string</span> fPwd; <span class="comment">//从文件中获取密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"管理员验证登录成功!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line">person = <span class="keyword">new</span> Manager(name, pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入管理员子菜单界面</span></span><br><span class="line">managerMenu(person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"验证登录失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>; <span class="comment">//用于接受用户的选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"======================  欢迎来到电子与信息工程学院机房预约系统  ====================="</span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"请输入您的身份"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t -------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                               |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          1.学生代表           |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                               |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          2.老    师           |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                               |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          3.管 理 员           |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                               |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|          0.退    出           |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t|                               |\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\t -------------------------------\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入您的选择: "</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (select) <span class="comment">//根据用户选择 实现不同接口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//学生身份</span></span><br><span class="line">LoginIn(STUDENT_FILE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//老师身份</span></span><br><span class="line">LoginIn(TEACHER_FILE, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line">LoginIn(ADMIN_FILE, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> :  <span class="comment">//退出系统</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎下一次使用！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入有误，请重新选择！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">system(<span class="string">"cls"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、运行截图"><a href="#三、运行截图" class="headerlink" title="三、运行截图"></a>三、运行截图</h1><p>管理员登入</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120215756077.png" alt="image-20210120215756077"></p><p>查看学生账号</p><p><img src="C:%5CUsers%5C10240%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210120220804655.png" alt="image-20210120220804655"></p><p>添加学生账号</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221041616.png" alt="image-20210120221041616"></p><p>重新查看账号</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221057187.png" alt="image-20210120221057187"></p><p>登录学生账号</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221153231.png" alt="image-20210120221153231"></p><p>申请预约</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221241951.png" alt="image-20210120221241951"></p><p>登录教师账号</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221537232.png" alt="image-20210120221537232"></p><p>教师审核</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210120221613690.png" alt="image-20210120221613690"></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地项目上传到github</title>
      <link href="/2020/10/23/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
      <url>/2020/10/23/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<p>从建立github仓库开始，介绍如何把本地项目上传到github仓库</p><a id="more"></a><h1 id="步骤概览"><a href="#步骤概览" class="headerlink" title="步骤概览"></a>步骤概览</h1><ol><li>建立github仓库</li></ol><h1 id="1-建立github仓库"><a href="#1-建立github仓库" class="headerlink" title="1.建立github仓库"></a>1.建立github仓库</h1><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201023140448267.png" alt="image-20201023140448267"></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201023140540644.png" alt="image-20201023140540644"></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201023141113291.png" alt="image-20201023141113291"></p><h1 id="2-建立github仓库与本地的连接"><a href="#2-建立github仓库与本地的连接" class="headerlink" title="2.建立github仓库与本地的连接"></a>2.建立github仓库与本地的连接</h1><p>（1）在需要上传的文件夹里右击鼠标，点击<code>Git Bash Here</code></p><p>（2）下图是命令执行截图</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201023143335365.png" alt="image-20201023143335365"></p><p>其中</p><p><code>git init</code>作用是初始化，使git可以控制此文件夹</p><p><code>git remote add origin git@github.com:tetedetian/Room-reservation-system.git</code>作用是建立与github仓库的连接。</p><p>（<code>git@github.com:tetedetian/Room-reservation-system.git</code>来源于下图）</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201023142024926.png" alt="image-20201023142024926"></p><h1 id="3-将本地文件推到github仓库"><a href="#3-将本地文件推到github仓库" class="headerlink" title="3.将本地文件推到github仓库"></a>3.将本地文件推到github仓库</h1><p>（1）执行<code>git add .</code></p><p>（2）执行<code>git commit -m &quot;这里写提交描述，会在仓库显示&quot;</code></p><p>（3）执行<code>git push -u origin master</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速下载Github项目</title>
      <link href="/2020/10/16/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDGitHub%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/10/16/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDGitHub%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<div align="center"> 把github的项目直接克隆到本地的速度实在太慢了。。</div><div align="center"> 我们可以借助gitee来帮助我们下载项目</div><a id="more"></a><h3 id="1-注册gitee"><a href="#1-注册gitee" class="headerlink" title="1.注册gitee"></a>1.注册gitee</h3><p>注册网址在<a href="https://gitee.com/" target="_blank" rel="noopener">这里</a></p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++基础知识点（更新中）</title>
      <link href="/2020/09/25/cpp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/09/25/cpp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div align="center">————一些c++基础知识点————</div><a id="more"></a><p><em>注：此博客只是我对部分知识点的记录与总结，想了解更多请参考权威书籍。</em></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="1-C语言与C-有什么区别？"><a href="#1-C语言与C-有什么区别？" class="headerlink" title="1.C语言与C++有什么区别？"></a>1.C语言与C++有什么区别？</h2><p><strong>（1）设计思想上：</strong></p><blockquote><p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p></blockquote><p>什么是面对过程？什么是面对对象？</p><p>简单来说，就是。。。。</p><p><strong>（2）语法上：</strong></p><blockquote><p>C++具有封装、继承和多态三种特性</p><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p><p>C++支持范式编程，比如模板类、函数模板等</p></blockquote><h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><h2 id="1-使用cout与cin"><a href="#1-使用cout与cin" class="headerlink" title="1.使用cout与cin"></a>1.使用cout与cin</h2><p>（1）<code>&lt;iostream&gt;</code>是头文件，iostream 中的 io 指的 是 输入（ 进入 程序 的 信息） 和 输出（ 从 程序 中 发送 出去 的 信息）。使用 cin 和 cout 进行 输入 和 输出 的 程序 必须 包含 iostream 文件</p><p>（2）<code>using namespace std</code>使用命名空间<code>std</code>。命名空间：名称空间主要作用是避免，在同一个程序不同文件使用了相同名字定义变量或者函数。后面会有命名空间的定义方法。</p><p>（3）<code>cin&gt;&gt;num</code>是将键盘的输入传到变量<code>num</code>。</p><p>（4）<code>cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl</code>是c++打印的语法，或者说是cout与endl的用法。此处与c语言的打印printf使用形式差别很大。<code>cin</code> <code>cout</code>和<code>&lt;&lt;</code>其实是头文件iostream对cout以及符号&lt;&lt;进行了重载，赋予了它新含义，后续会了解到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world,there are "</span>&lt;&lt;num&lt;&lt;<span class="string">" people"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200731131818741.png" alt="image-20200731131818741" style="zoom:80%;" /><h2 id="2-using-namespace"><a href="#2-using-namespace" class="headerlink" title="2.using namespace"></a>2.using namespace</h2><p><code>using</code>是使用名称空间的命令，如<code>using namespace std</code>是使用名称空间<code>std</code>。</p><ul><li><strong>名称空间有什么用：</strong></li></ul><p>顾名思义，名称空间就是一个存放名称的空间。namespace可以比喻成房间，using namespace就像是打开房门的指令，只有打开的房门，才可以从里面拿东西。  名称空间就是如此，建立名称空间就可以使得不同文件里的函数、变量等可以使用相同的名字。</p><ul><li><strong>如何创建名称空间</strong></li></ul><p>其实很简单，就是使用<code>namespace</code>，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把变量、结构体、函数等的声明放在namespace的定义里</span></span><br><span class="line"><span class="comment">//A就是名称空间</span></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">40</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">b</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getperson</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提倡在头文件中使用名称空间</p><ul><li><strong>需要注意的是：</strong></li></ul><p>（1）<code>using namespace std</code>是有作用域的，将<code>using namespace std</code>放置在哪个函数里，便能在哪个函数里使用名称空间std，若是放在所有函数定义之前的位置，则它的作用域就是全局。</p><p>（2）若是不使用<code>using</code>又想使用命名空间里的元素，可以使用<code>::</code>,如<code>std::cout</code></p><p>（3）如果是一个没有名字的名称空间，那名称空间里面的变量、函数只在名称空间所在的文件里有效</p><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p><strong>整型</strong>：bool、 char、 signed char、 unsigned char、 short、 unsigned short、 int、 unsigned int、 long 、unsigned long</p><p><strong>浮点类型：</strong>float、double、long double</p><p>（按照内存位数排序。如 short 至少 为 16 位， 而 int 至少 与 short 一样 长，long至少为32位， 且至少和int一样长。确切 的长度取决于实现）</p><h2 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4.const限定符"></a>4.const限定符</h2><p>（1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A=<span class="number">25</span>;<span class="comment">//相当于宏定义，后面就可以用A代替25了。不同于define的是这个可以放在函数内部从而有特定作用域</span></span><br></pre></td></tr></table></figure><p>（2）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *A=<span class="string">"you"</span>;<span class="comment">//const的作用是限定A在后面不能被重新赋值</span></span><br></pre></td></tr></table></figure><p>（3）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">39</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;a;<span class="comment">//这样定义的指针p不可以通过*p来改变a的值，但是可以改变p的值（即指向）</span></span><br></pre></td></tr></table></figure><p>（4）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">39</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;a;<span class="comment">//这样定义的指针p不可以改变p的值，就是不可以改变p的指向，但是可以通过*p改变a的值</span></span><br></pre></td></tr></table></figure><p>（5）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1=&amp;a;<span class="comment">//合法的，因为变量和指针都使用了const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>* p1=&amp;a;<span class="comment">//不合法的，因变量是const类型，但是指针p1不是，若是合法，那岂不是可以通过*p1改变a的值了？有矛盾</span></span><br></pre></td></tr></table></figure><p>（6）常函数、常对象</p><p>这部分放在了第三部分的第8点，<a href="#11">点我跳转</a></p><h2 id="5-强制类型转换"><a href="#5-强制类型转换" class="headerlink" title="5.强制类型转换"></a>5.强制类型转换</h2><p>在c语言里，强制类型转换的格式是:（typename）value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例如</span><br><span class="line">int a&#x3D;2;</span><br><span class="line">(float) a;&#x2F;&#x2F;将a强制转换为float类型</span><br></pre></td></tr></table></figure><p>而在c++中，格式变换了一下：typename（value）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">float</span>(a);<span class="comment">//新格式的想法是，要让强制类型转换就像是函数调用。</span></span><br></pre></td></tr></table></figure><p>C++ 还 引入了 4个 强制类型转换操作符，(稍后添加)</p><h2 id="6-读取字符串"><a href="#6-读取字符串" class="headerlink" title="6.读取字符串"></a>6.读取字符串</h2><p>当数组存放字符串时，需要注意：</p><p><strong>1.1</strong>  利用cin读取键盘上的字符串到字符数组时，遇到空格、 制表符 和 换行符时，便会结束读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出;</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200731135621632.png" alt="image-20200731135621632" style="zoom:80%;" /><p><strong>1.2</strong> getline(）、get（）</p><p>这两个函数是istream 中的 类（ 如 cin） 提供 了 一些 面向 行的 类 成员 函数：可读取一行输入，直到到达换行符。 然而，随后getline()将丢弃换行符， 而 get() 将 换行符保留在输入序列中。</p><p>(1)getline(）</p><ul><li>用法1：cin. getline(参数1，参数2)。参数1 是 用来 存储 输入 行的 数组 的 名称， 参数2是要 读取 的 字符 数。get()用法一样</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">cin</span>.getline(name,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用法2：getline(cin,string_name);</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1;&#x2F;&#x2F;string用法在1.3</span><br><span class="line">getline(cin,str1);&#x2F;&#x2F;将cin流入str,直到遇上换行符。同时会把换行符吞掉。这里的str1只可以是string类型的。数组名不行</span><br></pre></td></tr></table></figure><h2 id="7-string类"><a href="#7-string类" class="headerlink" title="7.string类"></a>7.string类</h2><p>string类可以直接定义一个变量存储字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1=<span class="string">"my home!"</span>;</span><br></pre></td></tr></table></figure><p>可以直接拼接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1=<span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">string</span> str2=<span class="string">"def"</span>;</span><br><span class="line"><span class="built_in">string</span> str3=str1+str2;</span><br></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8.结构体"></a>8.结构体</h2><p>定义结构体示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span>//<span class="title">name</span>就是结构体类型的名字，类似<span class="title">int</span>、<span class="title">char</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">double</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name A;<span class="comment">//这里的name就是上面那个结构体的类型名</span></span><br></pre></td></tr></table></figure><p>访问成员时，使用符号<code>.</code>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.num</span><br></pre></td></tr></table></figure><p>可以利用数组创建多个结构体对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name B[<span class="number">100</span>];<span class="comment">//则B[0]~B[99]都是结构体对象，引用成员示范：B[0].num</span></span><br></pre></td></tr></table></figure><h2 id="9-使用new操作符"><a href="#9-使用new操作符" class="headerlink" title="9.使用new操作符"></a>9.使用new操作符</h2><p><strong>（1）常规new</strong></p><p>给单个数据申请空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个指针p，指向一个新申请的内存空间，内存空间是int型的，然后就可以给*P赋值了</span></span><br><span class="line"><span class="keyword">int</span> *P=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p=<span class="number">58</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">//用完之后应该用delete进行释放，不然容易造成内存泄漏（就是你申请在这里又不用，浪费）如：</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>给数组申请空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]；<span class="comment">//使用new创建动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应地，用delete []进行释放</span></span><br><span class="line"><span class="keyword">delete</span> [] psome</span><br></pre></td></tr></table></figure><p><strong>（2）布局new</strong></p><p>先看个例子</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/5600997ee95534ce0ac5fe8d57ae775.png" alt="5600997ee95534ce0ac5fe8d57ae775" style="zoom:67%;" /><p>例子中，p1、p3是使用了常规new，p2、p4是使用了布局new</p><p><strong>两者的三点差别：</strong></p><blockquote><p>1.常规new是在堆上面申请内存，而这个布局new是将内存申请在括号里面的数组的地址。</p><p>2.重复使用常规new是不确定位置地在堆上面申请内存，但是布局new是在指定的位置上继续在后面的地址申请。</p><p>3.常规new用delete释放内存，但是这里的布局new不可以，因为数组buffer1与buffer2指定的内存是静态内存。</p></blockquote><h2 id="10-引用"><a href="#10-引用" class="headerlink" title="10.引用"></a>10.引用</h2><p>引用就是给一个变量起别名，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; A=B;<span class="comment">//给B起一个别名：A，以后对A的操作就相当于对B的操作了</span></span><br></pre></td></tr></table></figure><p>引用还有很多应用，比如作为函数参数，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapr</span><span class="params">(<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在这个例子里，使用了引用，作用是把a，b作为传进的参数的别名了。上述函数操作完之后，</span></span><br><span class="line"><span class="comment">a，b对应的变量会改变，如果没有使用引用的话，函数执行并不会改变变量原本的值*/</span></span><br></pre></td></tr></table></figure><p>引用还可以指向结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> sysop &amp; <span class="title">use</span><span class="params">(sysop &amp; sysopref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sysopref.name&lt;&lt;<span class="string">"say:\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sysopref.quote&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sysopref.used++;</span><br><span class="line">    <span class="keyword">return</span> sysopref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*上面是一个参数为结构体引用的函数，而且它的返回值是一个结构体引用。什么意思呢，</span></span><br><span class="line"><span class="comment">如果返回的是普通结构体类型，则函数返回的时候，是将结构体用一个临时空间存起来。中间有一个拷贝的过程，效率低。而引用返回的就是主函数中的结构体（sysopref是它的别名）*/</span></span><br></pre></td></tr></table></figure><h2 id="11-static"><a href="#11-static" class="headerlink" title="11.static"></a>11.static</h2><p><strong>作用：</strong></p><p><strong>（1）全局静态变量</strong></p><p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</p><p><u>作用域</u>：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p><p><strong>（2）局部静态变量</strong></p><p>在局部变量（比如函数里面的变量）之前加上关键字static，局部变量就成为一个局部静态变量。</p><p><u>作用域</u>：作用域仍为局部作用域（只在函数内部有效）。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p><p><strong>（1）（2）可以总结成下表格</strong></p><table><thead><tr><th>类别</th><th>位置及使用方法</th><th>作用域</th></tr></thead><tbody><tr><td>全局变量</td><td>在函数外面，不使用static</td><td>所在文件以及其他文件</td></tr><tr><td>全局静态变量</td><td>在函数外面，使用static</td><td>所在文件</td></tr><tr><td>局部静态变量</td><td>在函数里面，使用static</td><td>所在函数</td></tr></tbody></table><p><strong>（1）（2）点使用举例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="comment">//a的作用域是所在文件以及其他文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">2</span>;<span class="comment">//b的作用域是所在文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c=<span class="number">3</span>;<span class="comment">//c作用域是fun1</span></span><br><span class="line">    <span class="keyword">int</span> d=<span class="number">4</span>;<span class="comment">//d域也是fun1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）静态函数</strong></p><p>在函数返回类型前加static，函数就定义为静态函数。</p><p><u>作用域：</u>静态函数只是在声明他的文件当中可见，不能被其他文件所用，故不会同其他cpp中的同名函数引起冲突。（函数的定义和声明在没加static的默认情况下，其他文件是能链接到的）</p><p><u>注意</u>：为了规范，不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数</p><p><strong>（4） 类的静态成员</strong></p><p>在类定义时，若某个成员属性前面用了static修饰，那之后这个类创建的所有对象的此成员属性都使用同一个内存空间，即值都是相等的。若在对象1对该成员属性进行了更改，其他对象的该成员属性也会变化。（简单来说，就是数据共享了）</p><p><strong>（5）类的静态函数</strong></p><p>在类定义时，若某个成员函数前面用了static修饰，此成员函数就是类的静态函数</p><p>在静态成员函数的实现中<u>不能直接引用</u>类中说明的非静态成员，可以引用类中的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p><h2 id="12-枚举"><a href="#12-枚举" class="headerlink" title="12.枚举"></a>12.枚举</h2><p>枚举使用关键字enum</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;;</span><br></pre></td></tr></table></figure><p>这条语句完成两项工作：</p><p>●　让 spectrum 成为新类型的名称； spectrum 被称为枚举（ enumeration），就像 struct 变量被称为结构一样。</p><p>●　将 red、 orange、 yellow 等作为符号常量，它们对应整数值0〜7。这些常量叫作枚举量（ enumerator）。</p><p>在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。</p><h2 id="10-编程小知识"><a href="#10-编程小知识" class="headerlink" title="10.编程小知识"></a>10.编程小知识</h2><p>这部分是介绍c++编程时的一些小知识</p><p><strong>（1）system(“pause”);</strong></p><p>暂停程序的执行，等待任意健继续执行。</p><p><strong>（2）system(“cls”);</strong></p><p>将上一次运行输出的内容给清除掉</p><p>*<em>（3）#pragma once *</em></p><p>防止头文件重复包含</p><h1 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h1><h2 id="1-内联函数"><a href="#1-内联函数" class="headerlink" title="1.内联函数"></a>1.内联函数</h2><p><strong>作用</strong>：内联函数的作用与宏定义define很像，调用了内联函数的地方，系统在编译的时候会直接把<code>调用的语句</code>替换成<code>内联函数的定义内容</code>。 内联函数是C++为提高程序运行速度所做的一项改进。作用简单来说就是用空间换时间。</p><p><strong>空间换时间解释：</strong>执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。</p><p><strong>语法：</strong></p><p><em>定义函数</em>与<em>声明函数</em>需要使用关键字<code>inline</code></p><p>内联函数与常规函数的定义规则一样的，只是定义与调用的时候需要使用关键字<code>inline</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个加法函数，并且设置为内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add_3_num</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add_3_num(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//这里的调用，系统编译时会直接替换成上面的定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><p>内联只是给编译器的建议，比如函数体过大时，编译器不一定就会使用内联，例如存在循环语句、存在过多判断语句。</p><h2 id="2-函数默认参数"><a href="#2-函数默认参数" class="headerlink" title="2.函数默认参数"></a>2.函数默认参数</h2><p>c++支持给函数添加默认参数，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_3_num</span><span class="params">(<span class="keyword">int</span> a=<span class="number">10</span>, <span class="keyword">int</span> b=<span class="number">20</span>, <span class="keyword">int</span> c=<span class="number">30</span>)</span><span class="comment">//a,b,c的默认参数是10、20、30，函数调用时如果没传入参数，就取默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以只给后面部分参数设置参数值，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_3_num</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c=<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的时候需要传入至少两个参数，比如add_3_num(1,2)</span></span><br></pre></td></tr></table></figure><h2 id="3-函数模板"><a href="#3-函数模板" class="headerlink" title="3.函数模板"></a>3.函数模板</h2><p><strong>语法：</strong></p><p>系统会根据啊，a，b的数据类型把T更换成对应的数据类型。所以这里的a，b的数据类型需要相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数模板声明*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//<span class="title">class</span>也可以换成<span class="title">typename</span>，这里的<span class="title">T</span>不一定需要是<span class="title">T</span>，与下面对应就可以。（但是一般使用<span class="title">T</span>，约定俗成）</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fun</span>(<span class="title">T</span> &amp;<span class="title">a</span>, <span class="title">T</span> &amp;<span class="title">b</span>);</span><span class="comment">//有需要时，函数返回类型也可以使用T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数模板定义*/</span></span><br><span class="line"><span class="comment">/*这里就定义一个数据交换的函数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">fun</span>(<span class="title">T</span> &amp;<span class="title">a</span>,<span class="title">T</span> &amp;<span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T tmp;</span><br><span class="line">    tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、类"><a href="#三、类" class="headerlink" title="三、类"></a>三、类</h1><p>类是c++中的重点内容，也是c++相对于c语言，新增的内容，需要重点掌握</p><h2 id="1-什么是类"><a href="#1-什么是类" class="headerlink" title="1.什么是类"></a>1.什么是类</h2><p>类，往往是具有一些共同属性的事物集合。比如，圆可以抽象成一个类，这个类包含和半径，周长，面积等成员，每一个具体的圆就是一个具体的对象。人也可以抽象成一个类（所以叫人类？哈哈），而每一个具体的人就是一个具体的对象。</p><h2 id="2-如何创建简单类"><a href="#2-如何创建简单类" class="headerlink" title="2.如何创建简单类"></a>2.如何创建简单类</h2><p><strong>格式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/*private部分外界无法直接更改与调用，只有使用了public关键字的部分，外界才可以直接调用。</span></span><br><span class="line"><span class="comment">但是可以在public部分添加可以更改private数据的函数，然后外界通过调用public部分的成员函数，</span></span><br><span class="line"><span class="comment">对private数据进行更改*/</span></span><br><span class="line"><span class="keyword">private</span>：<span class="comment">//私有部分,这里一般放不希望被直接更改或调用的数据，一般成员属性设置为私有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>：<span class="comment">//共有部分，不使用public的话默认private属性,这里放可以被调用的函数，一般成员函数设置为共有</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>(1)创建一个简单的圆类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_l</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*pi*r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用简单类"><a href="#3-使用简单类" class="headerlink" title="3.使用简单类"></a>3.使用简单类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>//<span class="title">Circle</span>就是类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">set_r</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            r=a;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_l</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*<span class="number">3.14</span>*r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle c1;<span class="comment">//使用类创建一个具体对象c1</span></span><br><span class="line">    <span class="keyword">int</span> c_r;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c_r;</span><br><span class="line">    c1.set_r(c_r);<span class="comment">//把c_r的值赋值给c1的半径r</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"半径是："</span>&lt;&lt;c_r&lt;&lt;<span class="string">","</span>&lt;&lt;<span class="string">"周长是："</span>&lt;&lt;c1.calculate_l()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用成员时，需要使用"."进行连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出：</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200801133221798.png" alt="image-20200801133221798"></p><h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h2><p>就是类里面的一个函数，用来<strong>初始化类的私有数据</strong>，名字与类的名字一样。一般类有多少个变量，构造函数就有多少个参数。</p><p>构造函数有：无参构造函数、有参构造函数、拷贝构造函数。（其实这里就是用到了函数重载）</p><p><strong>（1）语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//构造函数必须放在public里，不然外界无法调用</span></span><br><span class="line">    <span class="comment">//无参构造函数,这也是类的默认构造函数</span></span><br><span class="line">        Circle()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里面就是无参构造函数初始化内容，根据实际需求编写</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Circle(<span class="keyword">int</span> a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里面就是有参构造函数初始化内容，根据实际需求编写</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数，作用就是根据引用的对象数据来初始化</span></span><br><span class="line">    Circle(<span class="keyword">const</span> Circle &amp; a)<span class="comment">//这里的const是必须的，保证引用的对象不会被更改</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里面就是拷贝构造函数初始化内容，根据实际需求编写</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*调用*/</span></span><br><span class="line"><span class="comment">/*下面的调用都只是举例，实际调用时的参数需要根据具体情况填写对应的类型、数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*括号引用法*/</span></span><br><span class="line">    <span class="comment">//无参构造函数调用,不需要括号</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//有参构造函数调用</span></span><br><span class="line">    Circle c1(3)；</span><br><span class="line">    <span class="comment">//拷贝构造函数调用</span></span><br><span class="line">    <span class="function">Circle <span class="title">c2</span><span class="params">(c1)</span></span>;<span class="comment">//假如c1已经存在且初始化了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*显式引用法*/</span></span><br><span class="line">    <span class="comment">//有参构造函数调用</span></span><br><span class="line">    Circle c1=Circle(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//拷贝构造函数调用</span></span><br><span class="line">    Circle c2=Circle(c1);<span class="comment">//假如c1已经存在且初始化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）初始化列表：</strong></p><p>构造函数有可以利用初始化列表语法进行初始化，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：构造函数：属性（参数），属性（参数），属性（参数）.....</span></span><br><span class="line"><span class="comment">//a,b,c的值就会赋值给c_a、c_b、c_c</span></span><br><span class="line">Circle (<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):c_a(a),c_b(b),c_c(c)<span class="comment">//这里的c_a、c_b、c_c假设是Circle的成员属性</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）explicit关键字</strong></p><p>在构造函数定义中使用 explicit 可防止隐式转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用explicit</span></span><br><span class="line">Circle(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    r=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用explicit</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r=a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么是隐式类型转换？比如</span></span><br><span class="line">Circle c1=<span class="number">1</span>;<span class="comment">//这就是隐式类型转换，这种初始化的含义并不是很明确，如果使用了explicit，那直接使用下面这种显式初始化</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><p>1.当我们提供了有参构造函数，系统就不会提供默认构造函数，但是会提供默认拷贝函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也就是如果我们只定义了</span></span><br><span class="line"> Circle(<span class="keyword">int</span> a):r(a)</span><br><span class="line"> &#123;</span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//没有定义</span></span><br><span class="line">Circle()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么创建对象的时候就一定要传入参数</span></span><br><span class="line"><span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//可行</span></span><br><span class="line">Circle c1;<span class="comment">//不可行，因为系统不会自动提供默认构造函数了</span></span><br></pre></td></tr></table></figure><p>2.当我们提供了拷贝构造函数，系统就不会提供任何默认构造函数。</p><h2 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5.析构函数"></a>5.析构函数</h2><p>对象过期时， 程序将自动调用一个特殊的成员函数—— 析构函数。析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与类名相同，在类名前面加一个“~”，没有返回值，不写void，不可以有参数</span></span><br><span class="line">~Circle()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里面不需要写什么内容，不过有时候为了能看到析构函数的调用时间，可以添加一些输出语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-static在类中使用"><a href="#6-static在类中使用" class="headerlink" title="6.static在类中使用"></a>6.static在类中使用</h2><p>static可以定义静态成员属性以及静态成员函数，可跳转“基础—static”部分查看</p><h2 id="7-this指针"><a href="#7-this指针" class="headerlink" title="7.this指针"></a>7.this指针</h2><p>this指针是一种隐含指针，它隐含于每个类的<u>非静态成员函数</u>（静态成员函数使用的是同一块内存空间，不需要this）中，this指针指向调用成员函数的对象。</p><p>比如，<code>c1.a(c2)</code>将this设置指向<code>c1</code>对象的指针，需要时就可以调用。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*示例1*/</span></span><br><span class="line"><span class="comment">//定义一个比较两个圆的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compare_r</span><span class="params">(Circle &amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;r==c.r)<span class="comment">//这里的this就是指向这个成员函数所在的对象。因此当需要将自身与其他对象比较的时候就很有用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"半径相同"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*示例2*/</span></span><br><span class="line"><span class="function">Circle &amp; <span class="title">compare_r</span><span class="params">(Circle &amp; c)</span><span class="comment">//返回值是一个对象（一定要用Circle &amp;,不然返回的只是这个对象拷贝出来的值）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;r==c.r)<span class="comment">//这里的this就是指向这个成员函数所在的对象。因此当需要将自身与其他对象比较的时候就很有用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">c1.compare_r(c2).compare_r(c3);<span class="comment">//这个就实现了先比较c1与c2的半径大小，然后半径大的再和c3比较。</span></span><br><span class="line"><span class="comment">//这里假如c1半径比较大，那就相当于c1.compare_r(c3)</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>（1）空指针问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果创建对象的时候是下面这样</span></span><br><span class="line">Circle * p=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;set_r(<span class="number">1</span>);<span class="comment">//set_r是设置半径的成员函数，这里看起来没什么问题，但是却执行不了，原因如下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_r</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*这里其实编译器是这样做的:this-&gt;r=a;但是由于创建对象的语句：Circle * p=NULL;</span></span><br><span class="line"><span class="comment">    其实已经把this=NULL了，因此r=a；这语句无法执行*/</span></span><br><span class="line">r=a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免执行不了程序宕机的情况下，经常加一个判断语句</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_r</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//直接返回，虽然这个函数依旧没有执行，但是避免了程序卡死的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">r=a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-常函数、常对象"><a href="#8-常函数、常对象" class="headerlink" title="8.常函数、常对象     "></a>8.常函数、常对象   <span id="11">  </span></h2><p>常函数与常对象需要使用<code>const</code>关键字 </p><p><strong>常函数：</strong>不允许修改指针指向的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_r</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span><span class="comment">//在成员函数头最后添加了const，就可以定义为常函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">r=a;<span class="comment">//r=a将会报错，因为r=a实际上是this-&gt;r=a,这修改了指针指向的值，是常函数不允许的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常对象：</strong>不允许修改成员属性，也不可以调用普通成员函数（可以调用常函数，但是常函数又改不了属性，所以其实差不多）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如创建对象时是使用const</span></span><br><span class="line"><span class="keyword">const</span> Circle c1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c1.set_r(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//无法执行，因为set_r()无法调用</span></span><br></pre></td></tr></table></figure><h2 id="9-友元"><a href="#9-友元" class="headerlink" title="9.友元"></a>9.友元</h2><p><strong>（1）友元函数</strong></p><p>就是可以在类定义里添加一个函数声明，它不是成员函数，但是它有与成员函数一样的操作权限（就是可以更改私有数据等），这种函数叫做友元函数。</p><p>声明如下：（多了个friend）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.把全局函数设置成友元函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">take_r</span><span class="params">()</span></span>;<span class="comment">//这个声明需要放到类中去。</span></span><br><span class="line"><span class="comment">//也就是普通的函数，你在它的声明前面添加friend并且放到类中，就可以称为类的友元函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.把其他类的成员函数设置成友元函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Square::set_l</span><span class="params">()</span></span>;<span class="comment">//假如这里的Square是一个正方形类，set_l（）是他的成员函数</span></span><br></pre></td></tr></table></figure><p>但是记住，他不是成员函数，所以成员函数特有的使用方式它不可以使用。比如“.”</p><p><strong>一个重要作用：用来重载”&lt;&lt;”</strong></p><p>我们都知道cout&lt;&lt;可以用来显示很多类型，十分方便。但其实，cout&lt;&lt;就是通过操作符重载来实现的，面对不同的类型，&lt;&lt;有不同的重载。如果想实现cout&lt;&lt;A（A是一个存储时间的类），那怎么办？这时候就可以通过重载&lt;&lt;实现，但是如果通过普通的方法，在Time类里重载&lt;&lt;，那就要写出A&lt;&lt;cout，这很奇怪。这个时候友元函数就有用了，因为友元函数两个参数的位置不一定，因为A与cout都只是参数而已</p><p><strong>（2）友元类</strong></p><p>声明与友元函数一样，使用关键字friend</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如想Circle类成为其他类的友元，就在其他类中添加下列语句</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span>;</span></span><br></pre></td></tr></table></figure><h1 id="四、重载"><a href="#四、重载" class="headerlink" title="四、重载   "></a>四、重载 <span id="chongzai">  </span></h1><h2 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="1.函数重载"></a>1.函数重载</h2><p><strong>（1）作用：</strong></p><p>函数重载就有点类似汉语中的多音字，同一个字在不同语句中有不同的意思。利用函数重载可以使得同一个函数名可以根据参数的不同（比如<u>参数类型、数目，顺序的不同</u>）采用不同的函数内容。</p><p><strong>（2）语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如下列例子，调用print函数时，系统会根据print传进的参数决定使用哪一个。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//函数内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）注意</strong></p><p>当同时使用了函数重载以及默认参数时，应该注意有没有二义性，看下列例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用fun(1),就会产生二义性，上下两个都满足</span></span><br></pre></td></tr></table></figure><h2 id="2-操作符重载"><a href="#2-操作符重载" class="headerlink" title="2.操作符重载"></a>2.操作符重载</h2><h3 id="1-加号运算符重载"><a href="#1-加号运算符重载" class="headerlink" title="1.加号运算符重载"></a>1.加号运算符重载</h3><p>c++的语法提供的操作符（加减乘除求余这些）的作用都是固定的，比如<code>+</code>只能对变量类型进行相加，而不能相加一些我们自己创建的一些数据类型，比如时间，日期这些类。但是c++提供了操作符重载，用来弥补这些不足。简单来说，就是我们可以DIY操作符的功能。</p><p><strong>语法：</strong></p><p>要点：定义一个函数，使用关键字<code>operator</code>，函数设置为类的友元函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假如我要重载“+”，使得两个圆对象相加时，是将他们的半径相加*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//把操作符重载函数设置为类的友元函数，不然它作为全局函数访问不到类</span></span><br><span class="line">        <span class="keyword">friend</span> Circle <span class="keyword">operator</span>+(Circle &amp; c1,Circle &amp; c2);</span><br><span class="line">        <span class="comment">//默认构造函数</span></span><br><span class="line">        Circle()</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">        Circle(<span class="keyword">int</span> a):r(a)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="comment">//半径修改函数</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">set_r</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            r=a;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//半径打印函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义一个全局函数，实现加号重载</span></span><br><span class="line">Circle <span class="keyword">operator</span>+(Circle &amp; c1,Circle &amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">    Circle tmp;</span><br><span class="line">    tmp.set_r(c1.r+c2.r);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试加号重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Circle <span class="title">c2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    Circle c3=c1+c2;</span><br><span class="line">    c3.show_r();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200804111206957.png" alt="image-20200804111206957" style="zoom:80%;" /><h3 id="2-左移运算符重载"><a href="#2-左移运算符重载" class="headerlink" title="2.左移运算符重载"></a>2.左移运算符重载</h3><p>基本上我们刚接触c++的时候就会看到<code>cout&lt;&lt;....&lt;&lt;endl;</code>,这语句是用来输出的。其中的原理就是对左移运算符<code>&lt;&lt;</code>进行了重载。但是，系统提供的重载有限，因此有时候我们想使用<code>cout&lt;&lt;....&lt;&lt;endl;</code>来输出我们自定义的一些数据类型，就要自己对<code>&lt;&lt;</code>进行重载</p><p><strong>语法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的重载其实和上面的加号重载语法基本相同，那我在这里就不写那么详细了</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(osteam&amp; <span class="built_in">cout</span>,Circle&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c.r"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的返回类型为什么需要返回ostream:因为最后需要return cout，这样才可以在一个语句中使用&lt;&lt;连续输出</span></span><br></pre></td></tr></table></figure><h3 id="3-不要重载-amp-amp-和"><a href="#3-不要重载-amp-amp-和" class="headerlink" title="3.不要重载&amp;&amp; 和||"></a>3.不要重载&amp;&amp; 和||</h3><p>原因就是实现不了，可以自己试试</p><h1 id="五、继承"><a href="#五、继承" class="headerlink" title="五、继承"></a>五、继承</h1><p>不同类之间可以继承。继承的作用就是可以复用其他类，减少代码的量。</p><h2 id="1-继承方式"><a href="#1-继承方式" class="headerlink" title="1.继承方式"></a>1.继承方式</h2><p>有公有继承，保护继承，私有继承。几种继承的区别可以看下列</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//公有继承，保护继承，私有继承都无法继承父类的私有部分</span></span><br><span class="line"><span class="comment">//:public A就是代表公有继承A</span></span><br><span class="line"><span class="comment">//公有继承。公有属性与保护属性不变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//保护继承。父类的所有成员都变成保护属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">protected</span> A;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//私有继承。父类的所有成员都变成私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-继承的构造与析构"><a href="#2-继承的构造与析构" class="headerlink" title="2.继承的构造与析构"></a>2.继承的构造与析构</h2><p>（1）子类不会继承父类（基类）的构造函数以及析构函数。因此需要给子类再添加构造函数以及析构函数。</p><p>（2）但是，在子类创建对象的时候，会先调用父类的构造函数，再调用子类的构造函数。</p><p>（3）在析构时，会先调用子类的析构函数再调用父类的析构函数。与构造函数顺序相反。</p><h2 id="3-继承中同名成员处理"><a href="#3-继承中同名成员处理" class="headerlink" title="3.继承中同名成员处理"></a>3.继承中同名成员处理</h2><p>假如父类中有一成员名称为A，子类中又定义了一成员A，那么直接调用的话，是调用子类。</p><p>如果想使用父类的同名函数，可以加上作用域指定，格式：<code>子类对象名.父类的类名::成员名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//半径打印函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"父类的r"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle1</span>:</span><span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Circle1()</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"子类的r "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle1 c;</span><br><span class="line">    c.set_r(<span class="number">2</span>);</span><br><span class="line">    c.show_r();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，输出就是“子类的r”，调用的是子类的函数</span></span><br><span class="line"><span class="comment">//如果想使用父类的同名函数，可以加上作用域指定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle1 c;</span><br><span class="line">    c.set_r(<span class="number">2</span>);</span><br><span class="line">    c.Circle::show_r();<span class="comment">//这里不一样了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-多继承"><a href="#4-多继承" class="headerlink" title="4.多继承"></a>4.多继承</h2><p>多继承也就是继承多个类，语法也很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A,<span class="keyword">public</span> B<span class="comment">//继承A和B</span></span><br></pre></td></tr></table></figure><p>多继承的用法与单继承差不多，需要注意的是多继承的二义性问题：父类A和父类B有同名成员。</p><p>解决方法：使用作用域，与上一点的子类父类同名用法一样。使用<code>子类对象名.父类的类名::成员名</code></p><h1 id="六、多态"><a href="#六、多态" class="headerlink" title="六、多态"></a>六、多态</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>（1）多态是什么：</strong></p><p><strong>（2）多态的分类：</strong></p><blockquote><p><strong>1) 静态多态</strong>：可以称为编译期多态，它是在编译期间通过<u>函数重载</u>和<u>操作符重载</u>的方式决定被调用函数。<br><strong>2) 动态多态</strong>：可以称为运行期多态，它可以通过<u>继承</u>和<u>虚函数</u>来实现。实现时，编译器将在进程运行的过程中动态的捆绑想要调用的函数 。</p></blockquote><h2 id="2-静态多态"><a href="#2-静态多态" class="headerlink" title="2.静态多态"></a>2.静态多态</h2><p>静态多态的函数重载以及操作符重载前面已经写了，在多态这一部分就不再啰嗦了。可以点击<a href="#chongzai">重载</a>查看相关内容</p><h2 id="3-动态多态"><a href="#3-动态多态" class="headerlink" title="3.动态多态"></a>3.动态多态</h2><p>动态多态依靠<u>继承</u>以及<u>虚函数</u>来实现。继承前面已经介绍，那么接下来介绍<u>虚函数</u>。</p><h3 id="3-1虚函数"><a href="#3-1虚函数" class="headerlink" title="3.1虚函数"></a>3.1虚函数</h3><p>（1）虚函数的作用：使函数不是在编译的时候就已经确定运行时机，而是在运行的时候动态绑定</p><p>虚函数是通过在继承中的父类成员函数前添加<code>virtual</code>关键字，可以实现子类重定义虚函数之后，直接调用虚函数是调用子类。说起来很难理解，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们使用一个计算器类来举例,先在父类中添加虚函数。之后每次添加功能再创建一个子类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">calculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">result</span> <span class="params">()</span><span class="comment">//把result定义为虚函数。其实这个虚函数并不实现什么，只是给子类提供派生接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setv1</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//给value1赋值的成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value1=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setv2</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//给value2赋值的接口函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value2=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，用来实现加法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">plus_calculator</span>:</span><span class="keyword">public</span> calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span><span class="comment">//在子类重写虚函数（函数头需要与父类相同）virtual可写可不写（建议写方便阅读），并且编写函数内容</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value1+value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">minus_calculator</span>:</span><span class="keyword">public</span> calculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value1-value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calculator * p;</span><br><span class="line">    </span><br><span class="line">    p=<span class="keyword">new</span> plus_calculator;<span class="comment">//用父类指针指向加法子类</span></span><br><span class="line">    p-&gt;setv1(<span class="number">10</span>);</span><br><span class="line">    p-&gt;setv2(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;result()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    </span><br><span class="line">    p=<span class="keyword">new</span> minus_calculator;<span class="comment">//用父类指针指向减法子类</span></span><br><span class="line">    p-&gt;setv1(<span class="number">10</span>);</span><br><span class="line">    p-&gt;setv2(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;result()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>（2）纯虚函数：</strong></p><p>父类中的虚函数除了像上面例子那样定义，还可以定义为纯虚函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">result</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//改成</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">result</span> <span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>但是使用了纯虚函数，需要注意以下几点：</p><blockquote><p>(1)如果父类中有纯虚函数，子类继承父类，就必须实现纯虚函数（就是必须在子类写个有内容的虚函数）</p><p>(2)如果父类中有了纯虚函数，就是一个抽象类，这个父类就无法示例化对象了。（就是没办法创建父类的对象了）</p></blockquote><p><strong>（3）虚析构</strong></p><p>在对父类的析构没使用<code>virtual</code>关键字时，是普通析构，普通析构是不会调用子类的析构函数的。比如上面的例子，是不会调用加法减法类的析构函数的。</p><p><u>想要系统也调用子类的析构函数的话，可以在父类的析构函数前面添加<code>virtual</code>关键字。</u></p><h1 id="七、STL"><a href="#七、STL" class="headerlink" title="七、STL"></a>七、STL</h1><p>STL全称是：standard Template Library(标准模板库)</p><p><strong>STL六大组件简介：</strong></p><blockquote><p><strong>1.容器：</strong>容器是一个与数组类似的单元，可以存储若干个值。 STL 容器是同质的，即存储的值的类型相同</p><p><strong>2.算法：</strong>算法是完成特定任务（如对数组进行排序或在链表中查找特定值）</p><p><strong>3.迭代器：</strong>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针</p><p>4.仿函数：5.适配器。6.空间配置器 </p></blockquote><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1.容器"></a>1.容器</h2><h3 id="1-1-string容器"><a href="#1-1-string容器" class="headerlink" title="1.1 string容器"></a>1.1 string容器</h3><h4 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h4><p><strong>头文件</strong>：</p><p>string</p><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><h4 id="1-1-2-构造函数"><a href="#1-1-2-构造函数" class="headerlink" title="1.1.2 构造函数"></a>1.1.2 构造函数</h4><p><strong>构造函数原型：</strong></p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;</li><li><code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'a'</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-赋值操作"><a href="#1-1-3-赋值操作" class="headerlink" title="1.1.3 赋值操作"></a>1.1.3 赋值操作</h4><p><strong>赋值的函数原型：</strong></p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line">str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2 = "</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str4;</span><br><span class="line">str4.assign(<span class="string">"hello c++"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str4 = "</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str5;</span><br><span class="line">str5.assign(<span class="string">"hello c++"</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str5 = "</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str6 = "</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str7;</span><br><span class="line">str7.assign(<span class="number">5</span>, <span class="string">'x'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str7 = "</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-4-拼接"><a href="#1-1-4-拼接" class="headerlink" title="1.1.4 拼接"></a>1.1.4 拼接</h4><p><strong>拼接函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s);</code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">"我"</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">"爱玩游戏"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">':'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"LOL DNF"</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">"I"</span>;</span><br><span class="line">str3.append(<span class="string">" love "</span>);</span><br><span class="line">str3.append(<span class="string">"game abcde"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str3 = "</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-5-查找和替换"><a href="#1-1-5-查找和替换" class="headerlink" title="1.1.5 查找和替换"></a>1.1.5 查找和替换</h4><p><strong>函数原型：</strong></p><p><u>find:</u>从左往右查找</p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>                       //查找字符c第一次出现位置</li></ul><p><u>rfind:</u>从右往左查找</p><ul><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>                      //查找字符c最后一次出现位置</li></ul><p><u>replace:</u>替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</p><ul><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">"abcdefgde"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">"de"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos = "</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.rfind(<span class="string">"de"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"pos = "</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">"abcdefgde"</span>;</span><br><span class="line">str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"1111"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str1 = "</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-6-比较"><a href="#1-1-6-比较" class="headerlink" title="1.1.6 比较"></a>1.1.6 比较</h4><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"aello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1 等于 s2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-7-存取"><a href="#1-1-7-存取" class="headerlink" title="1.1.7 存取"></a>1.1.7 存取</h4><p><strong>函数原型：</strong>（两种方式）</p><ul><li><code>char&amp; operator[](int n);</code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);</code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hello world"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过[]方式取字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过at方法获取字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line">str.at(<span class="number">1</span>) = <span class="string">'x'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-8-插入与删除"><a href="#1-1-8-插入与删除" class="headerlink" title="1.1.8 插入与删除"></a>1.1.8 插入与删除</h4><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">str.insert(<span class="number">1</span>, <span class="string">"111"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-9-获取子串"><a href="#1-1-9-获取子串" class="headerlink" title="1.1.9 获取子串"></a>1.1.9 获取子串</h4><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"subStr = "</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">"hello@sina.com"</span>;</span><br><span class="line"><span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">"@"</span>);</span><br><span class="line"><span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"username: "</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-vector容器"><a href="#1-2-vector容器" class="headerlink" title="1.2 vector容器"></a>1.2 vector容器</h3><h4 id="1-2-1-简介"><a href="#1-2-1-简介" class="headerlink" title="1.2.1 简介"></a>1.2.1 简介</h4><p><strong>头文件：</strong>vector</p><p><strong>功能：</strong>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector与普通数组区别：</strong></p><p>不同之处在于数组是静态空间，而vector可以动态扩展</p><p><strong>动态扩展：</strong></p><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p><p><strong>图示：</strong></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/clip_image002.jpg" alt="clip_image002"></p><h4 id="1-2-2-构造函数"><a href="#1-2-2-构造函数" class="headerlink" title="1.2.2 构造函数"></a>1.2.2 构造函数</h4><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个打印函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-赋值操作"><a href="#1-2-3-赋值操作" class="headerlink" title="1.2.3 赋值操作"></a>1.2.3 赋值操作</h4><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.assign(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-容量与长度"><a href="#1-2-4-容量与长度" class="headerlink" title="1.2.4 容量与长度"></a>1.2.4 容量与长度</h4><p><strong>函数原型：</strong></p><ul><li><p><code>empty();</code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //返回容器的容量</p></li><li><p><code>size();</code>                              //返回容器长度，即元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                                                //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    <span class="comment">//填充元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1不为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的容量 = "</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的大小 = "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.resize(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.resize(<span class="number">5</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>分清楚容量和长度（大小）</p><h4 id="1-2-5-插入和删除"><a href="#1-2-5-插入和删除" class="headerlink" title="1.2.5 插入和删除"></a>1.2.5 插入和删除</h4><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.push_back(<span class="number">10</span>);</span><br><span class="line">v1.push_back(<span class="number">20</span>);</span><br><span class="line">v1.push_back(<span class="number">30</span>);</span><br><span class="line">v1.push_back(<span class="number">40</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.insert(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">v1.insert(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.erase(v1.<span class="built_in">begin</span>());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.erase(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-6-存取数据"><a href="#1-2-6-存取数据" class="headerlink" title="1.2.6 存取数据"></a>1.2.6 存取数据</h4><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>       //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的第一个元素为： "</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的最后一个元素为： "</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-7-容器元素互换"><a href="#1-2-7-容器元素互换" class="headerlink" title="1.2.7 容器元素互换"></a>1.2.7 容器元素互换</h4><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换，还会根据vec的容量以及长度变化自身容量和长度</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"互换后"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v.resize(<span class="number">3</span>);<span class="comment">//调整大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存，根据v的大小重新创建了一个容量和大小都与v相同的新v</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-8-预留空间"><a href="#1-2-8-预留空间" class="headerlink" title="1.2.8 预留空间"></a>1.2.8 预留空间</h4><p>如果数据量较大，可以一开始利用reserve预留空间</p><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><h3 id="1-3-deque容器"><a href="#1-3-deque容器" class="headerlink" title="1.3 deque容器"></a>1.3 deque容器</h3><h4 id="1-3-1-简介"><a href="#1-3-1-简介" class="headerlink" title="1.3.1 简介"></a>1.3.1 简介</h4><p><strong>头文件</strong>：deque</p><p><strong>功能：</strong>双端数组，可以对头端进行插入删除操作</p><p><strong>deque与vector区别：</strong></p><ul><li>deque没有容量概念</li><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/clip_image002-1547547642923.jpg" alt="clip_image002-1547547642923"></p><div align="center"> deque与vector用法很多相同的地方，这里就不一一举例了</div><h4 id="1-3-2-常用函数"><a href="#1-3-2-常用函数" class="headerlink" title="1.3.2 常用函数"></a>1.3.2 常用函数</h4><p><strong>构造函数：</strong></p><ul><li><p><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</p></li><li><p><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</p></li><li><p><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</p></li><li><p><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</p><p><strong>赋值：</strong></p></li><li><p><code>deque&amp; operator=(const deque &amp;deq);</code>         //重载等号操作符</p></li></ul><ul><li><p><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</p><p><strong>大小：</strong></p></li><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>插入和删除：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p><p><strong>数据存取：</strong></p></li></ul><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>      //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>排序：</strong></p><p><strong>头文件</strong>：使用sort需要包含头文件algorithm</p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><h3 id="1-4-stack容器"><a href="#1-4-stack容器" class="headerlink" title="1.4 stack容器"></a>1.4 stack容器</h3><h4 id="1-4-1简介"><a href="#1-4-1简介" class="headerlink" title="1.4.1简介"></a>1.4.1简介</h4><p><strong>概念：</strong> stack就是栈，是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口。栈中进入数据称为  — <strong>入栈</strong>  <code>push</code>，栈中弹出数据称为  — <strong>出栈或弹栈</strong>  <code>pop</code></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/%E6%A0%88%E5%9B%BE.jpg" alt="栈图"></p><h4 id="1-4-2-常用函数"><a href="#1-4-2-常用函数" class="headerlink" title="1.4.2 常用函数"></a>1.4.2 常用函数</h4><p><strong>构造函数：</strong></p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p><strong>数据存取：</strong></p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top();</code>                //返回栈顶元素</li></ul><p><strong>大小操作：</strong></p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><h3 id="1-5-queue容器"><a href="#1-5-queue容器" class="headerlink" title="1.5 queue容器"></a>1.5 queue容器</h3><h4 id="1-5-1-简介"><a href="#1-5-1-简介" class="headerlink" title="1.5.1 简介"></a>1.5.1 简介</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口。允许从一端新增元素，从另一端移除元素。队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    ，<code>push</code>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/queue.jpg" alt="queue"></p><h4 id="1-5-2-常用函数"><a href="#1-5-2-常用函数" class="headerlink" title="1.5.2 常用函数"></a>1.5.2 常用函数</h4><p><strong>构造函数：</strong></p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p><strong>数据存取：</strong></p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front();</code>                                  //返回第一个元素</li></ul><p><strong>大小操作：</strong></p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><h3 id="1-6-list容器"><a href="#1-6-list容器" class="headerlink" title="1.6 list容器"></a>1.6 list容器</h3><h4 id="1-6-1-简介"><a href="#1-6-1-简介" class="headerlink" title="1.6.1 简介"></a>1.6.1 简介</h4><p><strong>头文件</strong>：list</p><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>list的优点：</strong></p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><strong>list的缺点</strong>：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><h4 id="1-6-2-常用函数"><a href="#1-6-2-常用函数" class="headerlink" title="1.6.2 常用函数"></a>1.6.2 常用函数</h4><p><strong>构造函数：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>赋值与交换：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符，实现赋值</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>大小操作：</strong></p><ul><li><p><code>size();</code>                             //返回容器中元素的个数</p></li><li><p><code>empty();</code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem);</code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>插入和删除：</strong></p><ul><li><code>push_back(elem);</code>//在容器尾部加入一个元素</li><li><code>pop_back();</code>//删除容器中最后一个元素</li><li><code>push_front(elem);</code>//在容器开头插入一个元素</li><li><code>pop_front();</code>//从容器开头移除第一个元素</li><li><code>insert(pos,elem);</code>//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code>//移除容器的所有数据</li><li><code>erase(beg,end);</code>//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>数据读取:</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>反转和排序：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序，默认从小到大</li></ul><h3 id="1-7-set-multiset容器"><a href="#1-7-set-multiset容器" class="headerlink" title="1.7 set/multiset容器"></a>1.7 set/multiset容器</h3><h4 id="1-7-1-简介"><a href="#1-7-1-简介" class="headerlink" title="1.7.1 简介"></a>1.7.1 简介</h4><p><strong>头文件：</strong>set</p><p>set与multiset基本一样，唯一<strong>区别</strong>是：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><p><strong>功能：</strong>所有元素都会在插入时自动被排序</p><p><strong>本质：</strong>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</p><h4 id="1-7-2-常用函数"><a href="#1-7-2-常用函数" class="headerlink" title="1.7.2 常用函数"></a>1.7.2 常用函数</h4><p>set与multiset函数一样</p><p><strong>构造</strong>：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>大小</strong>：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li></ul><p><strong>交换</strong>：</p><ul><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>插入和删除</strong>:</p><ul><li><code>insert(elem);</code>           //在容器中插入元素</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>查找和统计：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>排序：</strong></p><h3 id="1-8-map-multimap容器"><a href="#1-8-map-multimap容器" class="headerlink" title="1.8 map/ multimap容器"></a>1.8 map/ multimap容器</h3><h4 id="1-8-1-简介"><a href="#1-8-1-简介" class="headerlink" title="1.8.1 简介"></a>1.8.1 简介</h4><p><strong>头文件</strong>：map</p><ul><li>map中所有元素都是pair(成对出现的数据，利用对组可以返回两个数据)</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>map和multimap区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="1-7-2-常用函数-1"><a href="#1-7-2-常用函数-1" class="headerlink" title="1.7.2 常用函数"></a>1.7.2 常用函数</h4><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>大小和交换</strong>：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>插入和删除</strong>：</p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>查找和统计</strong>：</p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><h2 id="2-函数对象"><a href="#2-函数对象" class="headerlink" title="2.函数对象"></a>2.函数对象</h2><h3 id="2-1-函数对象简介"><a href="#2-1-函数对象简介" class="headerlink" title="2.1 函数对象简介"></a>2.1 函数对象简介</h3><p><strong>概念：</strong></p><ul><li>重载<u>函数调用操作符</u>（就是<code>（）</code>）的类，其对象常称为函数对象</li><li>函数对象使用重载的()时，行为类似函数调用，也叫<u>仿函数</u></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个类，不是一个函数</p><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><p><strong>(1)</strong>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span><span class="comment">//重载“（）”</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）</strong>函数对象可以有自己的状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//内部自己的状态，在这里，就是一个记录被调用次数的值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(<span class="string">"hello world"</span>);</span><br><span class="line">myPrint(<span class="string">"hello world"</span>);</span><br><span class="line">myPrint(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"myPrint调用次数为： "</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）</strong>函数对象可以作为参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , <span class="built_in">string</span> test)</span><span class="comment">//两个参数，一个Myprint类型，一个string类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">doPrint(myPrint, <span class="string">"Hello C++"</span>);<span class="comment">//实现将"Hello C++"当做参数传给myprint，最后结果就是打印"Hello C++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2谓词"><a href="#2-2谓词" class="headerlink" title="2.2谓词"></a>2.2谓词</h3><h4 id="2-2-1概念："><a href="#2-2-1概念：" class="headerlink" title="2.2.1概念："></a>2.2.1概念：</h4><ul><li><u>返回bool类型</u>的<u>仿函数</u>称为<u>谓词</u></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="2-2-2一元谓词示例："><a href="#2-2-2一元谓词示例：" class="headerlink" title="2.2.2一元谓词示例："></a>2.2.2一元谓词示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没找到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到:"</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3二元谓词示例："><a href="#2-2-3二元谓词示例：" class="headerlink" title="2.2.3二元谓词示例："></a>2.2.3二元谓词示例：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyCompare());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-内建函数对象"><a href="#2-3-内建函数对象" class="headerlink" title="2.3 内建函数对象"></a>2.3 内建函数对象</h3><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="2-3-2-算数仿函数"><a href="#2-3-2-算数仿函数" class="headerlink" title="2.3.2 算数仿函数"></a>2.3.2 算数仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-关系仿函数"><a href="#2-3-3-关系仿函数" class="headerlink" title="2.3.3 关系仿函数"></a>2.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-逻辑仿函数"><a href="#2-3-4-逻辑仿函数" class="headerlink" title="2.3.4 逻辑仿函数"></a>2.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">v2.resize(v.<span class="built_in">size</span>());</span><br><span class="line">transform(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-常用算法"><a href="#3-常用算法" class="headerlink" title="3.常用算法"></a>3.常用算法</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul><li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p></li><li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p></li></ul><h3 id="3-1-常用遍历算法"><a href="#3-1-常用遍历算法" class="headerlink" title="3.1 常用遍历算法"></a>3.1 常用遍历算法</h3><h4 id="3-1-1-for-each"><a href="#3-1-1-for-each" class="headerlink" title="3.1.1 for_each"></a>3.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-transform"><a href="#3-1-2-transform" class="headerlink" title="3.1.2 transform"></a>3.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.resize(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">transform(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), TransForm());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), MyPrint());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="3-2-常用查找算法"><a href="#3-2-常用查找算法" class="headerlink" title="3.2 常用查找算法"></a>3.2 常用查找算法</h3><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="3-2-1-find"><a href="#3-2-1-find" class="headerlink" title="3.2.1 find"></a>3.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到:"</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="3-2-2-find-if"><a href="#3-2-2-find-if" class="headerlink" title="3.2.2 find_if"></a>3.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到大于5的数字:"</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"aaa"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"bbb"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"ccc"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"ddd"</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Greater20());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到姓名:"</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">" 年龄: "</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="3-2-3-adjacent-find"><a href="#3-2-3-adjacent-find" class="headerlink" title="3.2.3 adjacent_find"></a>3.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找不到!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到相邻重复元素为:"</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-binary-search"><a href="#3-2-4-binary-search" class="headerlink" title="3.2.4 binary_search"></a>3.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"未找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-count"><a href="#3-2-5-count" class="headerlink" title="3.2.5 count"></a>3.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"4的个数为： "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"曹操"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">"诸葛亮"</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="3-2-6-count-if"><a href="#3-2-6-count-if" class="headerlink" title="3.2.6 count_if"></a>3.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), Greater4());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大于4的个数为： "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"刘备"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"关羽"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张飞"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"赵云"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">"曹操"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), AgeLess35());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小于35岁的个数："</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（更新中）</title>
      <link href="/2020/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div align="center">————这里，有一些计算机网络的基础知识，希望对你有帮助^_^————</div><div align="center">————（针对c++后台开发）————</div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="第一章——计算机网络概述"><a href="#第一章——计算机网络概述" class="headerlink" title="第一章——计算机网络概述"></a>第一章——计算机网络概述</h1><h2 id="1-计算机网络性能"><a href="#1-计算机网络性能" class="headerlink" title="1.计算机网络性能"></a><strong>1.计算机网络性能</strong></h2><blockquote><p><strong>1</strong>. <strong>速率</strong>：速率即数据率或比特率是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等</p><p><strong>2</strong>. <strong>带宽</strong>：数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。  </p><p><strong>3</strong>. <strong>吞吐量</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。受网络的带宽或网络的额定速率的限制。 </p><p><strong>4</strong>. <strong>时延</strong>：发送数据时，数据块从结点进入到传输媒体所需要的时间。</p><p><strong>5</strong>. <strong>时延带宽积</strong>：时延带宽积 = 传播时延 *带宽</p><p><strong>6</strong>. <strong>利用率</strong>：<strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。<strong>网络利用率</strong>则是全网络的信道利用率的加权平均值。</p></blockquote><h2 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2.计算机网络体系结构"></a>2.<strong>计算机网络体系结构</strong></h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706213841831.png" alt="image-20200706213841831" style="zoom: 67%;" /></blockquote><h2 id="3-OSI的7层大约作用"><a href="#3-OSI的7层大约作用" class="headerlink" title="3.OSI的7层大约作用"></a>3.<strong>OSI的7层大约作用</strong></h2><h3 id="3-1-分层的好处："><a href="#3-1-分层的好处：" class="headerlink" title="3.1 分层的好处："></a>3.1 <strong>分层的好处</strong>：</h3><blockquote><p>各层之间是独立的、灵活性好、结构上可分割开、易于实现和维护、能促进标准化工作。 </p></blockquote><h3 id="3-2-OSI七层模型及其包含的协议如下"><a href="#3-2-OSI七层模型及其包含的协议如下" class="headerlink" title="3.2 OSI七层模型及其包含的协议如下:"></a>3.2 OSI七层模型及其包含的协议如下:</h3><blockquote><p><strong>物理层</strong>: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45</p><p><strong>数据链路层</strong>: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP</p><p><strong>网络层</strong>：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP</p><p><strong>传输层</strong>：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP</p><p><strong>会话层</strong>：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p><p><strong>表示层</strong>: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p><p><strong>应用层</strong>: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p></blockquote><h3 id="3-3TCP-IP-4层模型包括："><a href="#3-3TCP-IP-4层模型包括：" class="headerlink" title="3.3TCP/IP 4层模型包括："></a>3.3TCP/IP 4层模型包括：</h3><blockquote><p><strong>网络接口层</strong>：MAC VLAN</p><p><strong>网络层</strong>:IP ARP ICMP</p><p><strong>传输层</strong>:TCP UDP</p><p><strong>应用层</strong>:HTTP DNS SMTP</p></blockquote><h1 id="第二章——物理层"><a href="#第二章——物理层" class="headerlink" title="第二章——物理层"></a>第二章——物理层</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>物理层的主要任务描述为确定与传输媒体的接口的一些特性，即： </p><blockquote><p><strong>机械特性</strong>  指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</p><p><strong>电气特性</strong>  指明在接口电缆的各条线上出现的电压的范围。</p><p><strong>功能特性</strong>  指明某条线上出现的某一电平的电压表示何种意义。</p><p><strong>过程特性</strong>  指明对于不同功能的各种可能事件的出现顺序</p></blockquote><h1 id="第三章——数据链路层"><a href="#第三章——数据链路层" class="headerlink" title="第三章——数据链路层"></a>第三章——数据链路层</h1><h2 id="1-数据链路层基本概念与三个基本问题"><a href="#1-数据链路层基本概念与三个基本问题" class="headerlink" title="1.数据链路层基本概念与三个基本问题"></a>1.数据链路层基本概念与三个基本问题</h2><h3 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h3><blockquote><p>除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<strong>数据链路层传送的是帧</strong></p></blockquote><h3 id="1-2三个基本问题"><a href="#1-2三个基本问题" class="headerlink" title="1.2三个基本问题"></a>1.2三个基本问题</h3><blockquote><p>(1) <strong>封装成帧</strong>：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708235705596.png" alt="image-20200708235705596" style="zoom: 50%;" /><p>(2) <strong>透明传输</strong>：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)</p><p>(3) <strong>差错控制</strong> ：在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</p></blockquote><p>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受。“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须再加上<strong>确认和重传机制</strong>。 </p><h2 id="2-两种情况下的数据链路层"><a href="#2-两种情况下的数据链路层" class="headerlink" title="2.两种情况下的数据链路层"></a>2.两种情况下的数据链路层</h2><h3 id="2-1使用点对点信道的数据链路层（用PPP）"><a href="#2-1使用点对点信道的数据链路层（用PPP）" class="headerlink" title="2.1使用点对点信道的数据链路层（用PPP）"></a>2.1使用点对点信道的数据链路层（用PPP）</h3><ul><li><strong>PPP 协议应满足的需求</strong> </li></ul><blockquote><p>1.简单——这是首要的要求。2.封装成帧 。3.透明性 。4.多种网络层协议。 5.多种类型链路。 6.差错检测。 7.检测连接状态。 8.最大传送单元 。9.网络层地址协商 。10.数据压缩协商 。</p></blockquote><ul><li><strong>ppp协议组成部分</strong></li></ul><blockquote><p>(1)一个将 IP 数据报封装到串行链路的方法。(接近物理层)</p><p>(2)链路控制协议 LCP (Link Control Protocol)。</p><p>(3)网络控制协议 NCP (Network Control Protocol)。（接近网络层）</p></blockquote><ul><li><strong>ppp协议的帧格式</strong></li></ul><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710110232555.png" alt="image-20200710110232555" style="zoom: 50%;" /><p>首部与尾部的F字段是帧定界符</p></blockquote><h3 id="2-2使用广播信道的数据链路层（用CSMA-CD）"><a href="#2-2使用广播信道的数据链路层（用CSMA-CD）" class="headerlink" title="2.2使用广播信道的数据链路层（用CSMA/CD）"></a>2.2使用广播信道的数据链路层（用CSMA/CD）</h3><ul><li><strong>CSMA/CD协议</strong></li></ul><blockquote><p><strong>要点</strong>：</p><p>1.<strong>多点接入</strong>：表示许多计算机以多点接入的方式连接在一根总线上。</p><p>2.<strong>载波监听</strong>：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 </p><p>3.<strong>碰撞检测</strong>：就是计算机边发送数据边检测信道上的信号电压大小。</p><p><strong>重要特性</strong>：</p><p>1.使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</p><p>2.每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </p><p>3.这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。 </p></blockquote><h2 id="3-虚拟局域网-（VLAN）"><a href="#3-虚拟局域网-（VLAN）" class="headerlink" title="3.虚拟局域网 （VLAN）"></a>3.虚拟局域网 （VLAN）</h2><blockquote><p><strong>（1）</strong>一个交换机可以通过划分VLAN，形成虚拟局域网。同一VLAN中的计算机处于同一虚拟局域网里。VLAN1中的广播不会传到VLAN2。相当于把交换机划分成两个交换机。</p><p><strong>（2）</strong>不同的VLAN之间的帧会有特殊标记，所以不会互相广播</p></blockquote><h1 id="第四章——网络层"><a href="#第四章——网络层" class="headerlink" title="第四章——网络层"></a>第四章——网络层</h1><h2 id="1-网络层提供的两种服务"><a href="#1-网络层提供的两种服务" class="headerlink" title="1.网络层提供的两种服务"></a>1.网络层提供的两种服务</h2><blockquote><p><strong>（1）虚电路服务</strong>：A计算机发给B计算机的所有数据，都沿着同一条虚电路传送。</p><p><strong>（2）数据报服务</strong>：计算机发给B计算机的数据，可能沿着不同路径传送。（现在在用的服务）</p></blockquote><h2 id="2-虚拟互联网"><a href="#2-虚拟互联网" class="headerlink" title="2.虚拟互联网"></a>2.虚拟互联网</h2><blockquote><p> 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 </p></blockquote><h2 id="3-ip"><a href="#3-ip" class="headerlink" title="3.ip"></a>3.ip</h2><h3 id="3-1-ip协议及配套使用协议"><a href="#3-1-ip协议及配套使用协议" class="headerlink" title="3.1 ip协议及配套使用协议"></a>3.1 ip协议及配套使用协议</h3><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有<strong>三个协议</strong>：</p><blockquote><p>地址解析协议 ARP (Address Resolution Protocol)</p><p>网际控制报文协议 ICMP (Internet Control Message Protocol)</p><p>网际组管理协议 IGMP (Internet Group Management Protocol)</p></blockquote><h3 id="3-2-ip地址分类"><a href="#3-2-ip地址分类" class="headerlink" title="3.2 ip地址分类"></a>3.2 ip地址分类</h3><blockquote><p> ip地址分为A、B、C三类地址。A类的前1位固定为0，B类的前2位固定为10，C类的前3位固定为110。用于识别是哪类地址。图示如下</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200712145253617.png" alt="image-20200712145253617" style="zoom: 50%;" /><p>因为前面1~3位已经固定，因此A、B、C三类地址的前8位范围是：</p><blockquote><p><strong>A类</strong>：00000000<del>01111111，转为十进制就是0</del>126（127划分到了本地环回地址）</p><p><strong>B类</strong>：10000000<del>10111111，转为十进制就是128</del>191</p><p><strong>C类</strong>：11000000<del>11011111，转为十进制就是192</del>223</p></blockquote><p><strong>分类的目的</strong>：满足不同用户的需求，有些可能网络号需求多，有些电脑连接多。</p></blockquote><h3 id="3-3子网掩码"><a href="#3-3子网掩码" class="headerlink" title="3.3子网掩码"></a>3.3子网掩码</h3><blockquote><p>网络号字段全置1，主机号字段全置0</p><p><strong>（1）默认</strong>：<strong>A类</strong>：255.0.0.0  ，<strong>B类</strong>：255.255.0.0  ，<strong>C类</strong>：255.255.255.0</p><p><strong>（2）子网划分：</strong></p><p>当C类地址还需要进行子网划分时，子网掩码就不一定是255.255.255.0了。</p><p>比如有200台计算机使用C类网络，但是需要每100台使用一个子网，比如192.168.0.00000000<del>192.168.0.011111111为一子网，192.168.0.10000000</del>192.168.0.111111111为另一子网。即C类网络主机号的第一位划分到网络号了，此时子网掩码是255.255.255.10000000，即255.255.255.128。据此，不同划分情况时，子网掩码后面8位数值可能是128、192、224、240、248、252 </p><p><strong>注意</strong>：划分的子网主机号部分字段不可以全为1或者全为0。全为1或者全为0有特殊用处。</p><p><strong>（3）网段合并：</strong></p><p>简单来说，就是通过改变子网的数值，重新划分网络号和主机号（网络位置1，主机位置0）</p><p><strong>例子1</strong>：将 <u>192.168.0.0，netmask:255.255.255.0</u> 和 <u>192.168.1.0,netmask:255.255.255.0</u> 合并。</p><p>192.168.0.0—&gt;11000000.10101000.00000000.00000000</p><p>255.255.255.0 —&gt;11111111.11111111.11111111.00000000</p><p>192.168.1.0—&gt;11000000.10101000.00000001.00000000</p><p>255.255.255.0 —&gt;11111111.11111111.11111111.00000000</p><p>要合并网段，就要使得两个ip地址的网络号相同，因此子网掩码就要改变（因为子网掩码就是用来标识网络号和主机号的）</p><p>可以看到连个的ip地址不同在于：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200714173449771.png" alt="image-20200714173449771" style="zoom:67%;" /><p>因此网络号要避开这两位，因此子网掩码应该变为11111111.11111111.11111110.00000000—&gt;255.255.254.0</p></blockquote><h2 id="4-ip和MAC"><a href="#4-ip和MAC" class="headerlink" title="4.ip和MAC"></a>4.ip和MAC</h2><blockquote><p> ip地址决定了数据包的起点和终点，MAC地址决定了数据帧的下一跳是哪里。</p></blockquote><h2 id="5-路由选择协议"><a href="#5-路由选择协议" class="headerlink" title="5.路由选择协议"></a>5.路由选择协议</h2><p>（1）<strong>内部网关协议</strong>（在区域内）</p><blockquote><p><strong>RIP协议</strong>：动态路由协议，根据路由器数量选择路径。每30秒更新一次路由表</p><p><strong>OSPF协议</strong>：动态路由协议，根据带宽选择路径。</p></blockquote><p>（2）<strong>外部网关协议</strong></p><blockquote><p><strong>BGP协议</strong>：BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p></blockquote><p>（3）<strong>三个协议之间的关系</strong>：</p><blockquote><p>三个协议统称<strong>ip</strong>协议，RIP和OSPF协议是自治系统（AS）内部路由的选择协议，不同自治系统（AS）之间的通信是用BGP协议。</p><p>如下图所示</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200718151935682.png" alt="image-20200718151935682" style="zoom: 50%;" /></blockquote><h1 id="第五章——传输层"><a href="#第五章——传输层" class="headerlink" title="第五章——传输层"></a>第五章——传输层</h1><h2 id="1-用户数据报协议-UDP-User-Datagram-Protocol"><a href="#1-用户数据报协议-UDP-User-Datagram-Protocol" class="headerlink" title="1.用户数据报协议 UDP (User Datagram Protocol)"></a>1.用户数据报协议 UDP (User Datagram Protocol)</h2><h3 id="1-1特点："><a href="#1-1特点：" class="headerlink" title="1.1特点："></a>1.1<strong>特点</strong>：</h3><blockquote><blockquote><p><strong>（1）</strong>一个数据包就能完成数据通信，是不可靠传输。</p><p><strong>（2）</strong>发送数据之前不需要建立连接(会话)。</p><p><strong>（3）</strong>尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</p><p><strong>（4）</strong>面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 </p><p><strong>（5）</strong>支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>（6）</strong>首部开销小，只有 8 个字节。 </p></blockquote><p>比如QQ聊天，多播就是用到UDP，这些过程的数据都比较小，一个数据包就可以传输。通过观察也可以判定，比如我们聊天的时候就是一个个信息打包发过去，遇上网络问题就会显示发送失败，这也算是不可靠传输的一种机制，可以通过提醒发送方重新发送。</p></blockquote><h3 id="1-2报文格式"><a href="#1-2报文格式" class="headerlink" title="1.2报文格式"></a>1.2报文格式</h3><blockquote><p><strong>（1）数据在经过运输层，IP层的大约处理流程：</strong></p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721152049574.png" alt="image-20200721152049574" style="zoom: 33%;" /><p><strong>（2）UDP 的首部格式</strong> </p><p><strong>端口：</strong>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。因此有了端口。简而言之，端口就好像不同系统用来定位自己进程的同一标识。</p><p><strong>伪首部</strong>：在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721152552788.png" alt="image-20200721152552788" style="zoom:50%;" /></blockquote><h2 id="2-传输控制协议-TCP-Transmission-Control-Protocol"><a href="#2-传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="2.传输控制协议 TCP (Transmission Control Protocol)"></a>2.传输控制协议 TCP (Transmission Control Protocol)</h2><h3 id="2-1-特点："><a href="#2-1-特点：" class="headerlink" title="2.1 特点："></a>2.1 特点：</h3><blockquote><blockquote><p><strong>（1）</strong>对数据进行分段、编号，建立会话，是可靠传输。</p><p><strong>（2）</strong>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </p><p><strong>（3）</strong>提供全双工通信(同时收发)。 </p><p><strong>（4）</strong>面向字节流（传输的时候并不管数据的完整性，而是直接把数据分成小的字节段打包发过去）。 </p></blockquote><p>比如QQ传文件，访问网址，下载文件。因为这些传输的数据都很大，难以通过一个数据包传输过去（比如带宽限制），因此就要通过对数据进行分段，编号，建立会话进行传输。</p></blockquote><h3 id="2-2-TCP-报文段的首部格式"><a href="#2-2-TCP-报文段的首部格式" class="headerlink" title="2.2 TCP 报文段的首部格式"></a>2.2 TCP 报文段的首部格式</h3><blockquote><p>上面特点有说，TCP是将数据分段传输，要使得分段的数据能够在网络上传到指定位置，以及接受数据的计算机能够将数据拼接起来，就要给数据添加一些标识信息。下图是TCP 报文段的首部格式 。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721180746586.png" alt="image-20200721180746586" style="zoom:50%;" /><p><strong>说明</strong>：</p><blockquote><p><strong>（1）</strong> 首部一般是20个字节，有些特殊数据会更长。</p><p><strong>（2）</strong>可以看到，源端口和目的端口占16位，也就是2个字节。序号占32位，就是4个字节，其他以此类推。</p><p><strong>（3）序号</strong> ：就是被分割成段的数据每一段的序号，数据段的第一个字节是整个文件的第几个字节，它的序号就是多少。</p><p><strong>（4）确认号：</strong>一般就是<em>数据段的最后一个字节是整个文件的第几个字节+1</em>，作用是告诉发送者下一次发第几个字节。然后发送者就会根据这个确认号去找序号是这个确认号的数据段。</p><p><strong>（5）数据偏移：</strong>  用来告诉接收端首部有多长，数据部分从第几个字节开始。</p><p><strong>（6）保留字段</strong>：占 6 位，保留为今后使用，但目前应置为 0。 </p><p><strong>（7）紧急 URG</strong> ：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </p><p><strong>（8）确认 ACK</strong> ： 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 </p><p><strong>（9）推送 PSH (PuSH)</strong> ： 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p><p><strong>（10）复位 RST (ReSeT)</strong> ：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</p><p><strong>（11）同步 SYN</strong> ：同步 SYN = 1 表示这是一个连接请求或连接接受报文。</p><p><strong>（12）终止 FIN (FINis)</strong> ：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 </p><p><strong>（13）检验和</strong> ：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p><p><strong>（14）紧急指针字段</strong> ：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  </p><p><strong>（15）选项字段</strong> ：长度不定。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 还有一些其他选项。</p></blockquote></blockquote><h3 id="2-3-如何实现可靠传输"><a href="#2-3-如何实现可靠传输" class="headerlink" title="2.3 如何实现可靠传输"></a>2.3 如何实现可靠传输</h3><blockquote><p><strong>原理简述</strong>：接受方需要对接受的数据包回发确认信息，确保可靠交付</p><p>下图是最初原理示意图：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721162922825.png" alt="image-20200721162922825" style="zoom: 50%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721163111899.png" alt="image-20200721163111899" style="zoom:50%;" /><p><strong>通过上面的方法传输的缺点</strong>：每次都要等待B的确认信息才能发下一个数据报，信道利用率低、浪费时间。因此常用的是下图的流水线传输方法以及利用滑动窗口。</p><p><strong>滑动窗口原理</strong>：发送窗口内的数据分段可以连续发送，每接受到B的一个确认信息，就往前移动。比如A收到B确认5收到的报文段，则窗口移动到5后面。<strong>万一B只收到1245呢？</strong> B会在回发的数据报文段的“选项”添加<code>选择确认 SACK</code>，可以告知发送端不连续字节块的边界信息。（选项最长40字节，因此可以存放8个边界信息，也就4个字节块边界信息）</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200721175052872.png" alt="image-20200721175052872" style="zoom:50%;" /></blockquote><h3 id="2-4-拥塞控制"><a href="#2-4-拥塞控制" class="headerlink" title="2.4 拥塞控制"></a>2.4 拥塞控制</h3><blockquote><p><strong>（1）什么是拥塞：</strong> 简单来说就是网络堵车了，假如就50M带宽，但是在网络上的每秒数据量都100M了，就会产生丢包，甚至路由器死机之类的。可以看下图，是控制前后的对比。可以看到在无拥塞控制得情况下，在给50M负载的时候，吞吐量并没有50M。就好像我们的手机，运行内存写6G，实际上用了5G以上就感觉卡了。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200722120052544.png" alt="image-20200722120052544" style="zoom:50%;" /><p><strong>（2）大约怎么进行拥塞控制</strong>：根据前面学的TCP数据传输原理，容易知道，可以通过控制发送方的发送窗口大小从而控制单位时间内发送出去的数据量，进行拥塞控制。简单来说，就是通过控制所有计算机的数据发送速率，减小网络负担。</p><p><strong>（3）具体方法：</strong></p><blockquote><p><strong>1）慢开始算法</strong>：给每个发送方设定一个叫做拥塞窗口（cwnd）的变量，用于控制发送窗口大小。cwnd有一个门限：ssthresh（用来限制cwnd最大值）。一开始cwnd设置为1，ssthresh设置为16（1和16指报文段数目，）。使用慢开始算法后，每经过一个<strong>传输轮次</strong>（例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 ），拥塞窗口 cwnd 就加倍。 当 cwnd = ssthresh 后，开始使用拥塞避免算法。</p><p><strong>2）拥塞避免算法：</strong>  当 cwnd = ssthresh 后，让拥塞窗口 cwnd 缓慢地增大，每经过一个传输轮次就把 cwnd 加 1，而不是加倍，使cwnd 按线性规律缓慢增长。</p><p><strong>3）当网络拥塞后</strong>：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把cwnd 重新设置为 1，执行慢开始算法。</p><div align="center">示意图 </div><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200722124119656.png" alt="image-20200722124119656" style="zoom:50%;" /><p><strong>4）快重传：</strong> 接收方每收到一个失序的报文段后就立即重复发出3次丢失报文段确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。这样做可以让发送方及早知道有报文段没有到达接收方。比如A传12345，但是B只收到1245，收到4的时候B就开始回发三次3的重传确认。</p><p><strong>5）快恢复：</strong> 当发送端收到连续三个重复的确认时，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。由于能够连着接受3个确认，发送方会认为网络很可能没有发生拥塞，因此不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 如下图</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200722135540845.png" alt="image-20200722135540845" style="zoom:50%;" /></blockquote></blockquote><h3 id="2-5-TCP-的连接建立-三次握手"><a href="#2-5-TCP-的连接建立-三次握手" class="headerlink" title="2.5 TCP 的连接建立:三次握手"></a>2.5 TCP 的连接建立:三次握手</h3><blockquote><ul><li><strong>过程</strong></li></ul><blockquote><p><strong>1）</strong>A向B发送请求报文，报文的SYN=1，代表这是一个连接请求或连接接受报文。seq是序号这个报文的序号。</p><p><strong>2）</strong>B收到后回发一个SYN=1，ACK=1，seq=y，ack=x+1的报文。其中ACK=1代表ack有效。seq是B发出的报文的序号，<code>ack=x+1</code>是B发出的确认号，也就是告诉A下次发序号是<code>x+1</code>的报文。</p><p><strong>3）</strong>A收到B的确认报文后，向B发一个ACK=1，seq=x+1，ack=y+1的报文。seq=x+1是因为B给A发了ack=x+1的报文，A发出去的报文序号seq就要是x+1。</p><p>（x,y都是随机的，数值不是重点，重点是每次两台计算机的互相响应）</p></blockquote><ul><li><strong>为什么要有第三次握手？</strong></li></ul><blockquote><p>两次握手不是已经可以证明能够通信了吗，第三次握手岂不是多此一举？</p><p><strong>原因：</strong> 第三次握手是用来再次确认。加入没有第三次：假设A发了请求，但是请求的报文走了远路，报文还没到B。A觉得太久了，给B发了第二次请求，第二次请求走了近路，比第一次还快到达，然后AB进行了通信。但是一会后，第一次请求也到B了，B接受到请求，又给A发了确认，接着等待A的通信。但是因为A已经在接受过B的确认了，就会不理A的确认。这会B岂不是在干等了？会浪费资源</p></blockquote><ul><li><strong>下图展示了三次握手的过程以及计算机状态</strong></li></ul><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200722145411745.png" alt="image-20200722145411745" style="zoom:50%;" /><p>当两台计算机都是ESTAB—LISHED状态了，就进行数据传送</p></blockquote><h3 id="2-6-TCP-的连接释放-四次挥手"><a href="#2-6-TCP-的连接释放-四次挥手" class="headerlink" title="2.6 TCP 的连接释放 :四次挥手"></a>2.6 TCP 的连接释放 :四次挥手</h3><blockquote><p>过程见下图：一共发送了四个报文</p><blockquote><p><strong>1)</strong>FIN = 1, seq = u：FIN代表要释放链接，告诉B要停止发送数据了。</p><p><strong>2）</strong>ACK = 1, seq = v, ack= u <strong>+</strong> 1：B回应A,允许它断开链接。</p><p><strong>3）</strong>FIN = 1, ACK = 1, seq = w, ack= u <strong>+</strong> 1：FIN代表要释放链接，告诉B要停止发送数据了。</p><p><strong>4）</strong>ACK = 1, seq = u + 1, ack = w <strong>+</strong> 1：同理，A回应B。</p></blockquote><p><strong>为什么A最后需要等待一段时间（2MSL）？：</strong></p><blockquote><p>因为如果A发给B的确认，B没收到，B就会重新发送释放链接的报文（也就是第三个）。所以此时要是没有TIME-WAIT状态等待，而是直接关了，A就无法接到B的请求，也就不会回应，这样B的连接就释放不了了。</p></blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200722163843224.png" alt="image-20200722163843224" style="zoom: 67%;" /></blockquote><h1 id="第六章——应用层"><a href="#第六章——应用层" class="headerlink" title="第六章——应用层"></a>第六章——应用层</h1><h2 id="1-统一资源定位符-URL"><a href="#1-统一资源定位符-URL" class="headerlink" title="1.统一资源定位符 URL"></a>1.统一资源定位符 URL</h2><blockquote><p><strong>怎样标志分布在整个因特网上的万维网文档？</strong></p><p><strong>答案</strong>：使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 </p><p><strong>URL 的一般形式 ：</strong><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></p><blockquote><p><strong>协议：</strong>ftp —— 文件传送协议 FTP、http —— 超文本传送协议 HTTP、News —— USENET 新闻</p><p><strong>主机</strong>： 是存放资源的主机在因特网中的域名</p><p><strong>端口和路径：</strong>经常省略</p></blockquote></blockquote><h2 id="2-超文本传送协议-HTTP"><a href="#2-超文本传送协议-HTTP" class="headerlink" title="2.超文本传送协议 HTTP"></a>2.超文本传送协议 HTTP</h2><p>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息</p><h3 id="2-1-使用HTTP的URL格式"><a href="#2-1-使用HTTP的URL格式" class="headerlink" title="2.1 使用HTTP的URL格式"></a>2.1 使用HTTP的URL格式</h3><blockquote><p>上面URL的格式<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code>中的协议部分，就可以选择HTTP协议。格式如下：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200723013130257.png" alt="image-20200723013130257" style="zoom: 67%;" /></blockquote><h3 id="2-2HTTP-的报文结构-："><a href="#2-2HTTP-的报文结构-：" class="headerlink" title="2.2HTTP 的报文结构 ："></a>2.2HTTP 的报文结构 ：</h3><p>HTTP 有<strong>两类</strong>报文：请求报文——从客户向服务器发送请求报文、响应报文——从服务器到客户的回答。</p><blockquote><p><strong>（1）请求报文</strong></p><blockquote><p>报文格式：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200723160136671.png" alt="image-20200723160136671" style="zoom:50%;" /><p><strong>方法</strong>：是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的操作，因此这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。</p><p><strong>URL</strong>：是所请求的资源的 URL。</p><p><strong>版本</strong>：是 HTTP 的版本。</p></blockquote><p><strong>（2）响应报文</strong></p><blockquote><p>报文格式：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200723160917845.png" alt="image-20200723160917845" style="zoom:50%;" /><p><strong>状态码：</strong>状态码都是三位数字 ，1xx 表示通知信息的，如请求收到了或正在进行处理；2xx 表示成功，如接受或知道了；3xx 表示重定向，表示要完成请求还必须采取进一步的行动；4xx 表示客户的差错，如请求中有错误的语法或不能完成；5xx 表示服务器的差错，如服务器失效无法完成请求。</p><p><strong>短语：</strong>解释状态码的简单短语</p></blockquote></blockquote><h2 id="3-用户点击链接后所发生的事件"><a href="#3-用户点击链接后所发生的事件" class="headerlink" title="3.用户点击链接后所发生的事件"></a>3.用户点击链接后所发生的事件</h2><p>以在浏览器点击链接到百度的超链接为例</p><blockquote><p>(1) 浏览器分析超链指向页面的 URL。</p><p>(2) 浏览器向 DNS 请求解析 <a href="http://www.baidu.com的" target="_blank" rel="noopener">www.baidu.com的</a> IP 地址。</p><p>(3) 域名系统 DNS 解析出百度服务器的 IP 地址。</p><p>(4) 浏览器与服务器建立 TCP 连接</p><p>(5) 浏览器发出取文件命令： GET /chn/yxsz/index.htm。</p><p>(6) 服务器给出响应，把文件 index.htm 发给浏览器。</p><p>(7) TCP 连接释放。</p><p>(8) 浏览器显示 index.htm 中的所有文本。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法题解</title>
      <link href="/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><hr><div align="center">——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——</div><a id="more"></a><h1 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h1><h2 id="1-无重复字符的最长子字符串"><a href="#1-无重复字符的最长子字符串" class="headerlink" title="1.无重复字符的最长子字符串"></a>1.无重复字符的最长子字符串</h2><p><strong>题目：</strong>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 :</p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>解题思路：</strong></p><p>思路很简单，就是从利用双指针+哈希表，先固定左指针，然后移动右指针，每次就判断右指针的字符是否存在于哈希表，不存在就把它投放到哈希表里，一直到到右指针碰到重复的字符，就记录左右指针之间不重复子串的长度。然后移动左指针，开始下一轮判断。</p><p>因为这是求最长子串的长度，自然子串的左端是字符串的其中一个字符，那我们不妨从第一个字符开始判断。</p><blockquote><p>1.定义两个变量，记录子串的左端点和右端点，右端点不断往右移动，直到遇到与左右端点之间重复的字符为止。</p><p>2.用一变量num记录下两端点之间不重复的字符串长度（其实就是用右变量减左变量）</p><p>3.将左端点向右移动一个字符，右端点保持不动，然后又开始判断左右端点间有没有重复，重复就右移，和上面的一样，最后更新num。</p></blockquote><p><strong>题解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//哈希集合，存放字符，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="comment">//right记录右端点，设置初始值是0；num是记录最长子串长度的变量</span></span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左端点向右移动一格（也就是i加1），从哈希集合里移除s[i-1]（因为现在s[i-1]已经不在左右端点之间了）</span></span><br><span class="line">                occ.erase(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*!occ.count(s[right])如果是0，代表哈希集合里面有s[right]，则while&#123;&#125;里的代码不会运行，也就是不会往  里面添加字符。*/</span></span><br><span class="line">             <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>()&amp;&amp; !occ.count(s[right]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//右指针往右移动了，往哈希集合里添加一个字符</span></span><br><span class="line">                occ.insert(s[right]);</span><br><span class="line">                <span class="comment">//右端点加1</span></span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新num</span></span><br><span class="line">            num=<span class="built_in">max</span>(num,right-i);<span class="comment">//num是前面所有子串中最大值，right是此次左右端点之间的差，也就是此次子串长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2.最长回文子串"></a>2.最长回文子串</h2><p><strong>题目：</strong>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p>示例 :</p><blockquote><p><strong>示例 1：</strong></p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p><strong>示例 2：</strong></p><p>输入: “cbbd”<br>输出: “bb”</p></blockquote><p><strong>解题思路1：</strong></p><blockquote><p>使用<strong>动态规划,</strong>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 ababa，如果我们已经知道 bab 是回文串，那么ababa一定是回文串，这是因为它的首尾两个字母都是 “a”。</p><p>根据这一思想总结：</p><p>1.我们可以把编程思路定为填写下面的表格的右上方（因为坐下方是非法的：右边界&lt;左边界），如果是回文串就填true（1），不是回文串就填false（0）。</p><p>2.因为ababa是不是回文的，可以根据bab 是不是回文串来决定，根据表格规律，可发现，某个空格应该填是1或0，是根据左下角来确定的。所以填表顺序应该是斜着来，从左上方斜往右下方。根据图表，可见斜线上的左右边界之间的差值是相等的。因此在写程序时，我们就可以先考虑填左右边界差值为0的，再到1的、2的。。。。</p><p>3.对角线都是只有一个字符，肯定是回文的，因此可以先全部填0。</p><p>根据上面的思路总结，可以得到下面的题解</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201118202850675.png" alt="image-20201118202850675" style="zoom:67%;" /></blockquote><p><strong>题解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();<span class="comment">//n为输入字符串的长度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;<span class="comment">//定义一个二维数组dp，就是相当于上面的表格，用来存储判断结果的</span></span><br><span class="line">        <span class="built_in">string</span> ans;<span class="comment">//记录最终的返回结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;++l)<span class="comment">//定义l来代表左右边界之间的差值（这一点在上面有解释为什么）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l&lt;n;++i)<span class="comment">//i是左边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//j是右边界</span></span><br><span class="line">                <span class="keyword">int</span> j=i+l;</span><br><span class="line">                <span class="comment">//l==0也就是只有一个字符，肯定是回文的</span></span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//l==1，也就是只有两个字符，是不是回文的，判断两个字符是否相等即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=(s[i]==s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//其他的点，判断是不是回文的，就要回归上面说的，需要根据数据的左下角以及左右边界来判断。左下角为真，且左右边界相等，那么就是回文的（真），这个逻辑关系可以用与或关系来表示。</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是回文的，长度（差值+1）又大于之前存储的ans的长度，就更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;(l+<span class="number">1</span>)&gt;ans.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ans=s.substr(i,l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-左旋转字符串"><a href="#3-左旋转字符串" class="headerlink" title="3.左旋转字符串"></a>3.左旋转字符串</h2><p><strong>题目</strong>：</p><p>把字符串前面的若干个字符转移到字符串的尾部</p><p><strong>示例</strong> 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure><p><strong>示例</strong> 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>直接利用string容器的一些操作函数。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">News</span><span class="params">(s)</span></span>;<span class="comment">//创建新的string变量News，并调用有参构造，将s赋值给News</span></span><br><span class="line">        News.erase(<span class="number">0</span>,n);<span class="comment">//删除News位置为0到n的字符</span></span><br><span class="line">        News.append(s,<span class="number">0</span>,n);<span class="comment">//将s的0到n字符串拼接到News后面</span></span><br><span class="line">        <span class="keyword">return</span> News;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-翻转单词顺序"><a href="#4-翻转单词顺序" class="headerlink" title="4.翻转单词顺序"></a>4.翻转单词顺序</h2><p><strong>题目</strong>：</p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例</strong>：</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>:</p><p>1.先把字符串首尾的空格去除。因为c++没有去除首尾字符串的内置函数，可以采用定义左边界left和右边界right的方法。把空格排除在边界外。</p><p>2.利用双指针，从左到右寻找单词的左右节点。</p><p>3.每一次双指针找到边界后，将单词拼接到新字符串上，并且拼接空格</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//left作为左端点，right作为右端点</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">' '</span>) ++left;</span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">' '</span>) --right;</span><br><span class="line">        <span class="comment">//用来决定每次循环单词的边界的</span></span><br><span class="line">        <span class="keyword">int</span> i=right;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="built_in">string</span> Newstr;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//i向左移动，直到不是空格停止，也就是单词的右边界</span></span><br><span class="line">            <span class="keyword">while</span>((i&gt;=left)&amp;&amp;(s[i]==<span class="string">' '</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把右边界赋值给j</span></span><br><span class="line">            j=i;</span><br><span class="line">            <span class="comment">//i继续移动，直到碰到第一个空格的地方</span></span><br><span class="line">            <span class="keyword">while</span>((i&gt;=left)&amp;&amp;(s[i]!=<span class="string">' '</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i+1到j就是单词，把s字符串从i+1位置起j-i个字符拼接到Newstr末尾</span></span><br><span class="line">            Newstr.append(s,i+<span class="number">1</span>,j-i);</span><br><span class="line">            <span class="comment">//单词之间的空格</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=left) Newstr.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-字符串转换整数"><a href="#5-字符串转换整数" class="headerlink" title="5.字符串转换整数"></a>5.字符串转换整数</h2><p><strong>题目</strong>：</p><p>实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>1.如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</p><p>2.假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</p><p>3.该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</p><p><strong>注意</strong>：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><strong>提示</strong>：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例</strong>：</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。  因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p><p>换个说法，就是我们可以这样操作：定义一个类，可以实现根据上次的状态以及输入字符来决定这次的状态。然后根据这次的状态来决定这次的操作。</p><p>根据问题的描述，可以得到各个状态遇到不同字符之后会转变到什么状态。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201213204811274.png" alt="image-20201213204811274" style="zoom: 50%;" /><p>表示为图表，如下</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201213205258255.png" alt="image-20201213205258255" style="zoom:67%;" /><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自动机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> state = <span class="string">"start"</span>;<span class="comment">//状态</span></span><br><span class="line">    <span class="comment">//定义一个unordered_map容器，键值为string类型，实值是vector类型。</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">"start"</span>, &#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"signed"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"in_number"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"end"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//控制数值返回函数，会根据传递的字符参数返回对应的0-3控制数值（vector有四个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//isspace（c）会检查c是不是空格</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//isdigit（c）会检查c是不是十进制数值1-9</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;<span class="comment">//决定正负的函数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//数值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][get_col(c)];<span class="comment">//根据字符c得到下一个状态</span></span><br><span class="line">        <span class="comment">//如果状态是“in_number”的话，说明可以开始录入数字了</span></span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">"in_number"</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;<span class="comment">//c这时候还是字符，需要通过-‘0’来装换成整数</span></span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断正负</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">"signed"</span>)</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;<span class="comment">//声明一个自动机对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h2><p><strong>题目</strong>：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><p><strong>思路</strong>:</p><p>大体思路:其实很简单，就是和平时算数一样，从低位开始相加，然后定义变量记录每次相加的结果，再定义变量记录是由需要进位。并且定义新的节点类型记录每次的计算结果。</p><p><strong>具体思路</strong>：定义新的头节点指针head，定义记录每次两数相加的和的变量sum，定义变量carry记录是否需要进位，定义一个节点指针指向新链表的尾部（保持指向尾部）（用于创建新的节点来存储数据）。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*定义一个addTwoNumber函数，参数类型是两个节点指针（节点是力扣系统自己定义好的了）*/</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//定义一个名为head的头节点，节点值为-1，head-&gt;next=NULL</span></span><br><span class="line">        ListNode* h=head;<span class="comment">//定义一个移动指针</span></span><br><span class="line">        <span class="keyword">int</span> sum;<span class="comment">//用来记录每位的和</span></span><br><span class="line">        <span class="keyword">bool</span> carry=<span class="number">0</span>;<span class="comment">//控制进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)<span class="comment">//当l1或者l2为NULL的时候，已经没有数据了，自然需要停止了</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum=<span class="number">0</span>;<span class="comment">//每个循环都需要置零</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)<span class="comment">//l1就是个指针，第一轮循环指向的就是例子中的2</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l1-&gt;val;<span class="comment">//就是sum=l1-&gt;val+sum</span></span><br><span class="line">                l1=l1-&gt;next;<span class="comment">//将l1指向下一个节点，下一个循环可以用</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l2-&gt;val;<span class="comment">//结合前面的if语句，这里其实sum=l1-&gt;val+l2-&gt;val</span></span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry) sum++;<span class="comment">//carry是记录进位的，第一轮的话没有进位，carry就是初始值0</span></span><br><span class="line">            h-&gt;next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//new ListNode(sum%10)开辟一个新节点，用来存储相加的结果</span></span><br><span class="line">            h=h-&gt;next;<span class="comment">//把h指针=刚才开辟的节点的next指针，方便下个循环接着这次开辟节点继续开辟</span></span><br><span class="line">            carry=sum&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;<span class="comment">//如果sum&gt;=10，carry=1，否则carry=0；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这一步是在所有循环结束后的，如果最后carry=1，代表有进位，那么最高位应该增加一个1*/</span></span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;<span class="comment">//返回头节点</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2.合并两个有序链表"></a>2.合并两个有序链表</h2><p><strong>题目</strong>：</p><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>可以使用递归的方法，非常简单巧妙的解决问题：先定义两个指针，指向l1和l2的头部，然后判断l1和l2谁的的第一个元素更加小，然后使小的一方的next指向mergeTwoLists(小的一方-&gt;next,大的一方)。有点难说明白，看代码吧</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="comment">//判断l1是否为0，为0的话就直接返回l2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val)<span class="comment">//判断大小</span></span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);<span class="comment">//使用递归</span></span><br><span class="line">            <span class="keyword">return</span> l1;<span class="comment">//因为这里是l1-&gt;val&lt;l2-&gt;val，所以l1才是头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3.反转链表"></a>3.反转链表</h2><p><strong>题目</strong>：</p><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>使用递归的思想。题目的解决可以分为两个问题：1.找到反转后的头节点，也就是反转前的尾节点。2.将链表反转。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*head == NULL的情况时链表本来就是空的情况。head-&gt;next == NULL是到了最后一个节点的情况，例如例子中的5。还有就是下面会使用递归，这个条件就代表已经递归到最后一个节点了*/</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* Newhead = reverseList(head-&gt;next);<span class="comment">//定义一个名为Newhead的ListNode类型指针来作为新链表的头节点。</span></span><br><span class="line">    head-&gt;next-&gt;next = head;<span class="comment">//反转操作。在第一轮了，head就是4的节点。那head-&gt;next-&gt;next其实就是5-&gt;</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Newhead;<span class="comment">//返回新链表的头节点。这里的p，其实在递归的最深层已经决定了，就是5的节点。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4.两两交换链表中的节点"></a>4.两两交换链表中的节点</h2><p><strong>题目</strong>：</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例</strong>：</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链表中节点的数目在范围 [0, 100] 内</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>思路其实就是，每两个节点为一次操作。比如1-&gt;2-&gt;3-&gt;4，就要想办法将2-&gt;1,1-&gt;4,4-&gt;3。那就可以分解为。</p><p>1.定义两个节点指针指向1,2，然后操作2-&gt;1,1-&gt;3。</p><p>2.定义一个指针来指向1,到下一轮就操作这个指针的next指向新一轮的节点2。</p><p>3.重新head的指向。（head是用来判断是否到结尾以及确定下一轮节点指针1,2的指向的）</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;<span class="comment">//判断是否为空表，没有这句的话，一旦是空表，下面的head-&gt;next就不存在了，会报错</span></span><br><span class="line">        ListNode* Newhead = head-&gt;next;<span class="comment">//建立Newhead，指向第二个节点，后面不再改变Newhead，最后直接返回Newhead就可以</span></span><br><span class="line"></span><br><span class="line">        ListNode* curr = head;<span class="comment">//curr是用来指向每次换两两节点后排后面的节点，为了使得上一轮交换后排后面的节点能够指向正确的节点。在第一第二轮中，就是为了使得1能够指向4。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span> &amp;&amp; head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新建两个节点指针firstNote和secondNode,用于改变节点指向。</span></span><br><span class="line">            ListNode* firstNode = head;<span class="comment">//节点指针1指向每两个节点的第一个</span></span><br><span class="line">            ListNode* secondNode = head-&gt;next;<span class="comment">//节点指针2指向每两个节点的第二个</span></span><br><span class="line"></span><br><span class="line">            curr-&gt;next=secondNode;<span class="comment">//把上一轮交换后的后面节点指向新的节点2</span></span><br><span class="line">            </span><br><span class="line">            firstNode-&gt;next = secondNode-&gt;next;<span class="comment">//指向节点2的next（这只是为了后面重新安排新的head）</span></span><br><span class="line">            </span><br><span class="line">            secondNode-&gt;next = firstNode;</span><br><span class="line">            </span><br><span class="line">            curr = firstNode;<span class="comment">//回归curr的作用，curr自然是等于firstNode，因为firstNode排后面</span></span><br><span class="line">            </span><br><span class="line">            head = firstNode-&gt;next;<span class="comment">//重新安排下一轮的head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newhead;<span class="comment">//Newhead就是指向第二个节点的指针，在第一轮就决定了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-删除链表中的节点"><a href="#5-删除链表中的节点" class="headerlink" title="5.删除链表中的节点"></a>5.删除链表中的节点</h2><p><strong>题目</strong>：</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><p><strong>示例</strong>：</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>定义一个节点指针，然后使得指针逐一递增，并且判断，如果遇到要删除的节点的话就把需要删除的节点前一节点的指针指向下一节点。最后依旧返回head</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p1=head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;<span class="comment">//判断是不是第一个节点就是要删除的节点。</span></span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;next-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;next=p1-&gt;next-&gt;next;<span class="comment">//把需要删除的节点前一节点的指针指向下一节点</span></span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><p><strong>题目</strong>：</p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 ：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>可以利用递归，从最后一个节点逐一插入到一个数组里</p><p><strong>题解</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        &#x2F;&#x2F;利用递归，从尾部往回，每次往vector&lt;int&gt;类型的a插入元素，最后就得到结果了</span><br><span class="line">        if(!head) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; a&#x3D;reversePrint(head-&gt;next);</span><br><span class="line">        a.push_back(head-&gt;val);&#x2F;&#x2F;push_back(val)，尾部插入元素val</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-两个链表的第一个公共节点。"><a href="#7-两个链表的第一个公共节点。" class="headerlink" title="7.两个链表的第一个公共节点。"></a>7.两个链表的第一个公共节点。</h2><p><strong>题目</strong>：</p><p>输入两个链表，找出它们的第一个公共节点。</p><p><strong>示例</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201207165154473.png" alt="image-20201207165154473" style="zoom: 80%;" /><p>返回c1</p><p><strong>思路</strong>：</p><p>使用双指针法：定义指针p1指向链表A的头部，指针p2指向链表B的头部。然后两个逐一往后移动，同时判断两个指针是否相等。p1移动到A尾部后，就从B头部开始继续移动。同样，p2移动到B尾部后，就从A头部继续移动。这样，在下一轮两个指针就会在交点相遇。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p1=headA;<span class="comment">//定义指针p1</span></span><br><span class="line">        ListNode* p2=headB;<span class="comment">//定义指针p2</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=(p1!=<span class="literal">NULL</span>?p1-&gt;next:headB);<span class="comment">//语句的意思：如果p1！=NULL成立，p1=p1-&gt;next,否则p1=headB</span></span><br><span class="line">            p2=(p2!=<span class="literal">NULL</span>?p2-&gt;next:headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-链表中倒数第k个节点"><a href="#8-链表中倒数第k个节点" class="headerlink" title="8.链表中倒数第k个节点"></a>8.链表中倒数第k个节点</h2><p><strong>题目</strong>：</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>定义一个全局变量num，然后利用递归，递归操作为触底反弹后num++，如果num&lt;=k,就返回head</p><h2 id="9-复杂链表的复制"><a href="#9-复杂链表的复制" class="headerlink" title="9.复杂链表的复制"></a>9.复杂链表的复制</h2><p><strong>题目</strong>：</p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p> <strong>示例</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201208200353762.png" alt="image-20201208200353762" style="zoom: 80%;" /><p><strong>思路</strong>：</p><p>（1）<strong>迭代</strong></p><p>1.先依次把每个节点拷贝并且插入到与下一个节点的中间。2.再给每个拷贝的节点的random赋值（因为新节点之间都是隔着一个旧节点，间隔是固定的，每次走两步，就能操作到每个新节点）。3.把新旧节点之间的next指向正确的节点。</p><p><strong>题解</strong>：</p><p>（1）<strong>迭代</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//如果是空表，直接返回NULL</span></span><br><span class="line">        Node* cur=head;<span class="comment">//用来迭代操作的节点指针</span></span><br><span class="line">        <span class="comment">/*1.把每个节点拷贝并且插入到与下一个节点的中间*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* Newnode=<span class="keyword">new</span> Node(cur-&gt;val);<span class="comment">//创建一个节点指针，指向新创立的节点</span></span><br><span class="line">            <span class="comment">//新节点插入操作</span></span><br><span class="line">            Newnode-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=Newnode;</span><br><span class="line">            <span class="comment">//重新赋值cur</span></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*2.拷贝新链表的random*/</span></span><br><span class="line">        cur=head;<span class="comment">//重新使cur回到头部</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//拷贝random。注意：cur-&gt;random可能是NULL（是NULL的话，就不存在cur-&gt;random-&gt;next了）。因此必须添加对cur-&gt;random是否等于NULL的判断。</span></span><br><span class="line">            cur-&gt;next-&gt;<span class="built_in">random</span>=(cur-&gt;<span class="built_in">random</span>!=<span class="literal">NULL</span>)?cur-&gt;<span class="built_in">random</span>-&gt;next:<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//对下一轮cur进行赋值</span></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*3.调整每个节点的next*/</span></span><br><span class="line">        Node* Newhead=head-&gt;next;<span class="comment">//新链表的头结点</span></span><br><span class="line">        Node* pur;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pur=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            cur=pur;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><strong>题目</strong>：</p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>（1）<strong>暴力法</strong></p><p>暴力法很简单。就是不断地枚举nums中的元素，看看哪两个元素加起来等于target。</p><p>（2）<strong>哈希表</strong></p><p>利用哈希表，存储数组的元素以及对应的下标。然后检查数组的每一个元素x对应的target-x能否在哈希表里面找到。找到的话，数组元素对应的下标和哈希表元素对应的键值就是所求。（其实就是双数组思想）</p><p><strong>暴力法题解</strong>：</p><p><strong>哈希表解法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;<span class="comment">//定义一个哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);<span class="comment">//在哈希表里面寻找符合target-x的数，赋值给it</span></span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>())<span class="comment">//如果it != hashtable.end()，也就是哈希表里面存在target-x的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;<span class="comment">//那么返回&#123;it-&gt;second, i&#125;，it-&gt;second是迭代器指向对应的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;<span class="comment">//给哈希表赋值（注意，这题解是把nums数组的值赋给哈希的键值。（因为题目说明数组元素不会重复，这倒是无所谓））</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-数组中重复的值"><a href="#2-数组中重复的值" class="headerlink" title="2.数组中重复的值"></a>2.数组中重复的值</h2><p><strong>题目</strong>：</p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>使用迭代，i=0到i&lt;nums.size(),判断nums[i]是否等于nums[nums[i]],等于的话，说明nums[i]肯定重复了。不等于的话，就把nums[i]放到nums[nums[i]]的位置。这样不断迭代下去，数值i就会不断被放到数组下标为i的位置。这样下去，当重复的数字被第二次归位，就会发现它的位置以及有“它”了，也就是nums[i]等于nums[nums[i]]。那么它就是要找的结果之一。</p><p>换个简单的描述就是，从头到尾，把数组的值nums[i]归位到数组下标为nums[i]的位置。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断nums[i]是否等于nums[nums[i]]，等于的话，说明nums[i]肯定重复了</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="comment">//如果上面判断不成立，就把nums[i]的值与nums[nums[i]]交换</span></span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp=nums[nums[i]];</span><br><span class="line">                nums[nums[i]]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-三数之和"><a href="#2-三数之和" class="headerlink" title="2.三数之和"></a>2.三数之和</h2><p><strong>题目</strong>：</p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ，请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[  [-1, 0, 1],  [-1, -1, 2]]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>为了避免重复，先将数组排序，然后开始三循环。在第一循环内（也就是a固定了）其实问题就有点类似两数之和了，target就是0-a。不过不同的是两数之和是没有重复的，所以符合条件的只有一个结果。因此，三数之和可以采用：第二第三循环使用双指针，一个指向循环的头，一个指向循环的尾，然后判断两者相加，如果大于0-a，就尾指针往回移，如果小于0-a，就头指针往后移动，这样可以避免重复枚举。另外，指针移动的时候，也需要判断移动前后指针指向的值是否相等，相等的话就直接跳过。</p><h1 id="四、哈希表"><a href="#四、哈希表" class="headerlink" title="四、哈希表"></a>四、哈希表</h1><h2 id="1-第一个只出现一次的字符"><a href="#1-第一个只出现一次的字符" class="headerlink" title="1.第一个只出现一次的字符"></a>1.第一个只出现一次的字符</h2><p><strong>题目</strong>：</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>建立一个哈希表dic，以字符作为键值。然后遍历字符串s，如果如果哈希表里能找到这个字符，就把此字符对应的数值改为0，找不到就赋值1。这样遍历一遍下来，重复的就会被赋值0，不重复的就是被赋值1。然后再遍历一次，找到第一个数值是1的就可以。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">        <span class="comment">//调用dic.find(c),如果在dic中找不到c，就会返回dic.end()。因此这一个for循环之后，重复字符在哈希表中对应的值都会变成0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">            dic[c] = dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>();</span><br><span class="line">        <span class="comment">//继续迭代判断，只要遇到dic[c]是1，就说明没有重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(dic[c]) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-无重复字符的最长子字符串"><a href="#2-无重复字符的最长子字符串" class="headerlink" title="2.无重复字符的最长子字符串"></a>2.无重复字符的最长子字符串</h2><p>和字符串的第一题一样。</p><h2 id="3-宝石与石头"><a href="#3-宝石与石头" class="headerlink" title="3.宝石与石头"></a>3.宝石与石头</h2><p><strong>题目</strong>：</p><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>简单来说，就是给定字符串J和S，输出S中可以在J找到的字符的数目</p><p><strong>示例</strong>：</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>注意:</p><p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p><p><strong>思路</strong>：</p><p>定义用于记录输出的整数num，再把J的字符存到哈希表中，然后再遍历S的字符，并且判断每个字符是否能够在哈希表里找到，找到就num++</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">char</span>&gt; gemstone;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把J的字符存到哈希表里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:J)</span><br><span class="line">            gemstone.insert(c);</span><br><span class="line">        <span class="comment">//遍历S，检查每个字符在哈希表里是否存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gemstone.<span class="built_in">find</span>(c)!=gemstone.<span class="built_in">end</span>())</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="五、二叉树"><a href="#五、二叉树" class="headerlink" title="五、二叉树"></a>五、二叉树</h1><h2 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="1.翻转二叉树"></a>1.翻转二叉树</h2><p><strong>题目</strong>：</p><p>翻转一颗二叉树</p><p><strong>示例</strong>：</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4 </span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>利用递归</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件：如果传入的根节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">        <span class="comment">//每次递归的需要进行的操作。在这题，就是将两个子节点位置互换</span></span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="comment">//返回跟节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-合并二叉树"><a href="#2-合并二叉树" class="headerlink" title="2.合并二叉树"></a>2.合并二叉树</h2><p><strong>题目</strong>：</p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p><strong>示例</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><p>注意: 合并必须从两个树的根节点开始。****</p><p><strong>思路</strong>：</p><p>利用深度优先遍历两个二叉树，同时不断构造需要输出的二叉树节点</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断t1或者t2有没有空节点，有的话就输出另一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创立新的节点，并且把t1和t2的值相加赋给新节点</span></span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        <span class="comment">//使用递归</span></span><br><span class="line">        merged-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        merged-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的最大深度"><a href="#3-二叉树的最大深度" class="headerlink" title="3.二叉树的最大深度"></a>3.二叉树的最大深度</h2><p><strong>题目</strong>：</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>使用递归。建立一个函数，给出一个根节点，就可以返回根节点的最大深度</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-将有序数组装换为二叉搜索树"><a href="#4-将有序数组装换为二叉搜索树" class="headerlink" title="4.将有序数组装换为二叉搜索树"></a>4.将有序数组装换为二叉搜索树</h2><p><strong>题目</strong>：</p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例</strong>:</p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>     0    / \  -3   9  /   /-10  5</code></pre><p>  <strong>思路</strong>：</p><p>因为需要高度平衡，而且数组时升序的，因此可以将数组的中间节点作为根节点。然后继续把数组中间节点左右两边的数据作为树的左子树根节点以及右子树根节点。因此，可以使用递归的方法，不断把数组的元素填充到二叉搜索树中。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//这里因为(left+right)可能是奇数或者偶数，因此这里mid的处理，会导致树的不同。比如当(left+right)奇数时，会有两个数组元素处于中间位置，选择左边的还是右边的，会导致树不同。在下面这个写法里，因为int类型会向下取整，所以取的是左边的。如果想取右边的，可以写int mid=(left+right+1)/2</span></span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//new新的节点，并且把数组下标为mid的元素赋值给节点。</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        <span class="comment">//利用递归，返回左右字数的节点</span></span><br><span class="line">        root-&gt;left=helper(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-二叉树的中序遍历"><a href="#5-二叉树的中序遍历" class="headerlink" title="5.二叉树的中序遍历"></a>5.二叉树的中序遍历</h2><p><strong>题目</strong>：</p><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201216202412684.png" alt="image-20201216202412684" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>思路其实很简单，利用递归算法中序遍历</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义一个函数，输入树的根节点以及空数组。在空数组中输出树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历的算法。在两个递归之间进行操作。</span></span><br><span class="line">        inorder(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        inorder(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-不同的二叉搜索树"><a href="#6-不同的二叉搜索树" class="headerlink" title="6.不同的二叉搜索树"></a>6.不同的二叉搜索树</h2><p><strong>题目</strong>：</p><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>可以看成一个数学问题。</p><p>首先，我们假设，给定整数n，会有G（n）种可能。分解来看，1~n，每个整数都可以作为根节点。</p><p>找规律：</p><p>比如节点1作为根节点，那么左子树剩下0个整数，也就只有G（0）种可能，右子树剩下2~n，共n-1个整数，就是有G（n-1）种可能。那么两个相乘，就是总的可能，即G（0）*G（n-1）。</p><p>那么节点2作为根节点，那么左子树剩下1个整数，也就只有G（1）种可能，右子树剩下3~n，共n-2个整数，就是有G（n-2）种可能。那么两个相乘，就是总的可能，即G（1）*G（n-2）。</p><p>其实已经可以发现规律，即当整数i（1=&lt;i&lt;=n）作为节点时，会有G（i-1）*G（n-i）种可能。那么，当给出整数1~n，总的可能如下</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201216223017188.png" alt="image-20201216223017188"></p><p>可以发现G（n）的值与G(0)~G（n-1）有关。而根据实际情况，我们可以知道，G（0）=0，G(1)=1。只要我们利用上面的公式，迭代从G（2）一直计算到G（n），就可以得到G（n）的值。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">G</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                G[i]+=G[j<span class="number">-1</span>]*G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-不同的二叉搜索树II"><a href="#7-不同的二叉搜索树II" class="headerlink" title="7.不同的二叉搜索树II"></a>7.不同的二叉搜索树II</h2><p><strong>题目</strong>：</p><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p><strong>大体思路</strong>：使用递归，定义一个函数，只要传入两个整数start和end，就会返回两整数之间元素能组成的所有二叉搜索树。</p><p><strong>细致思路</strong>：可以使用迭代，把逐一把整数i作为根节点。然后start<del>i-1作为左子树的节点，i+1</del>end作为右子树节点。此时，就可以使用递归，把start和i-1作为参数递归，i+1和end作为参数递归</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个节点数组，用来存储结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">//迭代，把start和end之间的每个节点轮流作为根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义左子树数组，并且使用递归得到结果</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees=generateTrees(start,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//定义右子树数组，并且使用递归得到结果</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees=generateTrees(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">            <span class="comment">//使用双层迭代，从左子树和右子树数组中逐一抽取子树进行组合，两个迭代完成后，就列举了所有此层递归左右子树数组的组合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; left:leftTrees)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; right:rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* currTree=<span class="keyword">new</span> TreeNode(i);<span class="comment">//将此时的根节点的值赋值给一个新节点</span></span><br><span class="line">                    currTree-&gt;left=left;</span><br><span class="line">                    currTree-&gt;right=right;</span><br><span class="line">                    allTrees.push_back(currTree);<span class="comment">//将组合完成的二叉搜索树假如到allTrees中。这里的allTrees，当递归往回退一层时，也就是被赋值到leftTrees或者rightTrees了</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8.对称二叉树"></a>8.对称二叉树</h2><p><strong>题目</strong>：</p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"> </span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>定义两个节点指针p1和p2，然后使用递归，不断判断拍p1-&gt;val是否等于p2-&gt;val。</p><p>整理成写代码思路，就是定义一个递归函数，输入参数类型是两个节点指针类型，函数会对p1-&gt;val是否等于p2-&gt;val进行判断。然后再递归p1的左节点与p2的右节点，以及p1的右节点与p2的左节点。因为需要每一次判断都是true，</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//针对p1、p2都是指向空节点的情况，这时候应该返回true</span></span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">nullptr</span>&amp;&amp;p2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//针对p1、p2有其中一个指向空节点，但是有一个不是空的。这时候明显不对称了，应该返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!p1 || !p2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断p1-&gt;val==p2-&gt;val，以及递归操作</span></span><br><span class="line">        <span class="keyword">return</span> p1-&gt;val==p2-&gt;val&amp;&amp;check(p1-&gt;left,p2-&gt;right)&amp;&amp;check(p1-&gt;right,p2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六、堆"><a href="#六、堆" class="headerlink" title="六、堆"></a>六、堆</h1><h1 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h1><h2 id="1-爬楼梯问题"><a href="#1-爬楼梯问题" class="headerlink" title="1.爬楼梯问题"></a>1.爬楼梯问题</h2><p><strong>题目</strong>：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例</strong>：</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶</span><br><span class="line">2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶 + 1 阶</span><br><span class="line">1 阶 + 2 阶</span><br><span class="line">2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>简单题解：根据规律，可以知道n级台阶可以通过n-1级爬1级到达，或者n-2级爬2级到达。也就是发f(n)=f(n-1)+f(n-2)，那么就可以使用动态规划，依次把f(1)到f(n)算出来，就可以得到答案。</p><p><strong>题解</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int a&#x3D;0,b&#x3D;1,c&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c&#x3D;a+b;</span><br><span class="line">            a&#x3D;b;</span><br><span class="line">            b&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-最小路径和"><a href="#2-最小路径和" class="headerlink" title="2.最小路径和"></a>2.最小路径和</h2><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210302175737257.png" alt="image-20210302175737257" style="zoom:80%;" /><p><strong>思路</strong>：</p><p>使用动态规划。</p><p>因为只可以往右移或者网下移动。那么容易知道，</p><p>第一行的状态转移方程是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+dp[i][j-1]</span><br></pre></td></tr></table></figure><p>第一列的状态转移方程是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+dp[i-1][j]</span><br></pre></td></tr></table></figure><p>其他的状态转移方程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+min(dp[i-1][j],dp[i][j-1])</span><br></pre></td></tr></table></figure><p>题解:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>()==<span class="number">0</span>||grid[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(grid)</span></span>;<span class="comment">//定义一个数组存储结果</span></span><br><span class="line">        <span class="keyword">int</span> rows=grid.<span class="built_in">size</span>(),columns=grid[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//获取输入的行数和列数</span></span><br><span class="line">        <span class="comment">//算第一列的dp,i从1开始是因为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><p>简单常见的有冒泡排序，选择排序，快速排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])<span class="comment">//这里使用大于号的话，就是升序排序</span></span><br><span class="line">&#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>])</span><br><span class="line"><span class="built_in">min</span> = j;</span><br><span class="line">&#125;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[<span class="built_in">min</span>];</span><br><span class="line">arr[<span class="built_in">min</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> i, j, datum, temp;<span class="comment">//datum就是基准的数</span></span><br><span class="line">i = left;</span><br><span class="line">j = right;</span><br><span class="line">datum = arr[left];<span class="comment">//一般最开始取首项为基准</span></span><br><span class="line"><span class="keyword">while</span> (i!=j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (arr[j] &gt;= datum &amp;&amp; i &lt; j) j--;<span class="comment">//j从最右边开始往左移动，遇到小于基准数就停下</span></span><br><span class="line"><span class="keyword">while</span> (arr[i] &lt;= datum &amp;&amp; i &lt; j) i++;<span class="comment">//i从最左边往右移动，遇到大于基准数的就停下</span></span><br><span class="line"><span class="comment">//交换arr[i]和arr[j],因为快速排序的思想就是把小于基准的放左边，大于的放右边。</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//把这一轮停下来的arr[i]与datum交换。因为这时候arr[i]是比datum小的。</span></span><br><span class="line">arr[left] = arr[i];<span class="comment">//交换一轮后，arr[i]的值会小于datum（自己操作下试试）</span></span><br><span class="line">arr[i] = datum;</span><br><span class="line">quicksort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">quicksort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">size</span>(a);</span><br><span class="line">selectsort(a, len);</span><br><span class="line">    <span class="comment">//bubblesort(a, len);</span></span><br><span class="line"><span class="comment">//quicksort(a, 0, len-1);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><h2 id="1-买卖股票的最佳时机"><a href="#1-买卖股票的最佳时机" class="headerlink" title="1.买卖股票的最佳时机"></a>1.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>既然可以无数次买入卖出，那么我每次买入卖出的时间间隔选择最小的时间间隔：1天，然后只要每次买入卖出的收益大于0，最终总的收益肯定是最大的</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>(),result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result+=<span class="built_in">max</span>(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-分发饼干"><a href="#2-分发饼干" class="headerlink" title="2.分发饼干"></a>2.分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：把饼干从大到小分别分配给胃口大到小的人，换句话说就是“尽量不浪费饼干”，只要每次分配都是“最不浪费饼干”的做法，最后也会满足最多的孩子。这也是贪心算法的思想。</p><p><strong>题解</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基本知识点</title>
      <link href="/2020/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<div align="center">————这里，有操作系统的一些基础知识点^_^————</div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>操作系统是什么：</strong></p><p>操作系统（Operating System， OS） 是指控制和管理整个计算机系统的硬件和软件资源， 并合理地组织调度计算机的工作和资源的分配； 以提供给用户和其他软件方便的接口和环境； 它是计算机系统中最基本的系统软件。  </p><h1 id="一、操作系统基本知识"><a href="#一、操作系统基本知识" class="headerlink" title="一、操作系统基本知识"></a>一、操作系统基本知识</h1><h2 id="1-1-操作系统特征"><a href="#1-1-操作系统特征" class="headerlink" title="1.1 操作系统特征"></a>1.1 操作系统特征</h2><p> <strong>并发性</strong></p><p>指两个或多个事件在同一时间间隔内发生。 这些事件宏观上是同时发生的， 但微观上是交替发生的。常考易混概念——<u>并行</u>： 指两个或多个事件在同一时刻同时发生。  </p><p>比如，单核CPU同一时刻只能执行一个程序，各个程序只能<strong>并发</strong>地执行。多核CPU同一时刻可以同时执行多个程序，多个程序可以<strong>并行</strong>地执行</p><p><strong>共享性</strong></p><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>共享性和并发性联系密切。如果没有并发性，也就是没有并发需求，那么共享性就失去了意义。如果没有共享性，那么并发性也无法实现。</p><p><strong>虚拟性</strong></p><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上 对应物（后者）是用户感受到的。</p><p><strong>异步性</strong></p><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>就好比如一个程序需要使用摄像头，但是另外一个程序也需要使用摄像头，但是因为摄像头已经被第一个程序使用了，第二个程序就要等待第一个程序使用完摄像头再使用。这就是异步。</p><h2 id="1-2-OS的发展与分类"><a href="#1-2-OS的发展与分类" class="headerlink" title="1.2 OS的发展与分类"></a>1.2 OS的发展与分类</h2><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201219151006528.png" alt="image-20201219151006528" style="zoom: 67%;" /><h2 id="1-3-OS的运行机制和体系结构"><a href="#1-3-OS的运行机制和体系结构" class="headerlink" title="1.3 OS的运行机制和体系结构"></a>1.3 OS的运行机制和体系结构</h2><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201219161459552.png" alt="image-20201219161459552" style="zoom:67%;" /><h2 id="1-4-中断与异常"><a href="#1-4-中断与异常" class="headerlink" title="1.4 中断与异常"></a>1.4 中断与异常</h2><p><strong>中断的作用</strong>：“中断” 会使CPU由用户态变为内核态， 使操作系统重新夺回对CPU的控制权  。如果没有“中断” 机制， 那么一旦应用程序上CPU运行， CPU就会一直运行这个应用程序 。那么就实现不了并发。</p><p><strong>内核态和用户态之间切换</strong>：</p><p>内核态-&gt;用户态： 执行一条特权指令——修改PSW的标志位为“用户态” ， 这个动作意味着操作系统将主动让出CPU使用权<br>用户态-&gt;内核态： 由“中断” 引发， 硬件自动完成变态过程， 触发中断信号意味着操作系统将强行夺回CPU的使用权  </p><p><strong>中断的分类</strong>：</p><blockquote><p>1.<strong>内中断</strong>：与当前执行的指令有关，中断信号来源于CPU内部  。例子：有时候应用程序想请求操作系统内核的服务， 此时会执行一条特殊的指令——陷入指令， 该指令会引发一个内部中断信号  </p><p>2.<strong>外中断</strong>：与当前执行的指令无关，中断信号来源于CPU外部  例子：时钟中断——由时钟部件发来的中断信号  </p></blockquote><p><strong>异常</strong>：内中断一般称为“异常”  。狭义的中断， 是指外中断</p><h2 id="1-5-系统调用"><a href="#1-5-系统调用" class="headerlink" title="1.5 系统调用"></a>1.5 系统调用</h2><p><strong>系统调用含义</strong>：“系统调用” 是操作系统提供给应用程序（程序员/编程人员） 使用的接口。可以理解为一种可供应用程序调用的特殊函数， 应用程序可以通过系统调用来请求获得操作系统内核的服务 。</p><p><strong>作用</strong>：通过系统调用的方式向操作系统内核提出服务请求， 由操作系统内核代为完成。 这样可以保证系统的稳定性和安全性， 防止用户进行非法操作。  </p><p>换个通俗点的说法，就是电脑会有很多应用程序，它们可能在同一段时间内对一个有限的系统资源有使用需求，就如这时候没有系统调用这个机制，那么它们就会争夺资源，导致十分混乱，任务无法正常执行。</p><p><strong>系统调用过程</strong>：传入参数<strong>—&gt;</strong>执行陷入指令（也称为trap指令或者访管指令）(此时处于用户态)—&gt;由操作系统内核程序处理系统调用请求<strong>—&gt;</strong>返回应用程序</p><h1 id="二、进程"><a href="#二、进程" class="headerlink" title="二、进程"></a>二、进程</h1><h2 id="2-1-进程的基本概念"><a href="#2-1-进程的基本概念" class="headerlink" title="2.1 进程的基本概念"></a>2.1 进程的基本概念</h2><p><strong>进程的概念</strong>：程序的一次执行过程  ，进程是资源分配的基本单位  。（同一个程序多次执行会对应多个进程  ）</p><p><strong>进程和程序的区别</strong>：程序是静态的， 就是个存放在磁盘里的可执行文件， 就是一系列的指令集合。  进程（Process）是动态的， 是程序的一次执行过程  </p><p><strong>进程的组成</strong>：</p><blockquote><p><strong>1.PCB（进程控制块）</strong>：包含着进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。（PCB是进程存在的唯一标志， 当进程被创建时， 操作系统为其创建PCB， 当进程结束时， 会回收其PCB。）</p><p><strong>2.程序段</strong>：程序的代码</p><p><strong>3.数据段</strong>：运行过程中产生的各种数据（如程序的定义的变量）</p></blockquote><p><strong>进程的特征</strong>：</p><blockquote><p>1.<strong>动态性</strong>:进程是程序的一次执行过程，是动态地产生、变化和消亡的。(<strong>动态性是进程最基本的特征</strong>  )</p><p>2.<strong>并发性</strong>：内存中有多个进程实体，各进程可以并发执行</p><p>3.<strong>独立性</strong>：进程是能独立运行，独立获得资源、独立接受调度的基本单位</p><p>4.<strong>异步性</strong>：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步的问题</p><p>5.<strong>结构性</strong>:每个进程都会配置一个PCB。结构上，进程由程序段，数据段，PCB组成。</p></blockquote><h2 id="2-2-进程的状态及转换"><a href="#2-2-进程的状态及转换" class="headerlink" title="2.2 进程的状态及转换"></a>2.2 进程的状态及转换</h2><p><strong>进程的基本状态</strong>：</p><blockquote><p>1.<strong>运次态</strong>：占用CPU，并在CPU上运行</p><p>2.<strong>就绪态</strong>：以及具备运行条件，但由于没有空闲的CPU，而暂时不能运行。</p><p>3.<strong>阻塞态</strong>：因等待某一事件而暂时不能运行。（比如等待分配打印机、等待读磁盘操作的结果等。这是进程会暂时转换到阻塞态）</p></blockquote><p>（另外还有创建态：操作系统为新的进程分配资源，创建PCB。终止态：操作系统回收进程的资源，撤销PCB）</p><p><strong>进程状态的转换</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201221150654200.png" alt="image-20201221150654200" style="zoom: 50%;" /><h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><p><strong>作用</strong>：进程控制就是要实现进程状态转换  </p><p><strong>如何实现进程控制</strong>：用原语实现进程的控制。（原语执行期间不允许中断）</p><p><strong>控制原语要做的三类事情</strong>：</p><ol><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源  </li></ol><p>比如进程切换原语需要做的事情：1.将运行环境信息存入PCB（为了下次恢复这个进程做准备）。2.PCB移入相应队列。3.选择另一个进程执行，并更新其PCB。4.根据PCB恢复新进程需要的运行环境。</p><h2 id="2-4-进程通信"><a href="#2-4-进程通信" class="headerlink" title="2.4 进程通信"></a>2.4 进程通信</h2><p>1.<strong>共享存储</strong></p><blockquote><ul><li><p>设置一个共享空间，两个进程需要互斥地访问共享空间。</p></li><li><p>两种方式：（1）基于数据结构。（2）基于存储区的共享</p></li></ul></blockquote><p>2.<strong>管道通信</strong></p><blockquote><ul><li><p>设置一个特殊的共享文件（管道），其实就是一个缓冲区。</p></li><li><p>一个管道只能实现半双工通信。也就是一个管道只可以实现从一个方向写操作，在另一个方向读操作。各进程也要互斥访问管道。</p></li><li><p>管道写满时不能再写、读空时不能再读、没写满不能读、没读完不能写</p></li></ul></blockquote><p>3.<strong>消息传递</strong></p><blockquote><ul><li>传递结构化的信息。</li><li>两种方式：（1)直接通信方式：信息直接挂到接收方的消息队列。（2）间接通信方式：消息先发送到中间体（信箱）</li></ul></blockquote><h1 id="三、线程"><a href="#三、线程" class="headerlink" title="三、线程"></a>三、线程</h1><h2 id="3-1-线程的基本概念"><a href="#3-1-线程的基本概念" class="headerlink" title="3.1 线程的基本概念"></a>3.1 线程的基本概念</h2><p>线程可以理解为轻量级进程。比如qq可以同时视频聊天，同时文字聊天，就是使用了线程并发。</p><p><strong>为什么需要线程</strong>：</p><p>为什么需要线程？我不可以多个进程并发吗。可以是可以，但是进程间的并发开销更大。前面有说过进程是资源分配的基本单位，也是CPU调度的基本单位，多进程的创建涉及到资源的分配，进程之间的切换也会需要保存、恢复运行环境等较大的开销。引入线程后，线程是CPU调度的基本单位，资源分配的基本单位依旧是进程。同一进程内的各个线程间并发， 不需要切换进程运行环境和内存地址空间，省时省力  </p><p><strong>引入线程带来的变化</strong>：</p><blockquote><ul><li>资源分配、调度的基本单位改变。</li><li>线程间也可以并发，提高了并发度</li><li>系统开销变小</li></ul></blockquote><p><strong>多线程模型</strong>：</p><blockquote><p>1.<strong>多对一模型</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201221191815244.png" alt="image-20201221191815244" style="zoom:50%;" /><p>优点：进程管理开销小，效率高。（因为线程切换在用户态就可以搞定）</p><p>缺点：并发度低，假如一个线程被阻塞，整个进程都被阻塞</p><p>2.<strong>一对一模型</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201221192010506.png" alt="image-20201221192010506" style="zoom:67%;" /><p>优点：各线程可以分配到多核处理机中并行执行。（比如这幅图，就可以分配给三个处理机）</p><p>缺点：进程管理开销大。（一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成， 需要切换到<br>核心态， 因此线程管理的成本高， 开销大。  ）</p><p>3.<strong>多对多模型</strong>：</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201221192512866.png" alt="image-20201221192512866" style="zoom:67%;" /><p>优点：集前两者的优点</p><p>缺点：实现相对复杂</p></blockquote><h1 id="四-调度"><a href="#四-调度" class="headerlink" title="四.调度"></a>四.调度</h1><h2 id="4-1-进程调度"><a href="#4-1-进程调度" class="headerlink" title="4.1 进程调度"></a>4.1 进程调度</h2><p><strong>基本概念</strong>：按某种算法选择一个进程将处理机分配给它</p><p><strong>三个层次</strong>：</p><blockquote><p>1.<strong>高级调度</strong>：从后备队列中选择合适的作业将其调入内存，并为其创建进程。</p><p>2.<strong>中级调度</strong>：从挂起队列中选择合适的进程将其数据调回内存。</p><p>3.<strong>低级调度</strong>：从就绪队列中选择一个进程为其分配处理机。</p></blockquote><p><strong>进程调度的一个重要知识点</strong>：进程的调度，切换是有代价的，并不是调度越频繁，并发度越高。</p><h2 id="4-2-调度算法的评价指标"><a href="#4-2-调度算法的评价指标" class="headerlink" title="4.2 调度算法的评价指标"></a>4.2 调度算法的评价指标</h2><p><strong>（1）cpu利用率</strong></p><p>利用率=忙碌的时间/总时间</p><p><strong>（2）系统吞吐量</strong></p><p>单位时间内完成的作业的数量</p><p>系统吞吐量=完成作业的数量/完成作业的总时间</p><p><strong>（3）周转时间</strong></p><p>作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><p>带权周转时间：作业周转时间/作业实际运行的时间。</p><p><strong>（4）等待时间</strong></p><p>指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p><p><strong>（5）响应时间</strong></p><p>从用户提交请求到首次产生响应所用的时间</p><h2 id="4-3-几种调度算法"><a href="#4-3-几种调度算法" class="headerlink" title="4.3 几种调度算法"></a>4.3 几种调度算法</h2><p><strong>（1）FCFS</strong>（先来先服务，first come first serve）</p><p>非抢占式算法</p><p>类似我们生活中排队买东西，按照到达时间顺序来处理。属于非抢占式的算法。</p><p>优点：公平、算法实现简单</p><p>缺点：对于短作业不利。举个例子，排队买奶茶，如果你只需要买一杯奶茶，但是你前面的一位顾客需要买20杯奶茶。这时候，如果采用FCFS，那么你就要等前面那个人买完20杯奶茶才可以。所以，这种算法对短进程并不友好。</p><p><strong>（2）SJF</strong>（短作业优先，shortest job first)</p><p>非抢占式算法</p><p>简单来说，就是如果同时有几个进程在等待处理机，那么使用处理机时间短的作业就会优先分配处理机。用回奶茶的例子就是，假如奶茶店先后来了三个人，分别买3,2,1杯奶茶，老板在选择时就会优先选择先做需要买1杯的那个人的。</p><p>注意：一般来说，短作业优先算法也是非抢占式的，但是，也会有抢占式的短作业优先算法。就是会判断正在进行的作业剩余时间和正在等待的作业需要的时间哪个更短，更短的就会优先。比如你去买3杯奶茶，你的做好一杯后，来了个买1杯的，按照这个算法，老板就会暂时停止做你的奶茶，去做那个人的一杯奶茶。</p><p>优点：可以降低总体的等待时间，对短作业友好</p><p>缺点：对长作业不友好，长作业容易出现饥饿甚至”饿死”</p><p><strong>（3）HRRN</strong>（高响应比优先，highest response ratio next）</p><p>非抢占式算法</p><p>这个算法，综合了前面两个算法的优点。采用了根据响应比来决定分配处理机的方法。</p><p>响应比=（等待时间+要求服务时间）/要求服务时间。高响应的进程优先。这样的算法的好处在于，如果两个进程要求服务时间相等，那么等待时间长的进程响应比就会大，就会被优先分配，符合FCFS的优点。如果两个进程的等待时间相等，那么要求服务时间短的进程响应比就会大，就会优先分配，符合SJF的优点。</p><p><strong>(4）时间片轮转</strong></p><p>就是设定好单位时间片的时间，进程在处理机上执行一个时间片之后就会被强制抢夺处理机，这时候若进程还没处理完，就需要回到就绪队列重新排队，并且将进程剩余服务时间作为要求服务时间。</p><p>优点：公平，响应快，适用于分时操作系统，不会导致饥饿。</p><p>缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。</p><p><strong>（5）优先级调度算法</strong></p><p>每个作业/进程有各自的优先级，按照优先级来调度。</p><p>通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程。</p><p>优点：可以用优先级区分紧急程度，重要程度，适用于实时操作系统。可以灵活地调整各进程。</p><p>缺点：如果源源不断地有高优先级的进程到来，可能会导致饥饿。</p><p><strong>（6）多级反馈队列</strong></p><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第1级队列，若时间片用完进程还未结束，则进程进入下一级队列的队尾。只有第k级队列为空时，才会为k+1级队头的进程分配时间片用于进程调度。</p><p>优点：结合了前面几种算法的优点</p><p>缺点：可能会导致饥饿的</p><h1 id="五、进程同步、进程互斥"><a href="#五、进程同步、进程互斥" class="headerlink" title="五、进程同步、进程互斥"></a>五、进程同步、进程互斥</h1><h2 id="5-1-基础概念"><a href="#5-1-基础概念" class="headerlink" title="5.1 基础概念"></a>5.1 基础概念</h2><p><strong>进程同步</strong>：并发性带来了异步性，有时候需要通过进程同步来解决这种异步问题。比如在管道通信中，写操作一定要在读操作之前，这就需要进程同步机制来调节。</p><p><strong>进程互斥</strong>：对临界资源的访问，需要互斥地进行，同一时间段内只允许一个进程访问该资源。</p><p>进程互斥需要遵循的原则：</p><blockquote><p>1.空闲让进：临界区空闲时，应允许一个进程访问。</p><p>2.忙则等待：临界区正在被访问时，其他视图访问的进程需要等待。</p><p>3.有限等待：要在有限时间内进入临界区，保证不会饥饿</p><p>4.让权等待：进不了临界区的进程，要释放处理机，防止忙等。</p></blockquote><p>根据这四个原则，可以判断一个进程互斥方法是否可靠，可靠的方法需要满足这四个原则</p><h2 id="5-2-进程互斥的软件实现方法"><a href="#5-2-进程互斥的软件实现方法" class="headerlink" title="5.2 进程互斥的软件实现方法"></a>5.2 进程互斥的软件实现方法</h2><p><strong>（1)单标志法</strong></p><p>设置一个变量，假设为turn，用turn的值来决定允许进入临界区的进程。伪代码如下</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210109143654057.png" alt="image-20210109143654057" style="zoom:80%;" /><p>存在问题：假如turn=0，说明P0进程被允许访问临界区，但是如果P0又一直不进入临界区，那么其他进程也无法访问临界区，因为谁能访问临界区需要靠P0进程的语句3来决定。也就是违反了“空闲让进”原则。</p><p><strong>（2）双标志先检查法</strong></p><p>设置一个数组，里面存着各个进程的标志值，1代表想进入临界区，0代表不想进入。一个进程想进入临界区之前，会想检查其他进程的标志值是否全为0，全是0的情况先，进程才会申请修改自己的标志位为1，来表示自己想进入临界区的意愿。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210109144410881.png" alt="image-20210109144410881" style="zoom:80%;" /><p>存在问题：因为进程是并发执行的，有可能出现大家都为0的情况下，然后两个进程都认为别人是0，然后修改了自己的标志位为1，同时访问了临界区，违背了最主要的“忙则等待”原则。</p><p><strong>（3）双标志后检查法</strong></p><p>和上面的类似，只是这个会先标志自己想进入临界区，再检查其他进程是否需要进入临界区。</p><p>问题也很明显，可能两个进程都把自己的标志位改了，然后检查的时候都发现有别的进程标志位为1，因此就在不断等待。违背“空闲让进”和“有限等待”原则。</p><p>上面的几种方法，都没有完全满足四个原则，因此并不是合格的进程互斥实现方法。</p><p><strong>（4）peterson 算法</strong></p><img src="C:\Users\10240\AppData\Roaming\Typora\typora-user-images\image-20210109221832692.png" alt="image-20210109221832692" style="zoom: 50%;" /><h2 id="5-3-进程互斥的硬件实现方法"><a href="#5-3-进程互斥的硬件实现方法" class="headerlink" title="5.3 进程互斥的硬件实现方法"></a>5.3 进程互斥的硬件实现方法</h2><p><strong>(1)中断屏蔽方法</strong></p><p><strong>简述</strong>：利用“开/关中断指令” 实现 。也就是在进程运行的时候直接把中断关了，那么就不会发生中断，自然不会发生进程的切换。</p><p><strong>优点：</strong>简单，高效。</p><p><strong>缺点：</strong></p><ul><li>不适用于多处理机。因为开关中断是对于一个处理机来说的，比如处理机A关中断，那么处理机B是不会关中断的，所以这时候B处理机的进程仍然可能访问那个临界区，导致两个进程同时访问临界区。</li><li>只适用于操作系统内核进程，不适用于用户进程。因为开关中断只能运行在内核态。</li></ul><p><strong>（2）TestAndSet指令</strong></p><p><strong>优点：</strong> 实现简单， 无需像软件实现方法那样严格检查是否会有逻辑漏洞； 适用于多处理机环境<br><strong>缺点：</strong> 不满足“让权等待” 原则， 暂时无法进入临界区的进程会占用CPU并循环执行TSL指令， 从而导致“忙等” 。  </p><p><strong>(3)Swap指令</strong></p><p>优缺点与TestAndSet指令一样</p><h2 id="5-4-信号量机制"><a href="#5-4-信号量机制" class="headerlink" title="5.4 信号量机制"></a>5.4 信号量机制</h2><p>在前面的两小节，进程互斥的软硬件实现方法中，我们发现有下面两个问题。</p><blockquote><p>1.在双标志先检查法中， 进入区的“检查” 、 “上锁” 操作无法一气呵成， 从而导致了两<br>个进程有可能同时进入临界区的问题。</p><p>2.所有的解决方案都无法实现“让权等待” 。 </p></blockquote><p>信号量机制就是用来可以同时解决上述两个问题的方法。</p><p><strong>含义简述</strong>：用户进程可以通过使用操作系统提供的<u>一对原语</u>来对<u>信号量</u>进行操作， 从而很方便的实现了进程互斥、 进程同步。  </p><p>信号量其实就是一个变量，可以是一个整数，也可以是一个更加复杂的记录型变量。原语有两个：wait（S）和signal（S）原语（也简称P，V操作）。</p><p>根据信号量的类型，下面分为两小点。</p><h3 id="5-4-1-整型信号量"><a href="#5-4-1-整型信号量" class="headerlink" title="5.4.1 整型信号量"></a>5.4.1 整型信号量</h3><p>用一个整数型的变量作为信号量， 用来表示系统中某种资源的数量，比如打印机资源就可以用整型信号量，因为打印机是一台台的。</p><p>例子：某计算机系统中有一台打印机…  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210206231536900.png" alt="image-20210206231536900" style="zoom:50%;" /><p>从上面就可以看到，信号量S就设置为1，代表打印机资源的数量。两个原语的定义如上，其实wait原语就是检查打印机资源S是否小于等于0，如果是，代表现在没有打印机可用，同时while循环就会一直执行，也就是p0进程中wait（S）这一步会卡住，P0无法使用打印机。假如S不为0，while循环就不会一直执行，就下来wait原语将S-1，代表打印机资源减少一个。</p><p><strong>缺陷</strong>：不满足“让权等待”原则， 会发生“忙等”  。例如打印机资源为0的时候，有一个进程占用了处理机，但是它又一直在检查打印机资源，只要没分配到打印机资源，它就会一直等待，造成“忙等”</p><h3 id="5-4-2-记录型信号量"><a href="#5-4-2-记录型信号量" class="headerlink" title="5.4.2 记录型信号量"></a>5.4.2 记录型信号量</h3><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210207165059357.png" alt="image-20210207165059357"></p><p>记录型信号量最大的变化就是，会检查资源的数量，如果数量不足，就会把进程切换到阻塞态（利用block原语）。当其他进程使用完资源之后，也会检查是否还有别的进程在等待这个资源，有的话就会使用wakeup原语唤醒等待队列中的一个进程（看上面例子，如果S.value&lt;=0,就代表还有其他进程在等待，不然肯定资源数是&gt;0的）。</p><p><strong>优点</strong>：符合“让权等待”。因为资源用完的时候进程会被切换到阻塞态，不会一直占用着处理机。</p><h2 id="5-5-信号量机制实现进程互斥、同步"><a href="#5-5-信号量机制实现进程互斥、同步" class="headerlink" title="5.5 信号量机制实现进程互斥、同步"></a>5.5 信号量机制实现进程互斥、同步</h2><p><strong>（1）进程互斥</strong></p><p>根据上面信号量机制的原理，其实只要把临界区当做一种资源，资源的信号量设置为1即可，处理方法和上面所述一样原理。</p><p><strong>（2）进程同步</strong></p><p>并发性带来了异步性，有时候需要通过进程同步来解决这种异步问题。看下面这个例子</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210207182158663.png" alt="image-20210207182158663" style="zoom:50%;" /><p>假如代码4的运行一定要基于代码1和代码2的运行结果，但是由于并发性，如果没有什么同步机制的情况下，处理机就有可能先执行代码4，之后再轮到代码1和2，这个时候自然就会出错。那么如何利用信号量来实现这个操作呢。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210207182629801.png" alt="image-20210207182629801" style="zoom:80%;" /><p>如上图，将信号量初始值设置为0。在需要先执行的代码块后面添加V操作，后执行的代码块前面添加P操作。这样只要没有执行完代码1和2，就不会执行V操作，也就是信号量会&lt;=0，导致P操作会卡住。</p><p><strong>（3）信号量机制实现前驱关系</strong></p><p>前驱关系其实就是同步的问题。假如现在有这么一个问题：进程 P1 中有句代码 S1， P2 中有句代码 S2 ， P3中有句代码S3 …… P6 中有句代码 S6。 这些代码要求按如下前驱图所示的顺序来执行：  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210208150831144.png" alt="image-20210208150831144" style="zoom: 50%;" /><p>那么应该怎么处理呢。其实，只要在每前后两个进程之间设置一个信号量即可控制。这种前后两个进程的关系也称作前驱关系。</p><p>每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）<br>因此需要做的工作就是</p><blockquote><p>1.要为每一对前驱关系各设置一个同步信号量</p><p>2.在“前操作” 之后对相应的同步信号量执行 V 操作</p><p>3.在“后操作” 之前对相应的同步信号量执行 P 操作  </p></blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210208151359186.png" alt="image-20210208151359186" style="zoom:50%;" /><h2 id="5-6-生产者-消费者问题"><a href="#5-6-生产者-消费者问题" class="headerlink" title="5.6 生产者-消费者问题"></a>5.6 生产者-消费者问题</h2><p><strong>问题描述</strong>：</p><p>系统中有一组生产者进程和一组消费者进程， 生产者进程每次生产一个产品放入缓冲区， 消费者进程每次从缓冲区中取出一个产品并使用，（注： 这里的“产品” 理解为某种数据。生产者、 消费者共享一个初始为空、 大小为n的缓冲区。</p><p>那么，根据前vp后的原则，图解如下</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210209132836864.png" alt="image-20210209132836864" style="zoom:67%;" /><h2 id="5-7-管程"><a href="#5-7-管程" class="headerlink" title="5.7 管程"></a>5.7 管程</h2><p>根据上面信号量机制的知识可以知道，信号量机制存在的问题： 编写程序困难、 易出错 。因此就有人引入了管程。引入管程的目的是更方便地实现进程互斥和同步 。</p><p>管程的基本特征：</p><blockquote><p>\1. 局部于管程的数据只能被局部于管程的过程所访问；<br>\2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；<br>\3. 每次仅允许一个进程在管程内执行某个内部过程。  </p></blockquote><p>其实，就类似于C++里面的类，体现的是一种封装的思想。</p><h1 id="六、死锁"><a href="#六、死锁" class="headerlink" title="六、死锁"></a>六、死锁</h1><h2 id="6-1-死锁产生的必要条件"><a href="#6-1-死锁产生的必要条件" class="headerlink" title="6.1 死锁产生的必要条件"></a>6.1 死锁产生的必要条件</h2><p>死锁产生的必要条件：</p><blockquote><p>1.<strong>互斥条件</strong>：就是某个资源只能被互斥地使用</p><p>2.<strong>不可剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p><p>3.<strong>请求和保持条件</strong>：进程已经保持至少一个资源，但又提出新的资源请求，而该资源又被其他进程占有。</p><p>4.<strong>循环等待条件</strong>：存在一种进程资源的循环等待链。</p></blockquote><h2 id="6-2-预防死锁的方法"><a href="#6-2-预防死锁的方法" class="headerlink" title="6.2 预防死锁的方法"></a>6.2 预防死锁的方法</h2><p>预防死锁，可以通过破坏四个必要条件的其中一个来实现，下面简述下方法以及缺点。</p><p><strong>1.破坏互斥条件</strong></p><p>将临界资源改造为可共享使用的资源。比如弄个队列把需要用到临界资源的进程排队。</p><p>缺点：可行性不高，在某些情况下必须保持临界资源的互斥性</p><p><strong>2.破坏不可剥夺条件</strong></p><ul><li>申请的资源得不到满足时，立即释放拥有的所有资源。</li><li>由操作系统协助剥夺（考虑优先级）</li></ul><p>缺点：实现复杂，剥夺资源可能导致部分工作实效。反复申请导致系统开销大；可能导致饥饿</p><p><strong>3.破坏请求和保持条件</strong></p><p>运行前分配好所有需要的资源，之后一直保持。</p><p>缺点：有些资源可能某个进程只需要使用很短时间，但是却在整个过程占用，资源利用率低；可能导致饥饿</p><p><strong>4.破坏循环等待条件</strong></p><p>给资源编号，必须按照编号从小到大的顺序申请资源。</p><p>缺点：用户编程麻烦；如果5号是打印机，7号是摄像头，进程就必须先申请5号，但是如果进程需要先使用摄像头很长一段时间再使用打印机，就会导致资源浪费。</p><h2 id="6-3-避免死锁的方法"><a href="#6-3-避免死锁的方法" class="headerlink" title="6.3 避免死锁的方法"></a>6.3 避免死锁的方法</h2><p>通过特定的算法，避免系统进入不安全状态。</p><p>首先需要了解几个概念：</p><p><strong>安全序列</strong>：所谓安全序列， 就是指如果系统按照这种序列分配资源， 则每个进程都能顺利完成。</p><p><strong>安全状态：</strong>只要能找出一个安全序列，系统就是安全状态。 当然， 安全序列可能有多个。</p><p><strong>不安全状态：</strong>如果分配了资源之后，系统中找不出任何一个安全序列， 系统就进入了不安全状态。</p><p> 如果系统处于安全状态， 就一定不会发生死锁。 如果系统进入不安全状态， 就可能发生死锁（处于不安全状态未必就是发生了死锁， 但发生死锁时一定是在不安全状态）  </p><p><strong>避免系统进入不安全状态的算法：</strong>银行家算法</p><p><strong>数据结构：</strong><br>长度为 m 的一维数组 Available 表示还有多少可用资源<br>n<em>m 矩阵 Max 表示各进程对资源的最大需求数<br>n</em>m 矩阵 Allocation 表示已经给各进程分配了多少资源<br>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</p><p><strong>银行家算法步骤：</strong><br>①检查此次申请是否超过了之前声明的最大需求数<br>②检查此时系统剩余的可用资源是否还能满足这次请求<br>③试探着分配， 更改各数据结构<br>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p><strong>安全性算法步骤：</strong><br>检查当前的剩余可用资源是否能满足某个进程的最大需求， 如果可以， 就把该进程加入安全序列，<br>并把该进程持有的资源全部回收。<br>不断重复上述过程， 看最终是否能让所有进程都加入安全序列。  </p><h1 id="七、内存"><a href="#七、内存" class="headerlink" title="七、内存"></a>七、内存</h1><h2 id="1-一些简单概念"><a href="#1-一些简单概念" class="headerlink" title="1.一些简单概念"></a>1.一些简单概念</h2><p><strong>内存是什么</strong>：内存是用于存放数据的硬件，被划分为一个一个存储单元。程序执行前需要先放到内存中才能被CPU处理。（因为CPU处理速度快，直接读取外存的话读取速度跟不上处理速度）</p><p><strong>4GB内存：</strong>1GB=2^10MB=2^20KB=2^30B，所以4GB为2^32B，所以需要2^32个存储单元，也就是要32位二进制才可以全部表示。因此，32位的操作系统最大支持4GB内存。</p><h2 id="2-页面置换算法"><a href="#2-页面置换算法" class="headerlink" title="2.页面置换算法"></a>2.页面置换算法</h2><p><strong>（1）最佳置换算法——OPT</strong></p><p>这个算法无法实现。</p><p><strong>思想</strong>：假如知道进程接下来访问的页面，就可以知道哪个页面最后才被访问到，就把最后才会被访问的页面置换成新访问的页面。</p><p><strong>无法实现原因</strong>：因为需要“预知未来”，需要知道进程接下来会访问到的页面才行。</p><p><strong>（2）先进先出置换算法——FIFO</strong></p><p><strong>思想</strong>：每次淘汰的是最早进入内存的页面</p><p><strong>实现方法</strong>：把调入内存的页面根据进入的顺序排成一个队列，每次淘汰队头就可以</p><p><strong>缺点</strong>：算法性能差，无法体现页面冷热信息（就是被使用的频繁度）</p><p><strong>（3）最近最久未使用置换算法——LRU</strong></p><p><strong>思想</strong>：每次淘汰的页面是最近这段时间内最久未使用的页面。也就是从开始需要置换的地方开始往回检查，最迟出现的页面就是“最近最久未使用置换算法“</p><p><strong>实现方法</strong>：</p><blockquote><p>方法1：使用一个栈，新页面或者被使用的页面，就移动到栈底，每次替换栈顶的缓存页面。</p><p>方法2：赋予每个页面对用的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面的时候，选择t最大的页面即可。</p></blockquote><p>前面的三种算法，OPT性能最好，但是无法实现。FIFO实现最简单，但是算法性能差。LRU算法性能好，但是实现起来不容易，开销比较大。所以，需要一个比较均衡的算法——clock</p><p><strong>（3）时钟置换算法——clock</strong></p><p><strong>思想</strong>：为每个在内存里的页面设置一个访问位，访问位有1和0两种情况，1代表最近访问过，0代表最近没访问过。再将内存中的页面都通过链接指针链接成一个循环队列。接下来就是操作：新加入的页面访问位都置为1。被访问的页面也置为1。当需要置换的时候，就开始循环扫描，如果页面访问位是0，说明少用，被置换。是1的话说明最近使用过，不被置换，但是访问位变0。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yilia主题使用方法</title>
      <link href="/2020/09/06/yilia%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/06/yilia%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<div align="center">这里，有yilia主题的配置方法及一些问题的解决方法，希望对你有帮助^_^</div><div align="center">我已经改为使用Volantis X主题啦</div><a id="more"></a><h3 id="置顶文章、文章阅读数统计、鼠标点击小红心的设置以及一些其他的功能添加，点这里"><a href="#置顶文章、文章阅读数统计、鼠标点击小红心的设置以及一些其他的功能添加，点这里" class="headerlink" title="置顶文章、文章阅读数统计、鼠标点击小红心的设置以及一些其他的功能添加，点这里"></a>置顶文章、文章阅读数统计、鼠标点击小红心的设置以及一些其他的功能添加，<a href="http://dongshuyan.com/2019/05/24/hexo%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" target="_blank" rel="noopener">点这里</a></h3><blockquote><p>注意：文章中下图这个地方有错，因为不蒜子域名有变</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200707013732926.png" alt="image-20200707013732926"></p><p>变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script  async  src&#x3D;&quot;https:&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="改背景，加头像旋转效果，点这里"><a href="#改背景，加头像旋转效果，点这里" class="headerlink" title="改背景，加头像旋转效果，点这里"></a>改背景，加头像旋转效果，<a href="https://qianlei6148.github.io/2018/09/30/hexo模版yilia左侧添加背景/" target="_blank" rel="noopener">点这里</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建与运营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础知识点(暂时完结)</title>
      <link href="/2020/09/06/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/09/06/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div align="center">————这里，有MySQL的一些基础知识点^_^————</div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>注：此博客内容基于《MySQL必知必会》一书，下载链接：<a href="https://pan.baidu.com/s/1phUYbp982A-aGwWTiGosKw" target="_blank" rel="noopener">https://pan.baidu.com/s/1phUYbp982A-aGwWTiGosKw</a> 提取码:4d7l</em></p><p>个人喜欢在学习一样新东西之前先了解它是什么、它有什么用、为什么要学它、大约怎么学。不然学起来云里雾里，心肌梗塞的感觉。<br>那么现在先回答一下上面的问题：</p><blockquote><p><strong>1.它是什么：</strong>MySQL其实是一个数据库管理系统，可以理解为一种数据库软件。 </p></blockquote><blockquote><p><strong>2.它有什么用：</strong>平时我们接触的很多东西都与数据库有关，比如你在学校的学籍信息系统通过你的学号查询你的信息，就是通过访问学校创建的数据库来查询的。而MySQL就相当于访问的工具。  </p></blockquote><blockquote><p><strong>3.为什么要学它：</strong>因为前面说的，我们日常生活中有许许多多的数据，我们要学会怎么去查看，获取等。  </p></blockquote><blockquote><p><strong>4.大约怎么学：</strong></p><blockquote><p>1.安装MySQL，微信搜索“<strong>软件安装管家</strong>”，软件目录里有多个MySQL版本的下载地址以及安装教程，最后那个Navicat Premium是一个将数据库可视化的软件。</p><p>2.建立《MySQL必知必会》用到的数据库，后面学习需要用，就像学习excel一样，需要有一个表格来处理。《MySQL必知必会》后面的附录B有介绍。也可参考博客：<a href="https://blog.csdn.net/x__Sherlock/article/details/104223646" target="_blank" rel="noopener">https://blog.csdn.net/x__Sherlock/article/details/104223646</a></p><p>3.学习MySQL知识以及处理命令</p></blockquote></blockquote><p><strong>window控制台一些命令</strong></p><p>启动mysql服务：<code>net start mysql</code></p><p>登录mysql：<code>mysql -u root -p</code></p><h1 id="第一章——了解SQL"><a href="#第一章——了解SQL" class="headerlink" title="第一章——了解SQL"></a>第一章——了解SQL</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL:"></a>SQL:</h2><blockquote><p>结构化查询语言（Structured Query Language），是一种专门用来与数据库通信的语言</p></blockquote><h2 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h2><blockquote><p>保存有组织的数据的容器</p></blockquote><h2 id="数据库组成"><a href="#数据库组成" class="headerlink" title="数据库组成"></a>数据库组成</h2><blockquote><ol><li><p><strong>表：</strong>某种特定类型数据的结构化清单</p><blockquote><p><strong>表名:</strong> 数据库中的每个表都有一个名字，用来标识自己  </p><p><strong>列和数据类型：</strong>列中存储表的部分信息，比如顾客地址，号码  </p><p><strong>行:</strong>例如，顾客表可以每行存储一个顾客。表中的行数为记录的总数  </p><p><strong>主键：</strong>占据一列，用于标识行  </p></blockquote></li></ol></blockquote><h1 id="第二章——MySQL简介"><a href="#第二章——MySQL简介" class="headerlink" title="第二章——MySQL简介"></a>第二章——MySQL简介</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote><p>含义：是一种DBMS（数据库管理系统），即它是一种数据库软件</p><p>数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS（数据库管理系统）完成的</p></blockquote><h1 id="第三章——使用MySQL"><a href="#第三章——使用MySQL" class="headerlink" title="第三章——使用MySQL"></a>第三章——使用MySQL</h1><p><em>注意：1.MySQL命令用;或\g结束，换句话说，仅按Enter不执行命令 2.输入quit或exit退出命令行实用程序。</em></p><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><h3 id="1-1创建新数据库"><a href="#1-1创建新数据库" class="headerlink" title="1.1创建新数据库"></a>1.1创建新数据库</h3><blockquote><p>如下，创建一个名为“test”的数据库<br><code>create database test;</code></p></blockquote><h3 id="1-2查看数据库"><a href="#1-2查看数据库" class="headerlink" title="1.2查看数据库"></a>1.2查看数据库</h3><blockquote><p><code>show databases;</code></p></blockquote><h3 id="1-3使用某个数据库"><a href="#1-3使用某个数据库" class="headerlink" title="1.3使用某个数据库"></a>1.3使用某个数据库</h3><blockquote><p><strong>格式</strong>：“use 数据库名字;”，比如下面是使用数据库“test”<br><code>use test;</code></p></blockquote><h3 id="1-4查看数据库的表"><a href="#1-4查看数据库的表" class="headerlink" title="1.4查看数据库的表"></a>1.4查看数据库的表</h3><blockquote><p><code>show tables;</code><br>查看数据库的表之前需要先“use”数据库，指明需要显示的数据库，如下<br><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/1.PNG" alt="1"></p></blockquote><h3 id="1-5查看表的列信息"><a href="#1-5查看表的列信息" class="headerlink" title="1.5查看表的列信息"></a>1.5查看表的列信息</h3><blockquote><p><code>show columns from customers;</code>或<code>describe customers;</code><br>返回的是每一列的信息，即字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息<br>显示结果如下</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/3.PNG" alt="3"></p><p>下图为customers表，自己比较一下</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/2.PNG" alt="2">  </p></blockquote><h1 id="第四章——检索数据"><a href="#第四章——检索数据" class="headerlink" title="第四章——检索数据"></a>第四章——检索数据</h1><h2 id="1-简单检索"><a href="#1-简单检索" class="headerlink" title="1.简单检索"></a>1.简单检索</h2><h3 id="1-1检索单列"><a href="#1-1检索单列" class="headerlink" title="1.1检索单列"></a>1.1检索单列</h3><blockquote><p><strong>例子</strong>：<code>select prod_name from products;</code><br><strong>解释</strong>：上述语句利用SELECT语句从 products表中检索一个名为prod_name的列。</p></blockquote><h3 id="1-2检索多个列"><a href="#1-2检索多个列" class="headerlink" title="1.2检索多个列"></a>1.2检索多个列</h3><blockquote><p><strong>例子</strong>：<code>select prod_id,prod_name,prod_price from products;</code><br><strong>解释</strong>：上述语句利用SELECT语句从products表中检索名为 prod_id,prod_name,prod_price 的三个列。</p></blockquote><h3 id="1-3检索所有列"><a href="#1-3检索所有列" class="headerlink" title="1.3检索所有列"></a>1.3检索所有列</h3><blockquote><p><strong>例子</strong>：<code>select * from products;</code><br><strong>解释</strong>：上述语句利用SELECT语句从products表中检索所有列。</p></blockquote><h3 id="1-4检索不同行"><a href="#1-4检索不同行" class="headerlink" title="1.4检索不同行"></a>1.4检索不同行</h3><blockquote><p><strong>例子</strong>：<code>select distinct vend_id from products;</code></p><p><strong>解释</strong>：上述语句利用SELECT语句从products表中检索vend_id列不同的行。输出看下图</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706133534777.png" alt="image-20200706133534777"></p><p>对比下图<code>select vend_id from products;</code>的输出结果</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706133958660.png" width="100px"></blockquote><h2 id="2-限制结果检索"><a href="#2-限制结果检索" class="headerlink" title="2.限制结果检索"></a>2.限制结果检索</h2><h3 id="2-1限制行数"><a href="#2-1限制行数" class="headerlink" title="2.1限制行数"></a>2.1限制行数</h3><blockquote><p><strong>例子</strong>：<code>select vend_id from products limit 5;</code></p><p><strong>解释</strong>：上述语句利用SELECT语句从products表中检索vend_id前五行。输出看下图</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706140153243.png" alt="image-20200706140153243"></p><p><strong>例子</strong>：<code>select vend_id from products limit 5,5;</code></p><p><strong>解释</strong>：上述语句利用SELECT语句从products表中检索vend_id 的6~10行（因为第一行为行0，不是行1，类似c语言的数组元素定义）。输出看下图</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706140433491.png" alt="image-20200706140433491"></p></blockquote><h3 id="2-2使用完全限定的表名"><a href="#2-2使用完全限定的表名" class="headerlink" title="2.2使用完全限定的表名"></a>2.2使用完全限定的表名</h3><blockquote><p><strong>例子</strong>：1.<code>select products.prod_name from products;</code></p><p>​            2.<code>select products.prod_name from test.products;</code>  (test是我存放这些表的)</p><p><strong>解释</strong>：1和2与<code>select prod_name from products;</code>功能一样至于有什么特殊用处，我还不知道。。。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png" width="100px"></blockquote><h1 id="第五章——排序检索数据"><a href="#第五章——排序检索数据" class="headerlink" title="第五章——排序检索数据"></a>第五章——排序检索数据</h1><h2 id="1-根据一个列排序"><a href="#1-根据一个列排序" class="headerlink" title="1.根据一个列排序"></a>1.根据一个列排序</h2><blockquote><p><strong>例子</strong>：<code>select prod_name from products order by prod_name;</code></p><p><strong>解释</strong>：上述语句将products表中prod_name列排序输出。（按照字母排序）</p></blockquote><h2 id="2-根据多个列排序"><a href="#2-根据多个列排序" class="headerlink" title="2.根据多个列排序"></a>2.根据多个列排序</h2><blockquote><p><strong>例子</strong>：<code>select prod_id,prod_price,prod_name from products order by prod_price,prod_name;</code></p><p><strong>解释</strong>：上述语句将products表中prod_id,prod_price,prod_name三列根据prod_price,prod_name排序输出。（先按照prod_price排序，prod_price相同的，按照prod_name排），输出如下图</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706161619491.png" width="300px"></blockquote><h2 id="3-指定排序方向"><a href="#3-指定排序方向" class="headerlink" title="3.指定排序方向"></a>3.指定排序方向</h2><blockquote><p>排序方向指升序还是降序，默认升序，需要降序的话需要用到desc关键字</p><p><strong>例子</strong>：<code>select prod_id,prod_price,prod_name from products order by prod_price desc,prod_name;</code></p><p><strong>解释</strong>：上述语句将products表中prod_id,prod_price,prod_name三列根据prod_price降序,prod_name升序，排序输出。</p></blockquote><h2 id="4-排序并限制输出数量"><a href="#4-排序并限制输出数量" class="headerlink" title="4.排序并限制输出数量"></a>4.排序并限制输出数量</h2><blockquote><p><strong>例子</strong>：<code>select prod_price from products order by prod_price desc limit 1;</code></p><p><strong>解释</strong>：上述语句将products表中prod_price列根据prod_price降序排序输出，并指输出一个。比如生活中需要找到最贵的选项。</p></blockquote><h1 id="第六章——过滤数据"><a href="#第六章——过滤数据" class="headerlink" title="第六章——过滤数据"></a>第六章——过滤数据</h1><p><em>本章将讲授如何使用 SELECT 语句的  WHERE 子句指定搜索条件</em></p><h2 id="1-相等检查"><a href="#1-相等检查" class="headerlink" title="1.相等检查"></a>1.相等检查</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price=<span class="number">2.50</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示prod_price=2.50的行。输出看下图</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200707131149667.png" alt="image-20200707131149667"></p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_name=<span class="string">'fuses'</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示prod_name=’fuses’的行(因为是字符串，需要用单引号)。</p></blockquote><h2 id="2-范围值检查"><a href="#2-范围值检查" class="headerlink" title="2.范围值检查"></a>2.范围值检查</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示5&lt;=prod_price&lt;=10的行。</p></blockquote><h2 id="3-空值检查"><a href="#3-空值检查" class="headerlink" title="3.空值检查"></a>3.空值检查</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示prod_price为空的行（注意：0不是空）。</p></blockquote><h2 id="4-其他的where子句操作符"><a href="#4-其他的where子句操作符" class="headerlink" title="4.其他的where子句操作符"></a>4.其他的where子句操作符</h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200707132256772.png" alt="image-20200707132256772" style="zoom: 67%;" /></blockquote><h2 id="5-一些注意点："><a href="#5-一些注意点：" class="headerlink" title="5.一些注意点："></a>5.一些注意点：</h2><blockquote><p>1.NULL值的行在匹配或不匹配具体数值是，不会返回。</p><p>2.where 与order by 一起用时，where需要放在order by 前面。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price=<span class="number">2.50</span> <span class="keyword">order</span> <span class="keyword">by</span> prod_name <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>输出如下</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200707134058952.png" alt="image-20200707134058952"></p></blockquote><h1 id="第七章——数据过滤"><a href="#第七章——数据过滤" class="headerlink" title="第七章——数据过滤"></a>第七章——数据过滤</h1><p>(这名字咋和第六章这么像呢)</p><p><em>本章讲授如何组合WHERE子句以建立功能更强的更高级的搜索条件。我们还将学习如何使用NOT和IN操作符。</em></p><h2 id="1-and操作符"><a href="#1-and操作符" class="headerlink" title="1.and操作符"></a>1.and操作符</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1003</span> <span class="keyword">and</span> prod_price&lt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示同时满足vend_id=1003 和 prod_price&lt;=10的行。</p></blockquote><h2 id="2-or操作符"><a href="#2-or操作符" class="headerlink" title="2.or操作符"></a>2.or操作符</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1003</span> <span class="keyword">or</span> vend_id=<span class="number">1002</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示满足vend_id=1003 或 vend_id=1002的行。</p></blockquote><h2 id="3-and与or优先级"><a href="#3-and与or优先级" class="headerlink" title="3.and与or优先级"></a>3.and与or优先级</h2><blockquote><p>and的优先级大于or，与加减乘除优先级类似，and相当于乘除，or加减</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span> <span class="keyword">and</span> prod_price&gt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：输出显示prod_name,prod_price两列，但只显示满足vend_id=1003 and prod_price&gt;=10 或 vend_id=1002的行。</p><p>可以通过加括号控制计算顺序，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> (vend_id=<span class="number">1002</span> <span class="keyword">or</span> vend_id=<span class="number">1003</span>) <span class="keyword">and</span> prod_price&gt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-in操作符"><a href="#4-in操作符" class="headerlink" title="4.in操作符"></a>4.in操作符</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">in</span> (<span class="number">1003</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name,prod_price两列，但只显示满足vend_id=1003 或 vend_id=1002的行。其实，他的功能和<code>select prod_name,prod_price from products where vend_id=1003 or vend_id=1002;</code>是一样的。</p><p><strong>相对于or的优点：</strong></p><blockquote><p>1.在使用长的合法选项清单时， in操作符的语法更清楚且更直观。<br>2.在使用in时，计算的次序更容易管理（因为使用的操作符更少）。<br>3.in操作符一般比OR操作符清单执行更快。<br>4.in的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。  </p></blockquote></blockquote><h2 id="5-not操作符"><a href="#5-not操作符" class="headerlink" title="5.not操作符"></a>5.not操作符</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1003</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示vend_id=1003 或 vend_id=1002 之外的行。</p></blockquote><h1 id="第八章——用通配符进行过滤"><a href="#第八章——用通配符进行过滤" class="headerlink" title="第八章——用通配符进行过滤"></a>第八章——用通配符进行过滤</h1><p><em>本章介绍什么是通配符、如何使用通配符以及怎样使用LIKE操作符进行通配搜索，以便对数据进行复杂过滤。</em></p><p><strong>通配符</strong>：用来匹配值的一部分的特殊字符  。</p><p><strong>搜索模式</strong>：由字面值、通配符或两者组合构成的搜索条件。  比如直接相等匹配和使用通配符匹配是两种搜索模式。</p><h2 id="1-like操作符（是一种谓词"><a href="#1-like操作符（是一种谓词" class="headerlink" title="1.like操作符（是一种谓词)"></a>1.like操作符（是一种谓词)</h2><blockquote><p>为在搜索子句中使用通配符，必须使用like操作符。like指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 （就是用来告诉MySQL搜索模式的）</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200707151702531.png" alt="image-20200707151702531" style="zoom:80%;" /> </blockquote><h2 id="2-百分号（-）通配符"><a href="#2-百分号（-）通配符" class="headerlink" title="2.百分号（%）通配符"></a>2.百分号（%）通配符</h2><blockquote><p>在搜索串中， %表示任何字符出现任意次数。  </p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name中以jet开头的行。</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name中包含jet的行。</p></blockquote><h2 id="3-下划线（-）通配符"><a href="#3-下划线（-）通配符" class="headerlink" title="3.下划线（_）通配符"></a>3.下划线（_）通配符</h2><blockquote><p>与下划线的用途与%一样，但下划线只匹配<strong>单个字符</strong>而不是多个字符 。</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'_ ton anvil'</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708153049199.png" alt="image-20200708153049199" style="zoom:80%;" /><p><strong>解释</strong>：”_“的地方只可以有一个字符。对比一下下面的例子</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name <span class="keyword">like</span> <span class="string">'% ton anvil'</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708153252854.png" alt="image-20200708153252854" style="zoom: 80%;" /></blockquote><h1 id="第九章——用正则表达式进行搜索"><a href="#第九章——用正则表达式进行搜索" class="headerlink" title="第九章——用正则表达式进行搜索"></a>第九章——用正则表达式进行搜索</h1><p><em>本章将学习如何在MySQL WHERE子句内使用正则表达式来更好地控制数据过滤。用到  regexp 操作符</em></p><h2 id="1-基本字符匹配"><a href="#1-基本字符匹配" class="headerlink" title="1.基本字符匹配"></a>1.基本字符匹配</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'1000'</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name中包含1000的行。</p></blockquote><h2 id="2-进行或匹配"><a href="#2-进行或匹配" class="headerlink" title="2.进行或匹配"></a>2.进行或匹配</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'1000|2000'</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：显示prod_name中包含1000或2000的行。</p></blockquote><h2 id="3-匹配几个字符之一"><a href="#3-匹配几个字符之一" class="headerlink" title="3.匹配几个字符之一"></a>3.匹配几个字符之一</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'[123] ton'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708160503106.png" alt="image-20200708160503106"></p><p><strong>解释</strong>：显示prod_name中包含”1 ton”、”2 ton”  或者”3 ton“的行。</p></blockquote><h2 id="4-匹配范围"><a href="#4-匹配范围" class="headerlink" title="4.匹配范围"></a>4.匹配范围</h2><blockquote><p>上面的<code>select prod_name from products where prod_name regexp &#39;[123] ton&#39;;</code>还可以换成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'[1-3] ton'</span>;</span><br></pre></td></tr></table></figure><p>还有字母也可以，比如[a-z]</p></blockquote><h2 id="5-匹配特殊字符"><a href="#5-匹配特殊字符" class="headerlink" title="5.匹配特殊字符"></a>5.匹配特殊字符</h2><blockquote><p>比如<code>.</code> ， <code>|</code>  ， <code>[]</code>  ，这些有特殊含义的字符，需要用<code>\\</code>来进行转义</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'\\.'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708161841862.png" alt="image-20200708161841862"></p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708161928028.png" alt="image-20200708161928028" style="zoom:80%;" /><p><strong>解释</strong>：因为<code>.</code>在regexp操作中，代表任意字符，如果不在前面，MySQL就以为你想搜索任意字符</p></blockquote><h2 id="6-匹配字符类"><a href="#6-匹配字符类" class="headerlink" title="6.匹配字符类"></a>6.匹配字符类</h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708163653726.png" alt="image-20200708163653726" style="zoom:67%;" /><p><strong>例子：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_name <span class="keyword">from</span> products <span class="keyword">where</span> prod_name regexp <span class="string">'[:upper:]'</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708163958227.png" alt="image-20200708163958227" style="zoom:80%;" /><p><strong>解释</strong>:显示prod_name中包含大写字母的行。</p></blockquote><h2 id="7-匹配多次出现"><a href="#7-匹配多次出现" class="headerlink" title="7.匹配多次出现"></a>7.匹配多次出现</h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708171249820.png" alt="image-20200708171249820" style="zoom:80%;" /><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &#39;\\([0-9] sticks?\\)&#39;;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708171613118.png" alt="image-20200708171613118" style="zoom:80%;" /><p><strong>解释</strong>：<code>\\(</code>  匹配  <code>(</code> ，<code>[0-9]</code>匹配任意数字（这个例子中为1和5），<code>sticks?</code>匹配<code>stick</code>和<code>sticks</code>（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），<code>\\)</code>匹配<code>)</code>。  </p><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &#39;[[:digit:]]&#123;4&#125;&#39;;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708172834824.png" alt="image-20200708172834824" style="zoom:80%;" /><p><strong>解释</strong>：<code>[[:digit:]]{4}</code>匹配连在一起的任意4位数字。</p></blockquote><h2 id="8-定位符"><a href="#8-定位符" class="headerlink" title="8.定位符"></a>8.定位符</h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708173605982.png" alt="image-20200708173605982" style="zoom:80%;" /><p>*注意：^的双重用途 ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。  *</p><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &#39;^[0-9\\.]&#39;;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708174236468.png" alt="image-20200708174236468" style="zoom:80%;" /><p><strong>解释</strong>：<code>^[0-9\\.]</code>匹配0到9，或者<code>.</code>为开头的prod_name,<code>^[0-9\\.]</code>也可写成<code>^[123456789\\.]</code></p><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &#39;[[:&lt;:]]t&#39;;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708174614522.png" alt="image-20200708174614522" style="zoom:80%;" /><p><strong>解释</strong>：<code>[[:&lt;:]]t</code>匹配t开头的词。</p></blockquote><h1 id="第十章——创建计算字段"><a href="#第十章——创建计算字段" class="headerlink" title="第十章——创建计算字段"></a>第十章——创建计算字段</h1><p>*本章介绍什么是计算字段，如何创建计算字段以及怎样从应用程序中使用别名引用它们。  *</p><h2 id="1-拼接字段"><a href="#1-拼接字段" class="headerlink" title="1.拼接字段"></a>1.拼接字段</h2><blockquote><p>使用<strong>concat</strong>函数</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span> (vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>) <span class="keyword">from</span> vendors;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708182831071.png" alt="image-20200708182831071" style="zoom:80%;" /><p><strong>解释</strong>：Concat()需要一个或多个指定的串，各个串之间用逗号分隔。上面的语句连接了4个元素。</p></blockquote><h2 id="2-使用别名"><a href="#2-使用别名" class="headerlink" title="2.使用别名"></a>2.使用别名</h2><blockquote><p>使用<strong>as</strong>关键字</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span> (vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>) <span class="keyword">as</span> vend_title <span class="keyword">from</span> vendors;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708183646269.png" alt="image-20200708183646269" style="zoom:80%;" /><p><strong>解释</strong>：这不用解释了吧？</p></blockquote><h2 id="3-执行算数计算"><a href="#3-执行算数计算" class="headerlink" title="3.执行算数计算"></a>3.执行算数计算</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> prod_id,quantity,item_price,quantity*item_price <span class="keyword">as</span> expanded_price <span class="keyword">from</span> orderitems <span class="keyword">where</span> order_num=<span class="number">20005</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200708190316956.png" alt="image-20200708190316956" style="zoom:80%;" /><p><strong>解释</strong>：这也不用解释了吧？加减乘除就是<code>##-*/</code>，也可以加括号。</p></blockquote><h1 id="第十一章——使用数据处理函数"><a href="#第十一章——使用数据处理函数" class="headerlink" title="第十一章——使用数据处理函数"></a>第十一章——使用数据处理函数</h1><p><em>本章介绍什么是函数， MySQL支持何种函数，以及如何使用这些函数。</em></p><h2 id="1-文本处理函数"><a href="#1-文本处理函数" class="headerlink" title="1.文本处理函数"></a>1.文本处理函数</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,<span class="keyword">upper</span>(vend_name) <span class="keyword">as</span> vend_name_upcase <span class="keyword">from</span> vendors;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709214317541.png" alt="image-20200709214317541" style="zoom: 80%;" /><p><strong>解释</strong>：upper()函数将文本装换为大写。</p><p>下面列举了一些常用函数</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709214548544.png" alt="image-20200709214548544" style="zoom:67%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709214615810.png" alt="image-20200709214615810" style="zoom:67%;" /><p>上面列举的函数中，有个特别有趣的函数：soundex（）函数。</p><p>soundex是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 作用是根据发音来查找数据。</p><p> <strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name,cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">soundex</span>(cust_contact)=<span class="keyword">soundex</span>(<span class="string">'Y Lie'</span>);</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709220135560.png" alt="image-20200709220135560" style="zoom:80%;" /><p>因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配 。这个的作用是能够对录入数据时的错误进行补救。</p></blockquote><h2 id="2-日期和时间处理函数"><a href="#2-日期和时间处理函数" class="headerlink" title="2.日期和时间处理函数"></a>2.日期和时间处理函数</h2><blockquote><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709221414550.png" alt="image-20200709221414550" style="zoom:67%;" /><p>上图列出了一些常用的日期和时间处理函数，使用这些函数，有一些注意点，如下：<br>1.日期必须为格式yyyy-mm-dd  ，因为它排除了多义性（如，04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或……）。</p><p>2.对于日期比较，习惯使用date()函数。  例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id,order_num <span class="keyword">from</span> orders <span class="keyword">where</span> <span class="built_in">date</span>(order_date)=<span class="string">'2005-09-01'</span>;</span><br></pre></td></tr></table></figure><p>比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id,order_num <span class="keyword">from</span> orders <span class="keyword">where</span> order_date=<span class="string">'2005-09-01'</span>;</span><br></pre></td></tr></table></figure><p>要好。因为order_date的数据类型为datetime。这种类型存储日期及时间值。  比 如 ， 存 储 的 order_date 值 为<br>2005-09-01 11:30:05，则WHERE order_date = ‘2005-09-01’失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。  </p><p>同理，也应该在适当的时候使用time（）函数（筛选时间的）。</p></blockquote><h2 id="3-数值处理函数"><a href="#3-数值处理函数" class="headerlink" title="3.数值处理函数"></a>3.数值处理函数</h2><blockquote><p>数值处理函数，就是我们平时学习其他语言都会有的一类函数。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709225533282.png" alt="image-20200709225533282" style="zoom:67%;" /></blockquote><h1 id="第十二章——汇总数据"><a href="#第十二章——汇总数据" class="headerlink" title="第十二章——汇总数据"></a>第十二章——汇总数据</h1><p>*本章介绍什么是SQL的聚集函数以及如何利用它们汇总表的数据  *</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709231425249.png" alt="image-20200709231425249" style="zoom:80%;" /><p>上图是一些基本的汇总数据的函数</p><p><strong>用法例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(prod_price) <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710142324387.png" alt="image-20200710142324387" style="zoom:80%;" /><p>其他函数用法类似，不过需要注意count（）函数用法。</p><h2 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h2><blockquote><p>1.使用COUNT(*)对表中行的数目进行计数， 不管表列中包含的是空值（NULL）还是非空值。<br>2.使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。  </p><p> <strong>例子(1)</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> customers;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710143135044.png" alt="image-20200710143135044" style="zoom: 80%;" /><p> <strong>例子(2)</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(cust_email) <span class="keyword">from</span> customers;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710143157026.png" alt="image-20200710143157026" style="zoom:80%;" /><p>因为cust_email只有三个数据，另外两个是空的，所以显示3</p></blockquote><h2 id="distinct参数"><a href="#distinct参数" class="headerlink" title="distinct参数"></a>distinct参数</h2><blockquote><p><strong>作用</strong>：只对不同的值进行处理</p><p> <strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(<span class="keyword">distinct</span> prod_price) <span class="keyword">from</span> products;</span><br></pre></td></tr></table></figure><p>只对prod_price中的不同值进行取平均值操作。</p></blockquote><h1 id="第十三章——分组数据"><a href="#第十三章——分组数据" class="headerlink" title="第十三章——分组数据"></a>第十三章——分组数据</h1><p><em>本章将介绍如何分组数据，以便能汇总表内容的子集。这涉及两个新SELECT语句子句，分别是GROUP BY子句和HAVING子句</em></p><h2 id="1-创建分组"><a href="#1-创建分组" class="headerlink" title="1.创建分组"></a>1.创建分组</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id,<span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710151928575.png" alt="image-20200710151928575" style="zoom: 80%;" /><p><strong>解释</strong>：group by子句把vend_id按照数值进行了分组</p><p><strong>group by使用注意点</strong>：</p><blockquote><p>1.**group by子句必须出现在where子句之后，order by子句之前。  </p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id,<span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">where</span> vend_id&lt;=<span class="number">1003</span> <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">order</span> <span class="keyword">by</span> vend_id <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="2-过滤分组"><a href="#2-过滤分组" class="headerlink" title="2.过滤分组"></a>2.过滤分组</h2><blockquote><p>使用<strong>having</strong>子句</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id,<span class="keyword">count</span>(*) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710163213402.png" alt="image-20200710163213402" style="zoom: 80%;" /><p><strong>解释</strong>：可以比较上面的例子，<code>having count(*)</code>把大于3的过滤出来，只显示大于3的</p></blockquote><h2 id="3-分组和排序"><a href="#3-分组和排序" class="headerlink" title="3.分组和排序"></a>3.分组和排序</h2><blockquote><p>group by和order by组合使用</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_num,<span class="keyword">sum</span>(quantity*item_price) <span class="keyword">as</span> ordertotal <span class="keyword">from</span> orderitems <span class="keyword">group</span> <span class="keyword">by</span> order_num <span class="keyword">having</span> <span class="keyword">sum</span>(quantity*item_price)&gt;=<span class="number">50</span> <span class="keyword">order</span> <span class="keyword">by</span> ordertotal;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710220755519.png" alt="image-20200710220755519" style="zoom:80%;" /></blockquote><h1 id="第十四章——使用子查询"><a href="#第十四章——使用子查询" class="headerlink" title="第十四章——使用子查询"></a>第十四章——使用子查询</h1><h2 id="1-利用子查询进行过滤"><a href="#1-利用子查询进行过滤" class="headerlink" title="1.利用子查询进行过滤"></a>1.利用子查询进行过滤</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name,cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="keyword">in</span> (<span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id=<span class="string">'TNT2'</span>));</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710223330857.png" alt="image-20200710223330857" style="zoom:80%;" /><p><strong>解释</strong>：<strong>(1)</strong> 检索包含物品TNT2的所有订单的编号。<strong>(2)</strong> 检索具有前一步骤列出的订单编号的所有客户的ID。<strong>(3)</strong> 检索前一步骤返回的所有客户ID的客户信息。  </p><p>这个例子，运用十五章学习的联结知识也可以解决，命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name,cust_contact <span class="keyword">from</span> customers,orderitems,orders <span class="keyword">where</span> customers.cust_id=orders.cust_id <span class="keyword">and</span> orderitems.order_num=orders.order_num <span class="keyword">and</span> prod_id=<span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-子查询作为计算字段"><a href="#2-子查询作为计算字段" class="headerlink" title="2.子查询作为计算字段"></a>2.子查询作为计算字段</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name,cust_state,(<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> orders <span class="keyword">where</span> orders.cust_id=customers.cust_id) <span class="keyword">as</span> orders <span class="keyword">from</span> customers <span class="keyword">order</span> <span class="keyword">by</span> cust_name;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200710231213346.png" alt="image-20200710231213346" style="zoom: 80%;" /><p><strong>解释</strong>：<code>select count(*) from orders where orders.cust_id=customers.cust_id</code>  的<strong>作用</strong>是：对于检索出的每个客户，统计其在orders表中的订单数目 。</p></blockquote><h1 id="第十五章——联结表"><a href="#第十五章——联结表" class="headerlink" title="第十五章——联结表"></a>第十五章——联结表</h1><p><em>本章将介绍什么是联结，为什么要使用联结，如何编写使用联结的SELECT语句。</em></p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><h3 id="1-1关系表"><a href="#1-1关系表" class="headerlink" title="1.1关系表"></a>1.1关系表</h3><blockquote><p>简单来说，就是两个表之间有一列数值是对应的，两个表的行之间是对应的。</p></blockquote><h3 id="1-2联结"><a href="#1-2联结" class="headerlink" title="1.2联结"></a>1.2联结</h3><blockquote><p>简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返<br>回一组输出，联结在运行时关联表中正确的行。  </p></blockquote><h2 id="2-创建联结"><a href="#2-创建联结" class="headerlink" title="2.创建联结"></a>2.创建联结</h2><h3 id="2-1联结两个表"><a href="#2-1联结两个表" class="headerlink" title="2.1联结两个表"></a>2.1联结两个表</h3><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,prod_name,prod_price <span class="keyword">from</span> vendors,products <span class="keyword">where</span> vendors.vend_id=products.vend_id <span class="keyword">order</span> <span class="keyword">by</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200711212343072.png" alt="image-20200711212343072" style="zoom: 80%;" /><p>vend_name是表vendors的数据， prod_name,prod_price是表products的数据。上面的语句把两个表的数据联结起来了</p><p>上面的例子也可以换个语法，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,prod_name,prod_price <span class="keyword">from</span> vendors <span class="keyword">inner</span> <span class="keyword">join</span> products <span class="keyword">on</span> vendors.vend_id=products.vend_id <span class="keyword">order</span> <span class="keyword">by</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure><p>使用的是inner join语法</p></blockquote><h3 id="2-2联结多个表"><a href="#2-2联结多个表" class="headerlink" title="2.2联结多个表"></a>2.2联结多个表</h3><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,prod_name,prod_price,quantity <span class="keyword">from</span> vendors,products,orderitems <span class="keyword">where</span> vendors.vend_id=products.vend_id <span class="keyword">and</span> orderitems.prod_id=products.prod_id <span class="keyword">and</span> order_num=<span class="number">20005</span>;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第十六章——创建高级联结"><a href="#第十六章——创建高级联结" class="headerlink" title="第十六章——创建高级联结"></a>第十六章——创建高级联结</h1><p><em>本章将讲解另外一些联结类型（包括它们的含义和使用方法），介绍如何对被联结的表使用表别名和聚集函数。</em></p><h2 id="1-使用表别名"><a href="#1-使用表别名" class="headerlink" title="1.使用表别名"></a>1.使用表别名</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name,prod_name,prod_price,quantity <span class="keyword">from</span> vendors <span class="keyword">as</span> v,products <span class="keyword">as</span> p,orderitems <span class="keyword">as</span> o <span class="keyword">where</span> v.vend_id=p.vend_id <span class="keyword">and</span> o.prod_id=p.prod_id <span class="keyword">and</span> order_num=<span class="number">20005</span>;</span><br></pre></td></tr></table></figure><p>给vendors ,products ,orderitems 三个表起了别名，目的是缩短SQL语句，方便多次使用表</p><p><strong>应该注意</strong>：表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。  </p></blockquote><h2 id="2-使用不同类型的联结"><a href="#2-使用不同类型的联结" class="headerlink" title="2.使用不同类型的联结"></a>2.使用不同类型的联结</h2><h3 id="2-1自联结"><a href="#2-1自联结" class="headerlink" title="2.1自联结"></a>2.1自联结</h3><blockquote><p>问题：假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.prod_id,p1.prod_name <span class="keyword">from</span> products <span class="keyword">as</span> p1,products <span class="keyword">as</span> p2 <span class="keyword">where</span> p1.vend_id=p2.vend_id <span class="keyword">and</span> p2.prod_id=<span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure><p>使用了自联结的方法，其实也可以使用子查询的方法。但有时候处理联结远比处理子查询快得多。  </p></blockquote><h3 id="2-2自然联结"><a href="#2-2自然联结" class="headerlink" title="2.2自然联结"></a>2.2自然联结</h3><h3 id="2-3外部联结"><a href="#2-3外部联结" class="headerlink" title="2.3外部联结"></a>2.3外部联结</h3><blockquote><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</p><p><strong>比如</strong>：对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户；  </p><p>先来看一下两个表</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200711230412881.png" alt="image-20200711230412881" style="zoom:80%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200711230615742.png" alt="image-20200711230615742" style="zoom:80%;" /><p>表1是orders表，表2是customers表。根据问题，要讲customers表所有的cust_id全部列出来，哪怕他在orders表没数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id,orders.order_num <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200711231050332.png" alt="image-20200711231050332" style="zoom:80%;" /><p>输出显示，就算cust_id=10002在orders表里没有数据，一样会输出，只是显示NULL。这主要是<code>left outer join</code>的作用，left指定了将<code>left outer join</code>左边的表的左右行输出，即customers。如果left替换成right，则指orders表。</p></blockquote><h2 id="3-使用带聚集函数的联结"><a href="#3-使用带聚集函数的联结" class="headerlink" title="3.使用带聚集函数的联结"></a>3.使用带聚集函数的联结</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_name,customers.cust_id,<span class="keyword">count</span>(orders.order_num) <span class="keyword">as</span> num_ord <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id <span class="keyword">group</span> <span class="keyword">by</span> customers.cust_id;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200712001103091.png" alt="image-20200712001103091" style="zoom:80%;" /></blockquote><h1 id="第十七章——组合查询"><a href="#第十七章——组合查询" class="headerlink" title="第十七章——组合查询"></a>第十七章——组合查询</h1><p><em>本章讲述如何利用UNION操作符将多条SELECT语句组合成一个结果集。</em>  </p><blockquote><p>使用<strong>union</strong></p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id,prod_id,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> prod_price <span class="keyword">union</span> <span class="keyword">select</span> vend_id,prod_id,prod_price <span class="keyword">from</span> products <span class="keyword">where</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p>UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。  </p><p><strong>union一些特性：</strong></p><blockquote><p>1.每个查询必须包含相同的列、表达式或聚集函数（不过分析各个列不需要以相同的次序列出）。  </p><p>2.UNION从查询结果集中自动去除了重复的行。若想保留重复行，可用UNION ALL  。</p><p>3.在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。  </p></blockquote></blockquote><h1 id="第十八章——全文本搜索"><a href="#第十八章——全文本搜索" class="headerlink" title="第十八章——全文本搜索"></a>第十八章——全文本搜索</h1><p><em>本章将学习如何使用MySQL的全文本搜索功能进行高级的数据查询和选择</em>  </p><h2 id="1-全文本搜索是什么？"><a href="#1-全文本搜索是什么？" class="headerlink" title="1.全文本搜索是什么？"></a>1.全文本搜索是什么？</h2><blockquote><p>是可以进行精确、多功能，高性能的文本搜索方式</p></blockquote><h2 id="2-使用方法-步骤-："><a href="#2-使用方法-步骤-：" class="headerlink" title="2.使用方法(步骤)："></a>2.使用方法(步骤)：</h2><blockquote><p><strong>（1）.创建表的时候要使用fulltext命令来对指定索引的列。</strong></p><p><strong>例子</strong>：（这个表在导入的时候已经存在了，这里只是演示怎么创建的，create table命令后面怎么用后面章节会讲，先理解fulltext作用）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> productnotes</span><br><span class="line">(</span><br><span class="line">    note_id  <span class="built_in">int</span>  <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    prod_id  <span class="built_in">char</span>(<span class="number">10</span>)  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    note_date  datetime  <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    note_text  <span class="built_in">text</span>  <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(note_id),</span><br><span class="line">    fulltext(note_text)</span><br><span class="line">)<span class="keyword">engine</span>=myisam;</span><br></pre></td></tr></table></figure><p>这个例子fulltext(note_text)指定了全文本搜索时对note_text列进行搜索。</p><p><strong>（2）.进行全文本搜索</strong>  </p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text <span class="keyword">from</span> productnotes <span class="keyword">where</span> <span class="keyword">match</span>(note_text) against(<span class="string">'rabbit'</span>);</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200714130019348.png" alt="image-20200714130019348" style="zoom:80%;" /><p>productnotes表中的note_text列有两行含有rabbit，因此被检索出来了。其中，Match(note_text)指示MySQL针对指定的<br>列进行搜索， Against(‘rabbit’)指定词rabbit作为搜索文本。  </p></blockquote><h2 id="3-全文本搜索优点"><a href="#3-全文本搜索优点" class="headerlink" title="3.全文本搜索优点"></a>3.全文本搜索优点</h2><blockquote><p><strong>（1）</strong>相对于like+通配符,正则表达式这些来说，性能高</p><p><strong>（2）</strong>全文本搜索会根据被搜索文本出现的先后，次数等进行排序</p></blockquote><h2 id="4-使用查询扩展"><a href="#4-使用查询扩展" class="headerlink" title="4.使用查询扩展"></a>4.使用查询扩展</h2><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text <span class="keyword">from</span> productnotes <span class="keyword">where</span> <span class="keyword">match</span>(note_text) against(<span class="string">'anvils'</span> <span class="keyword">with</span> <span class="keyword">query</span> expansion);</span><br></pre></td></tr></table></figure><p><code>with query expansion</code>使得搜索结果不仅输出anvils所在行，还会输出带有<code>anvils所在行</code>其他单词的行，就是<code>anvils所在行</code>的其他单词，要是在其他行出现，会被认为相关，然后一起输出</p></blockquote><h2 id="5-布尔文本搜索"><a href="#5-布尔文本搜索" class="headerlink" title="5.布尔文本搜索"></a>5.布尔文本搜索</h2><blockquote><p>即使没有FULLTEXT索引也可以使用布尔文本搜索   </p><p>以布尔方式，可以提供关于如下内容的细节：</p><blockquote><p> 要匹配的词；<br> 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；<br> 排列提示（指定某些词比其他词更重要，更重要的词等级更高）；<br> 表达式分组；<br> 另外一些内容  </p></blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> note_text <span class="keyword">from</span> productnotes <span class="keyword">where</span> <span class="keyword">match</span>(note_text) against (<span class="string">'heavy -ropes*'</span> <span class="keyword">in</span> <span class="built_in">boolean</span> <span class="keyword">mode</span>);</span><br></pre></td></tr></table></figure><p>添加<code>in boolean mode</code>代表进行布尔文本搜索，<code>-rope*</code>代表排除包含rope*（任何以rope开始的词，包括ropes）的行  。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200714140336335.png" alt="image-20200714140336335" style="zoom: 67%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200714140525598.png" alt="image-20200714140525598" style="zoom:80%;" /></blockquote><h2 id="6-全文本搜索的使用说明"><a href="#6-全文本搜索的使用说明" class="headerlink" title="6.全文本搜索的使用说明"></a>6.全文本搜索的使用说明</h2><blockquote><p><strong>(1)</strong>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。<br><strong>(2)</strong> MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。<br><strong>(3)</strong>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此， MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。 50%规则不用于IN BOOLEAN MODE。<br><strong>(4)</strong>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。<br><strong>(5)</strong> 忽略词中的单引号。例如， don’t索引为dont。<br><strong>(6)</strong>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。<br><strong>(7)</strong>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。  </p></blockquote><h1 id="第十九章——插-入-数-据"><a href="#第十九章——插-入-数-据" class="headerlink" title="第十九章——插 入 数 据"></a>第十九章——插 入 数 据</h1><p><em>本章介绍如何利用SQL的INSERT语句将数据插入表中。</em>  </p><h2 id="1-插入行"><a href="#1-插入行" class="headerlink" title="1.插入行"></a>1.插入行</h2><blockquote><p>使用<code>insert into</code></p><p><strong>例子</strong>：给表customers添加了两行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">'tian'</span>,<span class="string">'dong shan street'</span>,<span class="string">'huazhou'</span>,<span class="string">'MI'</span>,<span class="string">'66666'</span>,<span class="string">'CH'</span>),</span><br><span class="line">      (<span class="string">'bin'</span>,<span class="string">'dong shan street'</span>,<span class="string">'huazhou'</span>,<span class="string">'MI'</span>,<span class="string">'66066'</span>,<span class="string">'CH'</span>);</span><br></pre></td></tr></table></figure><p><code>insert into</code>后面跟着表名，需要添加数据的列用括号括着。<code>values</code>指出需要添加的数据，需要按照前面的列名顺序添加。</p></blockquote><h2 id="2-插入检索出的数据"><a href="#2-插入检索出的数据" class="headerlink" title="2.插入检索出的数据"></a>2.插入检索出的数据</h2><blockquote><p><strong>例子</strong>：将表custnew的行插入到表customers中</p><p>假设A,B,C,D,E,F,G 是表custnew的列名。这个例子是把A列插入到cust_name，B列插入到cust_address，以此类推</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line"><span class="keyword">select</span> A,B,C,D,E,F,G <span class="keyword">from</span> custnew;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十章——更新和删除数据"><a href="#第二十章——更新和删除数据" class="headerlink" title="第二十章——更新和删除数据"></a>第二十章——更新和删除数据</h1><p><em>本章介绍如何利用UPDATE和DELETE语句进一步操纵表数据。</em>  </p><h2 id="1-更新数据"><a href="#1-更新数据" class="headerlink" title="1.更新数据"></a>1.更新数据</h2><blockquote><p>使用update语句</p><p><strong>例子1</strong>：给表customers里的一位客户添加邮箱地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_email=<span class="string">'elmer@fudd.com'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p><strong>例子1</strong>：更新表customers里的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> customers <span class="keyword">set</span> cust_name=<span class="string">'The Fudds'</span>,cust_email=<span class="string">'elmer@fudd.com'</span> <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p>记得不要漏了where语句，不然就会把全部行的数据都更新了。如果想删除某个列数值，可设置它为NULL  。</p><p><strong>ignore关键字</strong>： 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：UPDATE IGNORE customers…  </p></blockquote><h2 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2.删除数据"></a>2.删除数据</h2><blockquote><p><strong>（1）删除整个行</strong>，使用delete语句</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id=<span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p>（2）删除所有行，使用truncate table语句</p><p><strong>例子1</strong>：更新表customers里的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> customers;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3.注意点"></a>3.注意点</h2><blockquote><p>（1）小心使用 MySQL没有撤销（ undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。  </p><p>（2）在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确  。</p></blockquote><h1 id="第二十一章——创建和操纵表"><a href="#第二十一章——创建和操纵表" class="headerlink" title="第二十一章——创建和操纵表"></a>第二十一章——创建和操纵表</h1><p><em>本章讲授表的创建、更改和删除的基本知识。</em>  </p><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h2><blockquote><p>使用create table</p><blockquote><p><strong>(1)</strong>表的<strong>主键</strong>可以在创建表时用<strong>PRIMARY KEY</strong>关键字指定。主键是用来标识表中每个行的列。  </p><p><strong>(2)</strong>每个表列或者是NULL列，或者是NOT NULL列，需要规定好。NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。NULL代表该列可以是空的，NOT NULL代表该列一定要有值。</p><p><strong>(3)</strong> <strong>AUTO_INCREMENT</strong> :添加了AUTO_INCREMENT的列每当增加一行时自动增量  。</p><p><strong>(4)</strong> 指定默认值  :使用<strong>DEFAULT</strong> ，与AUTO_INCREMENT添加位置一样，比如添加default 1,那么这一列在没给出数值的时候就是默认值1。</p><p><strong>(5)</strong> <strong>引擎类型</strong> :可以看到下面例子的最后有个语句：ENGINE=InnoDB  ，这语句是用来配置引擎的，InnoDB是一个可靠的事务处理引擎  。除此之外还有MEMORY、MyISAM  </p></blockquote><p><strong>例子</strong>：表customers的创建</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200716164435258.png" alt="image-20200716164435258" style="zoom: 67%;" /></blockquote><h2 id="2-操纵表"><a href="#2-操纵表" class="headerlink" title="2.操纵表"></a>2.操纵表</h2><h3 id="2-1-更新表"><a href="#2-1-更新表" class="headerlink" title="2.1 更新表"></a>2.1 更新表</h3><blockquote><p>使用ALTER TABLE语句  </p><p><strong>例子1</strong>：给表添加一个列  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors <span class="keyword">add</span> vend_phone <span class="built_in">char</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><strong>例子2</strong>：给表删除一个列  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> vendors <span class="keyword">drop</span> <span class="keyword">column</span> vend_phone;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-2-删除表"><a href="#2-2-删除表" class="headerlink" title="2.2 删除表"></a>2.2 删除表</h3><blockquote><p>删除表（删除整个表而不是其内容） ,使用DROP TABLE语句，  与上一章的delete不一样，</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> vendors2;</span><br></pre></td></tr></table></figure><p>请谨慎使用！</p></blockquote><h3 id="2-3-重命名表"><a href="#2-3-重命名表" class="headerlink" title="2.3 重命名表"></a>2.3 重命名表</h3><blockquote><p>使用RENAME TABLE语句可以重命名一个表</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> vendors <span class="keyword">to</span> vendor,vendor <span class="keyword">to</span> vendors;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十二章——使-用-视-图"><a href="#第二十二章——使-用-视-图" class="headerlink" title="第二十二章——使 用 视 图"></a>第二十二章——使 用 视 图</h1><p><em>本章将介绍视图究竟是什么，它们怎样工作，何时使用它们。我们还将看到如何利用视图简化前面章节中执行的某些SQL操作。</em>  </p><h2 id="1-什么是视图"><a href="#1-什么是视图" class="headerlink" title="1. 什么是视图"></a>1. 什么是视图</h2><blockquote><p>简单来说，就是可以通过视图，呈现多个表数据的组合，在对视图进行检索、查看的时候，其实是通过一定的方式查看视图引用的表的数据，视图并没有像表这样实际数据。我们前面有学习了联结，联结的语句一般会比较复杂，利用视图就可以简化复杂语句的使用了。</p><p>再简而言之，视图就是对筛选的数据进行封装，但是它并没有真正的复制表的数据，只是引用。</p></blockquote><h2 id="2-使用视图注意点"><a href="#2-使用视图注意点" class="headerlink" title="2.使用视图注意点"></a>2.使用视图注意点</h2><blockquote><p><strong>（1）</strong>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。<br><strong>（2）</strong>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。<br><strong>（3）</strong>视图不能索引，也不能有关联的触发器或默认值。<br><strong>（4）</strong>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。  </p></blockquote><h2 id="3-使用视图"><a href="#3-使用视图" class="headerlink" title="3.使用视图"></a>3.使用视图</h2><p><strong>创建视图</strong>：CREATE VIEW语句<br><strong>查看创建某视图的语句</strong>： 使用SHOW CREATE VIEW viewname（viewname是实际视图名字）<br><strong>删除视图：</strong>其语法为DROP VIEW viewname。<br><strong>更新视图时</strong>：可以先用DROP再用CREATE，也可以直接用CREATE ORREPLACE VIEW。</p><h3 id="3-1-利用视图简化复杂的联结"><a href="#3-1-利用视图简化复杂的联结" class="headerlink" title="3.1 利用视图简化复杂的联结"></a>3.1 利用视图简化复杂的联结</h3><blockquote><p><strong>例子</strong>：创建一个视图，呈现内容与<code>select customers.cust_id,orders.order_num from customers left outer join orders on customers.cust_id=orders.cust_id;</code>一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> customers_num <span class="keyword">as</span> <span class="keyword">select</span> customers.cust_id,orders.order_num <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> orders <span class="keyword">on</span> customers.cust_id=orders.cust_id;</span><br></pre></td></tr></table></figure><p>创建之后，可通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> customers_num;</span><br></pre></td></tr></table></figure><p>查看与上述联结语句一样的内容</p></blockquote><h3 id="3-2用视图过滤不想要的数据"><a href="#3-2用视图过滤不想要的数据" class="headerlink" title="3.2用视图过滤不想要的数据"></a>3.2用视图过滤不想要的数据</h3><blockquote><p>其实与利用视图简化联结一样用法</p><p><strong>例子</strong>：过滤没有邮箱的客户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> customers_not_email <span class="keyword">as</span> <span class="keyword">select</span> cust_id,cust_name,cust_email <span class="keyword">from</span> customers <span class="keyword">where</span> cust_email <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></blockquote><p>其他的视图创建都差不多，后面跟着select语句。</p><h1 id="第二十三章——使用存储过程"><a href="#第二十三章——使用存储过程" class="headerlink" title="第二十三章——使用存储过程"></a>第二十三章——使用存储过程</h1><p><em>本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法</em>。  </p><h2 id="1-什么是存储过程"><a href="#1-什么是存储过程" class="headerlink" title="1.什么是存储过程"></a>1.什么是存储过程</h2><blockquote><p>简单来说，存储过程的各语言里的子函数很像，把一些语句封装成块，使用的时候直接调用即可。</p></blockquote><h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2.创建存储过程"></a>2.创建存储过程</h2><blockquote><p>使用<code>create procedure</code>语句</p><p><code>DELIMITER //</code>告诉命令行实用程序使用//作为新的语句结束分隔符 ，如果用<code>；</code>会报错</p><blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(<span class="keyword">IN</span> onumber <span class="built_in">INT</span>, <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(item_price*quantity) <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num=onumber <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>//</span><br></pre></td></tr></table></figure><p>创建完成后，下面是把分隔符换回<code>;</code>，调用存储过程，以及使用的截图</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200717151934659.png" alt="image-20200717151934659" style="zoom: 80%;" /></blockquote></blockquote><h2 id="3-建立智能存储过程"><a href="#3-建立智能存储过程" class="headerlink" title="3.建立智能存储过程"></a>3.建立智能存储过程</h2><blockquote><p><strong>例子</strong>：对某些顾客增加增值税  </p><p><code>--</code>后面的是注释，<code>taxable</code>它是一个布尔值（如果要增加税则为真，否则为假）,<code>DECLARE</code>语句定义了两个局部变量。  <code>COMMENT</code>它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200717160912339.png" alt="image-20200717160912339" style="zoom: 67%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200717161009835.png" alt="image-20200717161009835" style="zoom: 80%;" /><p><strong>输入输出</strong>：</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200717161248152.png" alt="image-20200717161248152"></p></blockquote><h2 id="4-检查存储过程"><a href="#4-检查存储过程" class="headerlink" title="4.检查存储过程"></a>4.检查存储过程</h2><blockquote><p>为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATEPROCEDURE语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十四章——使-用-游-标"><a href="#第二十四章——使-用-游-标" class="headerlink" title="第二十四章——使 用 游 标"></a>第二十四章——使 用 游 标</h1><p><em>本章将讲授什么是游标以及如何使用游标。</em></p><h2 id="1-什么是游标"><a href="#1-什么是游标" class="headerlink" title="1.什么是游标"></a>1.什么是游标</h2><blockquote><p>如果学过c语言，就比较好理解。游标的作用与指针类似。比如在一个操作里，需要对一个表的一千行进行有规律的操作，比如+1、+2、+3……，那么使用一千条语句就不现实了。此时就可以通过游标和循环，每次对一行操作，循环一千次。</p></blockquote><h2 id="2-使用游标"><a href="#2-使用游标" class="headerlink" title="2.使用游标"></a>2.使用游标</h2><blockquote><p><strong>创建游标</strong>: 用<code>DECLARE ....CURSOR</code>语句创建 。</p><p><strong>打开和关闭游标</strong>：用<code>OPEN</code>语句来打开  ，用<code>CLOSE</code>语句来打开,如果你不明确关闭游标， MySQL将会在到达END语句时自动关闭它。  </p><p><strong>使用游标数据</strong>  :游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。  </p></blockquote><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> processorders()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--声明局部变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> o <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--声明游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> ordernumbers <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">--定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里它指出当SQLSTATE'02000'出现时，SET done=1。</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">'02000'</span> <span class="keyword">SET</span> done=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建一个表存数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ordertotals</span><br><span class="line"></span><br><span class="line"><span class="comment">--打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">--重复使用FETCH</span></span><br><span class="line">REPEAT FETCH ordernumbers INTO o;</span><br><span class="line"></span><br><span class="line"><span class="comment">--掉用前面增加增值税的存储过程，并且返回结果</span></span><br><span class="line"><span class="keyword">CALL</span> ordertotal(o,<span class="number">1</span>,t);</span><br><span class="line"></span><br><span class="line"><span class="comment">--保存数据，十九章内容</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ordertotals(order_num,total) <span class="keyword">VALUES</span>(o,t);</span><br><span class="line"></span><br><span class="line"><span class="comment">--结束循环</span></span><br><span class="line">UNTIL done <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--关闭游标</span></span><br><span class="line">CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>//</span><br></pre></td></tr></table></figure><h1 id="第二十五章——使用触发器"><a href="#第二十五章——使用触发器" class="headerlink" title="第二十五章——使用触发器"></a>第二十五章——使用触发器</h1><p><em>本章学习什么是触发器，为什么要使用触发器以及如何使用触发器。本章还介绍创建和使用触发器的语法。</em>  </p><p>如果你想要某条语句（或某些语句）在事件发生时自动执行，怎么办呢？ 答案：使用<strong>触发器</strong> </p><p><strong>要点</strong>：</p><blockquote><p><strong>（1）</strong>触发器只能触发的语句：<strong>DELETE、 INSERT、UPDATE</strong>。  </p><p><strong>（2）</strong>只有表才支持触发器，视图不支持（临时表也不支持）。  </p><p><strong>（3）</strong> 触发器自带一些虚拟表，比如NEW,OLD。</p></blockquote><h2 id="1-创建触发器"><a href="#1-创建触发器" class="headerlink" title="1.创建触发器"></a>1.创建触发器</h2><blockquote><blockquote><p><strong>创建触发器要求：</strong><br> 唯一的触发器名；<br> 触发器关联的表；<br> 触发器应该响应的活动（DELETE、 INSERT或UPDATE）；<br> 触发器何时执行（处理之前或之后）。  </p></blockquote><p>用<code>CREATE TRIGGER</code>语句创建  </p><p><strong>例子</strong>：这个例子暂时有问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--文本Productadded将对每个插入的行显示一次。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> newproduct <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> products <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'product added'</span> <span class="keyword">INTO</span> @tip;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO products(prod_id,vend_id,prod_name,prod_price,prod_desc)</span><br><span class="line">VALUES(&#39;tian&#39;,1003,&#39;yutian&#39;,10,&#39;sss&#39;);</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-删除触发器"><a href="#2-删除触发器" class="headerlink" title="2.删除触发器"></a>2.删除触发器</h2><blockquote><p>和前面的删除语句一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> newproduct;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十六章——管理事务处理"><a href="#第二十六章——管理事务处理" class="headerlink" title="第二十六章——管理事务处理"></a>第二十六章——管理事务处理</h1><p><em>本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理</em>  </p><h2 id="1-什么是事务处理"><a href="#1-什么是事务处理" class="headerlink" title="1.什么是事务处理"></a>1.什么是事务处理</h2><blockquote><p><strong>事务处理</strong>是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。<strong>通俗点</strong>来说就是用来避免因为一些故障导致sql语句执行到一半就停止了，然后产生了错误的数据。</p><p>事务处理以<code>START TRANSACTION;</code>开始，有点类似一个函数块，然后可以利用一些语句对整个事务处理进行控制。</p></blockquote><h2 id="2-使用ROLLBACK"><a href="#2-使用ROLLBACK" class="headerlink" title="2.使用ROLLBACK"></a>2.使用ROLLBACK</h2><blockquote><p>ROLLBACK命令用来回退（撤销） MySQL语句</p><p><strong>注意：</strong></p><blockquote><p><strong>(1)</strong>ROLLBACK只能在一个事务处理内使用（在执行一条STARTTRANSACTION命令之后）。  </p><p><strong>(2)</strong>不能回退SELECT语句。（这样做也没有什么意义。）不能回退CREATE或DROP操作。  </p></blockquote><p><strong>例子</strong> :撤销删除操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-使用COMMIT"><a href="#2-使用COMMIT" class="headerlink" title="2.使用COMMIT"></a>2.使用COMMIT</h2><blockquote><p>为进行明确的提交，使用COMMIT语句。也就是COMMIT用来保证语句执行完毕无误后再提交结果</p><p><strong>例子</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。  </p></blockquote><h2 id="3-使用保留点"><a href="#3-使用保留点" class="headerlink" title="3.使用保留点"></a>3.使用保留点</h2><blockquote><p>ROLLBACK和COMMIT语句可以写入或撤销整个事务处理。但是复杂的事务处理可能需要部分提交或回退。便可以使用保留点</p><p>使用SAVEPOINT语句 创建保留点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> goback;</span><br></pre></td></tr></table></figure><p> goback就是保留点名称，如果需要返回保留点，就用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> goback;</span><br></pre></td></tr></table></figure><p>释放保留点就用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT goback;</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-更改默认的提交行为"><a href="#4-更改默认的提交行为" class="headerlink" title="4.更改默认的提交行为"></a>4.更改默认的提交行为</h2><blockquote><p>在事务处理里，每一个语句都是立刻执行并提交的，如果想指示MySQL不自动提交更改  ，可以用以下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。  </p></blockquote><h1 id="第二十七章——全球化和本地化"><a href="#第二十七章——全球化和本地化" class="headerlink" title="第二十七章——全球化和本地化"></a>第二十七章——全球化和本地化</h1><p><em>本章介绍MySQL处理不同字符集和语言的基础知识。</em>  </p><h2 id="1-字符集和校对顺序"><a href="#1-字符集和校对顺序" class="headerlink" title="1.字符集和校对顺序"></a>1.字符集和校对顺序</h2><blockquote><p><strong>(1)显示所有可用的字符集以及每个字符集的描述和默认校对:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure><p><strong>(2)显示所有可用的校对，以及它们适用的字符集</strong>  :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span>;</span><br></pre></td></tr></table></figure><p><strong>(3)给表指定字符集和校对</strong>  </p><p>此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">columnn1 <span class="built_in">INT</span>,</span><br><span class="line">COLUMNN2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line"><span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p><strong>(4)对每个列指定字符集个校对</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(</span><br><span class="line">columnn1 <span class="built_in">INT</span>,</span><br><span class="line">COLUMNN2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">column3 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_ci)</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew</span><br><span class="line"><span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十八章——安-全-管-理"><a href="#第二十八章——安-全-管-理" class="headerlink" title="第二十八章——安 全 管 理"></a>第二十八章——安 全 管 理</h1><p><em>数据库服务器通常包含关键的数据，确保这些数据的安全和完整需要利用访问控制。本章将学习MySQL的访问控制和用户管理。</em>  </p><h2 id="1-创建，重命名，删除用户"><a href="#1-创建，重命名，删除用户" class="headerlink" title="1.创建，重命名，删除用户"></a>1.创建，重命名，删除用户</h2><blockquote><p><strong>（1）创建用户</strong></p><p>使用CREATE USER语句  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> tian1 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'111111'</span>;</span><br></pre></td></tr></table></figure><p><code>tian1</code>是用户名，<code>111111</code>是密码。不过创建新用户不一定需要设置密码。</p><p><strong>（2）重命名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> tian1 <span class="keyword">TO</span> tiantian;</span><br></pre></td></tr></table></figure><p><strong>（3）删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> tiantian;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-设置访问权限"><a href="#2-设置访问权限" class="headerlink" title="2.设置访问权限"></a>2.设置访问权限</h2><p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。  </p><blockquote><p><strong>(1)查看权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> tian1;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200719135438219.png" alt="image-20200719135438219" style="zoom: 80%;" /><p><code>USAGE ON *.*</code>：<code>USAGE</code>表示没有权限，<code>*.*</code>表示任意数据库以及任意表。所以，此结果表示在任意数据库和任意表上对任何东西没有权限。  </p><p><strong>（2）添加权限</strong></p><p>使用GRANT语句  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT ON crashcourses.* TO tian1;</span><br></pre></td></tr></table></figure><p>此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。  </p><p><strong>（3）删除权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">FROM</span> tian1;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3-更改密码"><a href="#3-更改密码" class="headerlink" title="3.更改密码"></a>3.更改密码</h2><blockquote><p>使用SET PASSWORD语句  </p><p><strong>例子1：</strong>更改tian1的密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> tian1=<span class="keyword">Password</span>(<span class="string">'222222'</span>);</span><br></pre></td></tr></table></figure><p><strong>例子1：</strong>更改当前登录用户的密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> =<span class="keyword">Password</span>(<span class="string">'222222'</span>);</span><br></pre></td></tr></table></figure></blockquote><h1 id="第二十九章——数据库维护"><a href="#第二十九章——数据库维护" class="headerlink" title="第二十九章——数据库维护"></a>第二十九章——数据库维护</h1><p><em>本章学习如何进行常见的数据库维护。</em>  </p><blockquote><p><strong>(1)</strong>ANALYZE TABLE，用来检查表键是否正确。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ANALYZE</span> <span class="keyword">TABLE</span> orders;</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200719150555529.png" alt="image-20200719150555529" style="zoom:80%;" /><p>(2)</p></blockquote><h1 id="第三十章——改善性能"><a href="#第三十章——改善性能" class="headerlink" title="第三十章——改善性能"></a>第三十章——改善性能</h1><p><em>本章将复习与MySQL性能有关的某些要点。</em></p><blockquote><p>（1）MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是没问题的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用 SHOW VARIABLES;和 SHOW STATUS;。）<br>（2）MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。<br>（3）总是有不止一种方法编写同一条SELECT语句。 应该试验联结、并、子查询等，找出最佳的方法。<br>（4）使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。<br>（5）一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。<br>（6）应该总是使用正确的数据类型。<br>（7）决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。<br>（8） 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。<br>（9）在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。<br>（10）必须索引数据库表以改善数据检索的性能。<br>（11）你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改<br>进。<br>（12）索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）<br>（13）LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。<br>（14）数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown小技巧</title>
      <link href="/2020/09/06/markdown%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/09/06/markdown%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<div align="center" >————markdown的基础语法以及一些稍微高级的用法————</div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>markdown是什么？</strong></p><p>百度百科：Markdown是一种可以使用普通文本编辑器编写的<a href="https://baike.baidu.com/item/标记语言/5964436" target="_blank" rel="noopener">标记语言</a>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>换种说法，就是文章内容会根据你标记的符号来呈现特定的格式，markdown文件后缀是md。</p><p><strong>需要用到什么软件：</strong></p><p>不需要特定软件，</p><p>在这里，给大家介绍一款我在用的markdown编辑器——Typera（特殊的编辑器会根据<strong>markdown</strong>语法实时渲染，呈现格式。）效果可以看视频。</p><h1 id="一、基础语法看这里"><a href="#一、基础语法看这里" class="headerlink" title="一、基础语法看这里"></a>一、基础语法看这里</h1><blockquote><p>1.<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">链接1</a></p><p>2.<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">连接2</a></p></blockquote><h1 id="二、基础语法没怎么提及的用法"><a href="#二、基础语法没怎么提及的用法" class="headerlink" title="二、基础语法没怎么提及的用法"></a>二、基础语法没怎么提及的用法</h1><h2 id="1-控制主页显示内容"><a href="#1-控制主页显示内容" class="headerlink" title="1.控制主页显示内容"></a>1.控制主页显示内容</h2><blockquote><p>使用<code>&lt;!--more--&gt;</code><br>只显示 <code>&lt;!--more--&gt;</code> 之前的内容、</p></blockquote><h2 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2.插入图片"></a>2.插入图片</h2><blockquote><p>目前我使用的是阿里云+Typora的方法，方法见知乎：<br><a href="https://zhuanlan.zhihu.com/p/138878534" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/138878534</a><br>目前我是用4.98元买了6个月的资源包，后续费用怎样我再写上来</p></blockquote><h2 id="3-调节图片大小"><a href="#3-调节图片大小" class="headerlink" title="3.调节图片大小"></a>3.调节图片大小</h2><blockquote><p><strong>方法1</strong>：格式：<code>&lt;img src=&quot;图片路径或网址&quot; width=&quot;这里写宽度px&quot;&gt;</code></p><p>比如下面这张图片的代码是<code>&lt;img src=&quot;http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png&quot; width=&quot;100px&quot;&gt;</code></p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png" width="100px"><p><strong>方法2：</strong></p><p>格式：<code>&lt;img src=&quot;图片路径或网址&quot; alt=&quot;图片描述（图片没显示时显示的文字）&quot; style=&quot;zoom: 一个百分数（控制大小）;&quot; /&gt;</code></p><p>图片描述也可以不要：<code>&lt;img src=&quot;图片路径或网址&quot; style=&quot;zoom: 一个百分数（控制大小）;&quot; /&gt;</code></p><p>比如下面这张图片的代码是<code>&lt;img src=&quot;http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png&quot; style=&quot;zoom: 67%;&quot; /&gt;</code></p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png" style="zoom: 67%;" /><p><strong>方法3：</strong>根据上面插入图片的方法配置好，可以直接把图片复制粘贴到Typora，会自动上传阿里云并且编辑好方法2的格式，十分方便。</p></blockquote><h2 id="4-添加目录"><a href="#4-添加目录" class="headerlink" title="4.添加目录"></a>4.添加目录</h2><blockquote><p>利用vscode的“Markdown TOC”插件可以自动生成目录</p></blockquote><h2 id="5-文字居中"><a href="#5-文字居中" class="headerlink" title="5.文字居中"></a>5.文字居中</h2><blockquote><div align="center" >比如这样</div><p>上面语句的代码：<code>&lt;div align=&quot;center&quot; &gt;比如这样&lt;/div&gt;</code></p><p>格式就是：<code>&lt;div align=&quot;center&quot; &gt;这里添加需要居中的文本&lt;/div&gt;</code></p></blockquote><h2 id="6-实现页面内跳转"><a href="#6-实现页面内跳转" class="headerlink" title="6.实现页面内跳转"></a>6.实现页面内跳转</h2><blockquote><p>跳转起点添加语句：<code>[跳转入口名字](#jump)</code></p><p>跳转终点添加语句：<code>&lt;span id=&quot;jump&quot;&gt; &lt;/span&gt;</code></p><p><strong>解释：</strong></p><blockquote><p>（1）跳转入口名字: 就是像超链接一样，颜色一般是蓝色的，点击就会跳转，类似提示语</p><p>（2）jump：这里的jump是两个点连接的标识，可以称为id。jump只是我定义的id，你也可以用其他字母或者数字</p><p>（3）<code>&lt;span id=&quot;jump&quot;&gt; &lt;/span&gt;</code>中间可以加文本，会在终点显示</p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建与运营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础知识点</title>
      <link href="/2020/09/06/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/09/06/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<div align="center">————这里，有我学习linux时记录的一些基础知识点————</div><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><strong>为什么学习 Linux 系统？</strong>  </li></ul><p>可以看一下下图linux相对于windows的优势</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709110136166.png" alt="image-20200709110136166" style="zoom:80%;" /><p>Linux的这些优势就是需要学习Linux的部分原因</p><h1 id="一、linux基础命令"><a href="#一、linux基础命令" class="headerlink" title="一、linux基础命令"></a>一、linux基础命令</h1><h3 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h3><p><code>命令名称 [命令参数] [命令对象]</code></p><p>命令名称、命令参数、命令对象之间请用空格键分隔。<br>命令对象一般是指要处理的文件、目录、用户等资源，而命令参数可以用长格式（完整的选项名称,例如：<code>man --help</code>）， 也可以用短格式（单个字母的缩写，例如：<code>man -h</code>）， 两者分别用<code>--</code>与<code>-</code>作为前缀  .</p><h3 id="2-常用系统工作命令"><a href="#2-常用系统工作命令" class="headerlink" title="2.常用系统工作命令"></a>2.常用系统工作命令</h3><ul><li><strong>man命令</strong></li></ul><p>man可以用来查看命令的帮助信息，比如我想了解<code>date</code>命令的帮助信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man date</span><br></pre></td></tr></table></figure><ul><li><strong>echo命令</strong></li></ul><p><strong>格式</strong>:“echo [字符串 | $变量]”，echo 命令用于在终端输出字符串或变量提取后的值。</p><p>1.输出字符串“tiantian”  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ echo tiantian</span><br><span class="line">tiantian</span><br></pre></td></tr></table></figure><p>2.提取变量SHELL的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><ul><li><strong>date命令</strong></li></ul><p><strong>格式</strong>：“date [选项] [+指定的格式]”  ，date 命令用于显示及设置系统的时间或日期  。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709134743022.png" alt="image-20200709134743022" style="zoom:67%;" /><ul><li><strong>reboot命令</strong></li></ul><p>reboot命令用于重启系统</p><ul><li><strong>poweroff命令</strong></li></ul><p>poweroff命令用于关闭系统</p><ul><li><strong>wget命令</strong></li></ul><ul><li><strong>ps命令</strong></li></ul><p><strong>格式</strong>：“ps [参数]”，ps 命令用于查看系统中的进程状态，</p><ul><li><strong>top命令</strong></li></ul><p><strong>格式</strong>： top  </p><p>top 命令用于动态地监视进程活动与系统负载等信息</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200709141112655.png" alt="image-20200709141112655" style="zoom:67%;" /><p>top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。</p><blockquote><p>第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、 5分钟、 15 分钟内的平均值，数值越小意味着负载越低）。<br> 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。<br> 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。（96.0id 意味着有 96.0%的 CPU 处理器资源处于空闲 ）</p><p>第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p><p>第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。  </p></blockquote><ul><li><strong>pidof命令</strong></li></ul><p><strong>格式</strong>：“pidof [参数] [服务名称]”， pidof 命令用于查询某个指定服务进程的 PID 值，</p><p>每个进程的进程号码值（PID）是唯一的，因此可以通过 PID 来区分不同的进程。  </p><ul><li><strong>kill命令</strong></li></ul><p><strong>格式</strong>：“kill [参数] [进程 PID]”，  kill 命令用于终止某个指定 PID 的服务进程</p><ul><li><strong>killall 命令</strong>  </li></ul><p><strong>格式</strong>：“killall [参数] [进程名称]”，killall 命令用于终止某个指定名称的服务所对应的全部进程。</p><h3 id="2-系统状态检测命令"><a href="#2-系统状态检测命令" class="headerlink" title="2.系统状态检测命令"></a>2.系统状态检测命令</h3><ul><li><strong>ifconfig 命令</strong>  </li></ul><p>ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。  </p><p>输出如下，网卡名称、 <strong>inet</strong> 参数后面的 IP 地址、 <strong>ether</strong> 参数后面的网卡物理地址（又称为 MAC 地址），以及 <strong>RX</strong>、 <strong>TX</strong> 的接收数据包与发送数据包的个数及累计流量 ，都是重要参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# ifconfig</span><br><span class="line">ens33: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.231.130  netmask 255.255.255.0  broadcast 192.168.231.255</span><br><span class="line">        inet6 fe80::cce1:d7a5:4905:6f54  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:09:5b:2c  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 2960  bytes 1124457 (1.1 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1266  bytes 186200 (186.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 516  bytes 41664 (41.6 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 516  bytes 41664 (41.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><ul><li><strong>uname</strong>命令</li></ul><p>uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。  </p><ul><li>*<em>uptime 命令  *</em></li></ul><p>uptime 用于查看系统的负载信息，格式为 uptime。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# uptime</span><br><span class="line"> 14:47:03 up  1:35,  2 users,  load average: 0.04, 0.01, 0.00</span><br></pre></td></tr></table></figure><p>它可以显示当前<strong>系统时间</strong>、<strong>系统已运行时间</strong>、<strong>启用终端数量</strong>以及<strong>平均负载值</strong>等信息。平均负载值指的是系统在最近 1 分钟、 5 分钟、 15 分钟内的压力情况，负载值越低越好  。</p><ul><li><strong>free 命令</strong>  </li></ul><p>free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# free -h</span><br><span class="line">              总计         已用        空闲        共享       缓冲&#x2F;缓存      可用</span><br><span class="line">内存：        1.9G        929M        387M        7.0M        641M        865M</span><br><span class="line">交换：        2.0G          0B        2.0G</span><br></pre></td></tr></table></figure><p><strong>共享</strong>：进程共享的内存量。<strong>缓冲/缓存</strong>：磁盘缓存的内存量。<strong>可用</strong>：缓存的内存量。</p><p>（我的系统显示的是中文）</p><ul><li><strong>who 命令</strong>  </li></ul><p>who 用于查看当前登入主机的用户终端信息，格式为“who [参数]”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# who</span><br><span class="line">tian     :0           2020-07-09 13:12 (:0)</span><br><span class="line">tian     pts&#x2F;2        2020-07-09 13:15 (192.168.231.1)</span><br></pre></td></tr></table></figure><ul><li><strong>last 命令</strong></li></ul><p>last 命令用于查看所有系统的登录记录，格式为“last [参数]”。</p><ul><li><strong>history 命令</strong></li></ul><p>history 命令用于显示历史执行过的命令，格式为“history”，要清除记录，用<code>history -c</code>。还可以使用“!编码数字”的方式来重复执行某一次的命令。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# history</span><br><span class="line">    1  history</span><br><span class="line">    2  date</span><br><span class="line">    3  history</span><br><span class="line">root@tian-virtual-machine:~# !2</span><br><span class="line">date</span><br><span class="line">2020年 07月 09日 星期四 15:10:56 CST</span><br></pre></td></tr></table></figure><ul><li><strong>sosreport 命令</strong></li></ul><p>sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。  </p><h3 id="3-工作目录切换命令"><a href="#3-工作目录切换命令" class="headerlink" title="3.工作目录切换命令"></a>3.工作目录切换命令</h3><ul><li><strong>pwd 命令</strong>  </li></ul><p>pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。  </p><ul><li><strong>cd命令</strong></li></ul><p>cd 命令用于切换工作路径，格式为“cd [目录名称]”。  </p><p><code>cd ~</code>切换到根目录，<code>cd -</code>切换到上一次的目录.</p><ul><li><strong>ls命令</strong></li></ul><p>ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。  </p><p><code>ls -a</code>看到全部文件（包括隐藏文件）  ,<code>ls -l</code>查看文件的属性、大小等详细信息。  </p><h3 id="4-文本文件编辑命令"><a href="#4-文本文件编辑命令" class="headerlink" title="4.文本文件编辑命令"></a>4.文本文件编辑命令</h3><ul><li><strong>cat命令</strong></li></ul><p>cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。  </p><ul><li>*<em>more 命令  *</em></li></ul><p>more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。  </p><p>可以使用空格键或回车键向下翻页  </p><ul><li><strong>head 命令</strong>  </li></ul><p>head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。  </p><ul><li>*<em>tail 命令  *</em></li></ul><p>tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。  </p><ul><li><strong>tr 命令</strong>  </li></ul><p>tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。  </p><ul><li><strong>wc 命令</strong>  </li></ul><p>wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。  </p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">只显示行数</td></tr><tr><td align="center">-w</td><td align="center">只显示单词数</td></tr><tr><td align="center">-c</td><td align="center">只显示字节数</td></tr></tbody></table><ul><li><strong>stat 命令</strong>  </li></ul><p>stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。  </p><ul><li><strong>cut 命令</strong>  </li></ul><p>cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。  </p><ul><li><strong>diff 命令</strong>  </li></ul><p>diff 命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。  </p><p>以使用–brief 参数来确认两个文件是否不同，还可以使用-c参数来详细比较出多个文件的差异之处，  </p><h3 id="5-文件目录管理命令"><a href="#5-文件目录管理命令" class="headerlink" title="5.文件目录管理命令"></a>5.文件目录管理命令</h3><p><strong>touch 命令</strong>  </p><p>touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。  </p><p>创建tian.txt文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ touch tian.txt</span><br></pre></td></tr></table></figure><ul><li><strong>mkdir 命令</strong>  </li></ul><p>mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。  </p><p>创建tian文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ mkdir tian</span><br></pre></td></tr></table></figure><ul><li><strong>cp 命令</strong>  </li></ul><p>cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。  </p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>保留原始文件的属性</td></tr><tr><td>-d</td><td>若对象为“链接文件”，则保留该“链接文件”的属性</td></tr><tr><td>-r</td><td>递归持续复制（用于目录）</td></tr><tr><td>-i</td><td>若目标文件存在则询问是否覆盖</td></tr><tr><td>-a</td><td>相当于-pdr（p、 d、 r 为上述参数）</td></tr></tbody></table><p>将tian.txt复制到tian文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ cp tian.txt tian</span><br></pre></td></tr></table></figure><ul><li><strong>mv 命令</strong>  </li></ul><p>mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。  </p><ul><li><strong>rm 命令</strong>  </li></ul><p>rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。</p><p>rm 命令后跟上-f 参数来强制删除。</p><p> 想要删除一个目录，需要在 rm 命令后面一个-r 参数    </p><ul><li><strong>dd 命令</strong>  </li></ul><p>dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。  </p><ul><li><strong>file 命令</strong>  </li></ul><p>file 命令用于查看文件的类型，格式为“file 文件名”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ file tian.txt</span><br><span class="line">tian.txt: ASCII text</span><br></pre></td></tr></table></figure><h3 id="6-打包与压缩的命令"><a href="#6-打包与压缩的命令" class="headerlink" title="6.打包与压缩的命令"></a>6.打包与压缩的命令</h3><ul><li><strong>tar 命令</strong>  </li></ul><p>tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。  </p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">创建压缩文件</td></tr><tr><td align="center">-x</td><td align="center">解开压缩文件</td></tr><tr><td align="center">-t</td><td align="center">查看压缩包内有哪些文件</td></tr><tr><td align="center">-z</td><td align="center">用 Gzip 压缩或解压</td></tr><tr><td align="center">-j</td><td align="center">用 bzip2 压缩或解压</td></tr><tr><td align="center">-v</td><td align="center">显示压缩或解压的过程</td></tr><tr><td align="center">-f</td><td align="center">目标文件名</td></tr><tr><td align="center">-p</td><td align="center">保留原始的权限与属性</td></tr><tr><td align="center">-P</td><td align="center">使用绝对路径来压缩</td></tr><tr><td align="center">-C</td><td align="center">指定解压到的目录</td></tr></tbody></table><p>将tian文件夹用 Gzip 压缩，并且显示压缩的过程，压缩文件命名为tian.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ tar -czvf tian.gz tian</span><br><span class="line">tian&#x2F;</span><br><span class="line">tian&#x2F;tian.txt</span><br></pre></td></tr></table></figure><ul><li><strong>grep 命令</strong>  </li></ul><p>grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。  </p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-b</td><td align="center">将可执行文件（binary）当作文本文件（text）来搜索</td></tr><tr><td align="center">-c</td><td align="center">仅显示找到的行数</td></tr><tr><td align="center">-i</td><td align="center">忽略大小写</td></tr><tr><td align="center">-n</td><td align="center">显示行号</td></tr><tr><td align="center">-v</td><td align="center">反向选择—仅列出没有“关键词”的行</td></tr></tbody></table><p>在tian.txt文件中找“c”,结果只显示c的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ grep -n c tian.txt</span><br><span class="line">3:c</span><br></pre></td></tr></table></figure><ul><li><strong>find 命令</strong>  </li></ul><p>find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。  </p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-name</td><td>匹配名称</td></tr><tr><td>-perm</td><td>匹配权限（mode 为完全匹配， -mode 为包含即可）</td></tr><tr><td>-user</td><td>匹配所有者</td></tr><tr><td>-group</td><td>匹配所有组</td></tr><tr><td>-mtime -n +n</td><td>匹配修改内容的时间（-n 指 n 天以内， +n 指 n 天以前）</td></tr><tr><td>-atime -n +n</td><td>匹配访问文件的时间（-n 指 n 天以内， +n 指 n 天以前）</td></tr><tr><td>-ctime -n +n</td><td>匹配修改文件权限的时间（-n 指 n 天以内， +n 指 n 天以前）</td></tr><tr><td>-nouser</td><td>匹配无所有者的文件</td></tr><tr><td>-nogroup</td><td>匹配无所有组的文件</td></tr><tr><td>-newer f1 !f2</td><td>匹配比文件 f1 新但比 f2 旧的文件</td></tr><tr><td>–type b/d/c/p/l/f</td><td>匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、 链接文件、文本文件）</td></tr><tr><td>-size</td><td>匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件）</td></tr><tr><td>-prune</td><td>忽略某个目录</td></tr><tr><td>-exec …… {};</td><td>后面可跟用于进一步处理搜索结果的命令（下文会有演示）</td></tr></tbody></table><h1 id="二、管道符、重定向与环境变量"><a href="#二、管道符、重定向与环境变量" class="headerlink" title="二、管道符、重定向与环境变量"></a>二、管道符、重定向与环境变量</h1><h2 id="1-输入输出重定向"><a href="#1-输入输出重定向" class="headerlink" title="1.输入输出重定向"></a>1.输入输出重定向</h2><p><strong>输入重定向</strong>：把文件导入到命令中。</p><p><strong>输出重定向</strong>：把原本要输出到屏幕的数据信息写入到指定文件中。</p><blockquote><p><strong>标准输出重定向</strong>: 错误信息不会被输出到重定向的文件里。</p><p><strong>错误输出重定向</strong>: 错误信息也会输出到重定向的文件里。两者具体区别可以看下面的例子</p></blockquote><p>​                    </p><p> <strong><em>输入重定向中用到的符号及其作用</em></strong></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分界符</td><td>从标准输入中读入，直到遇见分界符才停止</td></tr><tr><td>命令 &lt; 文件 1 &gt; 文件 2</td><td>将文件 1 作为命令的标准输入并将标准输出到文件 2</td></tr></tbody></table><p> <strong><em>输出重定向中用到的符号及其作用</em></strong></p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写入到文件中（追加到原有内容的 后面）</td></tr></tbody></table><p><strong>例子</strong>：</p><p><strong>1</strong>.将<code>man ls</code>的输出内容写到tian.txt文件里面去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ man ls &gt; tian.txt</span><br></pre></td></tr></table></figure><p><strong>2</strong>.用<code>tian tian aaaa</code>覆盖tian.txt里面的内容，<code>tian tian bbbb</code>追加在后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ echo &quot;tian tian aaaa&quot;&gt;tian.txt</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ cat tian.txt</span><br><span class="line">tian tian aaaa</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ echo &quot;tian tian bbbb&quot;&gt;&gt;tian.txt</span><br><span class="line">tian tian aaaa</span><br><span class="line">tian tian bbbb</span><br></pre></td></tr></table></figure><p><strong>3</strong>.使用标准输出重定向（222是不存在的目录，瞎编的）</p><p>可以看到，第3行进行查看tian.txt，显示是空，说明错误提示并没有输入到tian.txt里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ ls -l 222  &gt;tian.txt</span><br><span class="line">ls: 无法访问&#39;222&#39;: 没有那个文件或目录</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ cat tian.txt</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$</span><br></pre></td></tr></table></figure><p><strong>4</strong>.使用错误输出重定向（222是不存在的目录，瞎编的）</p><p>可以看到，第2行进行查看tian.txt，显示内容就是<code>ls -l 222 2&gt;tian.txt</code>的错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ ls -l 222 2&gt;tian.txt</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ cat tian.txt</span><br><span class="line">ls: 无法访问&#39;222&#39;: 没有那个文件或目录</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$</span><br></pre></td></tr></table></figure><h2 id="2-管道命令符（-）"><a href="#2-管道命令符（-）" class="headerlink" title="2.管道命令符（|）"></a>2.管道命令符（|）</h2><p><strong>作用</strong>：把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入  </p><h2 id="3-命令行的通配符"><a href="#3-命令行的通配符" class="headerlink" title="3.命令行的通配符"></a>3.命令行的通配符</h2><p><strong>星号（*）</strong>：匹配零个或多个字符</p><p><strong>问号（?）</strong>：代表匹配单个字符</p><p><strong>[0-9]</strong> : 代表匹配 0～9之间的单个数字的字符,当然，括号里面的范围可以自己定义。</p><p><strong>[abc]</strong> :则是代表匹配 a、 b、 c 三个字符中的任意一个字符。  </p><h2 id="4-常用的转义字符"><a href="#4-常用的转义字符" class="headerlink" title="4.常用的转义字符"></a>4.常用的转义字符</h2><p>4 个最常用的转义字符如下所示。</p><blockquote><p><strong>反斜杠（\）</strong>：使反斜杠后面的一个变量变为单纯的字符串。<br><strong>单引号（’’）</strong>：转义其中所有的变量为单纯的字符串。<br><strong>双引号（””）</strong>：保留其中的变量属性，不进行转义处理。<br><strong>反引号（``）</strong>：把其中的命令执行后返回结果。  </p></blockquote><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~&#x2F;tian$   echo uname -a</span><br><span class="line">uname -a</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian$ echo &#96;uname -a&#96;</span><br><span class="line">Linux tian-virtual-machine 5.3.0-51-generic #44~18.04.2-Ubuntu SMP Thu Apr 23 14:27:18 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><h2 id="5-重要的环境变量"><a href="#5-重要的环境变量" class="headerlink" title="5.重要的环境变量"></a>5.重要的环境变量</h2><p>Linux 系统中最重要的 10 个环境变量  </p><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户的主目录（即家目录）</td></tr><tr><td>SHELL</td><td>用户在使用的 Shell 解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言、语系名称</td></tr><tr><td>RANDOM</td><td>生成一个随机数字</td></tr><tr><td>PS1</td><td>Bash 解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>用户默认的文本编辑器</td></tr></tbody></table><p>查看变量值，可以使用<code>echo $变量</code>,例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为 WORKDIR 的变量，方便用户更轻松地进入一个层次较深的目录：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ mkdir tian&#x2F;zhu&#x2F;da</span><br><span class="line">tian@tian-virtual-machine:~$ WORKDIR&#x3D;tian&#x2F;zhu&#x2F;da</span><br><span class="line">tian@tian-virtual-machine:~$ cd $WORKDIR</span><br><span class="line">tian@tian-virtual-machine:~&#x2F;tian&#x2F;zhu&#x2F;da$ pwd</span><br><span class="line">&#x2F;home&#x2F;tian&#x2F;tian&#x2F;zhu&#x2F;da</span><br></pre></td></tr></table></figure><h1 id="三、Vim-编辑器与-Shell-命令脚本"><a href="#三、Vim-编辑器与-Shell-命令脚本" class="headerlink" title="三、Vim 编辑器与 Shell 命令脚本"></a>三、Vim 编辑器与 Shell 命令脚本</h1><h2 id="1-Vim-文本编辑器"><a href="#1-Vim-文本编辑器" class="headerlink" title="1.Vim 文本编辑器"></a>1.Vim 文本编辑器</h2><h3 id="1-1三种模式"><a href="#1-1三种模式" class="headerlink" title="1.1三种模式"></a>1.1三种模式</h3><blockquote><p>(1)<strong>命令模式</strong>：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。<br>(2)<strong>输入模式</strong>：正常的文本录入。<br>(3)<strong>末行模式</strong>：保存或退出文档，以及设置编辑环境。 </p></blockquote><p>在每次运行 Vim 编辑器时，默认进入命令模式  </p><p><strong>三种模式切换方法</strong>： </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200712173900187.png" alt="image-20200712173900187" style="zoom:67%;" /><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><p>（<strong>1）命令模式中常用的一些命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除（剪切）光标所在整行</td></tr><tr><td>5dd</td><td>删除（剪切）从光标处开始的 5 行</td></tr><tr><td>yy</td><td>复制光标所在整行</td></tr><tr><td>5yy</td><td>复制从光标处开始的 5 行</td></tr><tr><td>n</td><td>显示搜索命令定位到的下一个字符串</td></tr><tr><td>N</td><td>显示搜索命令定位到的上一个字符串</td></tr><tr><td>u</td><td>撤销上一步的操作</td></tr><tr><td>p</td><td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td></tr></tbody></table><p><strong>（2）末行模式中常用的一些命令</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:q!</td><td>强制退出（放弃对文档的修改内容）</td></tr><tr><td>:wq!</td><td>强制保存退出</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>不显示行号</td></tr><tr><td>:命令</td><td>执行该命令</td></tr><tr><td>:整数</td><td>跳转到该行</td></tr><tr><td>:s/one/two</td><td>将当前光标所在行的第一个 one 替换成 two</td></tr><tr><td>:s/one/two/g</td><td>将当前光标所在行的所有 one 替换成 two</td></tr><tr><td>:%s/one/two/g</td><td>将全文中的所有 one 替换成 two</td></tr><tr><td>?字符串</td><td>在文本中从下至上搜索该字符串</td></tr><tr><td>/字符串</td><td>在文本中从上至下搜索该字符串</td></tr></tbody></table><h2 id="2-编写-Shell-脚本"><a href="#2-编写-Shell-脚本" class="headerlink" title="2.编写 Shell 脚本"></a>2.编写 Shell 脚本</h2><h3 id="2-1编写一个简单脚本"><a href="#2-1编写一个简单脚本" class="headerlink" title="2.1编写一个简单脚本"></a>2.1编写一个简单脚本</h3><p>第一行的脚本声明（#!）用来告诉系统使用哪种 Shell 解释器来执行该脚本。</p><p>第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该<br>脚本的作用或一些警告信息。</p><p>第三、四行的可执行语句也就是我们平时执行的 Linux 命令了。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# touch tiana.sh</span><br><span class="line">root@tian-virtual-machine:~# vim tiana.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#一个简单脚本</span><br><span class="line">pwd</span><br><span class="line">ls -a</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">root@tian-virtual-machine:~# cat tiana.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#一个简单脚本</span><br><span class="line">pwd</span><br><span class="line">ls -a</span><br><span class="line">root@tian-virtual-machine:~# bash tiana.sh</span><br><span class="line">&#x2F;root</span><br><span class="line">.  ..  .bash_history  .bashrc  .cache  .gnupg  .profile  tiana.sh  .viminfo</span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><h3 id="2-2-接收用户的参数"><a href="#2-2-接收用户的参数" class="headerlink" title="2.2 接收用户的参数"></a>2.2 接收用户的参数</h3><p>一些字符的含义：</p><blockquote><p><strong>$0</strong> ：当前 Shell 脚本程序的名称</p><p><strong>$#</strong>：参数总数</p><p> <strong>$*</strong>：对应的是所有位置的参数值</p><p><strong>$?</strong>：对应的是显示上一次命令的执行返回值</p><p><strong>$N</strong>：第 N 个位置的参数值  </p></blockquote><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tian@tian-virtual-machine:~$ vim tiana.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;当前脚本名称是$0&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;当前总共有$#个参数，分别是$*&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;第一个参数是$1&quot;</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">这里省略了一大堆“~”</span><br><span class="line">~</span><br><span class="line">&quot;tiana.sh&quot; [新] 8L, 123C 已写入                                                                                                 </span><br><span class="line">tian@tian-virtual-machine:~$ sh tiana.sh 1 2 3 4</span><br><span class="line">当前脚本名称是tiana.sh</span><br><span class="line">当前总共有4个参数，分别是1 2 3 4</span><br><span class="line">第一个参数是1</span><br><span class="line">tian@tian-virtual-machine:~$</span><br></pre></td></tr></table></figure><h3 id="2-3判断用户的参数"><a href="#2-3判断用户的参数" class="headerlink" title="2.3判断用户的参数"></a>2.3判断用户的参数</h3><p><strong>（1）文件判断</strong></p><p>Shell 脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字 0，否则便返回其他随机数值。  </p><p>条件测试语法的执行格式如下图所示，切记，<strong>条件表达式两边均应有一个空格</strong>。  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713131623637.png" alt="image-20200713131623637" style="zoom:80%;" /><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>测试文件是否为目录类型</td></tr><tr><td>-e</td><td>测试文件是否存在</td></tr><tr><td>-f</td><td>判断是否为一般文件</td></tr><tr><td>-r</td><td>测试当前用户是否有权限读取</td></tr><tr><td>-w</td><td>测试当前用户是否有权限写入</td></tr><tr><td>-x</td><td>测试当前用户是否有权限执行</td></tr></tbody></table><div align="center">文件测试所用参数表<div><p><strong>（2）逻辑判断</strong></p><p>还可以利用逻辑语句对测试结果进行逻辑分析，根据测试结果可实现不同的效果。</p><p><strong>&amp;&amp;</strong>：表示当前面的命令执行成功后才会执行它后面的命令 。</p><p><strong>||</strong>  ：表示当前面的命令执行失败后才会执行它后面的命令  </p><p><strong>！</strong>  ：表示把条件测试中的判断结果取相反值  </p><p><strong>例子</strong>(tian.sh是存在的，t.sh是不存在的)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# ls -a</span><br><span class="line">.  ..  .bash_history  .bashrc  .cache  .gnupg  .profile  tiana.sh  tian.sh  .viminfo</span><br><span class="line">root@tian-virtual-machine:~# [ -f tian.sh ]</span><br><span class="line">root@tian-virtual-machine:~# echo $?</span><br><span class="line">0</span><br><span class="line">root@tian-virtual-machine:~# [ -f tian.sh ] &amp;&amp; echo &quot;存在&quot;</span><br><span class="line">存在</span><br><span class="line">root@tian-virtual-machine:~# [ -f t.sh ] || echo &quot;存在&quot;</span><br><span class="line">存在</span><br><span class="line">root@tian-virtual-machine:~# [ ! -f tian.sh ] || echo &quot;存在&quot;</span><br><span class="line">存在</span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><p><strong>再来看一个复杂一点的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# [ ! -f tian.sh ] &amp;&amp; echo &quot;不存在&quot; || echo &quot;存在&quot; </span><br><span class="line">存在</span><br></pre></td></tr></table></figure><p><strong>（3）整数判断</strong></p><p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作  </p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>-eq</td><td>是否等于</td></tr><tr><td>-ne</td><td>是否不等于</td></tr><tr><td>-gt</td><td>是否大于</td></tr><tr><td>-lt</td><td>是否小于</td></tr><tr><td>-le</td><td>是否等于或小于</td></tr><tr><td>-ge</td><td>是否大于或等于</td></tr></tbody></table><div align="center">可用的整数比较运算符表<div><p><strong>例子1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# [ 10 -eq 10 ] &amp;&amp; echo &quot;10&#x3D;10&quot;</span><br><span class="line">10&#x3D;10</span><br></pre></td></tr></table></figure><p><strong>例子2</strong>：判断内存是否不足，小于1024内存不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# free -m</span><br><span class="line">              总计         已用        空闲      共享    缓冲&#x2F;缓存    可用</span><br><span class="line">内存：        1958         878         442           9         638         914</span><br><span class="line">交换：        2047           0        2047</span><br><span class="line">root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot;</span><br><span class="line">内存：        1958         878         442           9         638         914</span><br><span class="line">root@tian-virtual-machine:~# free -m</span><br><span class="line">              总计         已用        空闲      共享    缓冲&#x2F;缓存    可用</span><br><span class="line">内存：        1958         878         442           9         638         914</span><br><span class="line">交换：        2047           0        2047</span><br><span class="line">root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot;</span><br><span class="line">内存：        1958         878         442           9         638         914</span><br><span class="line">root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot; | awk &#39;&#123;print $4&#125;&#39;</span><br><span class="line">442</span><br><span class="line">root@tian-virtual-machine:~# FreeMem&#x3D;&#96;free -m | grep &quot;内存：&quot; | awk &#39;&#123;print $4&#125;&#39;&#96;</span><br><span class="line">root@tian-virtual-machine:~# echo $FreeMem</span><br><span class="line">441            </span><br><span class="line">root@tian-virtual-machine:~# [ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;内存不足&quot;</span><br><span class="line">内存不足</span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><p><code>free -m</code>: 获取当前系统正在使用及可用的内存量信息，-m是以Mb显示。</p><p><code>grep &quot;内存：&quot;</code>:只显示“内存”这一行。</p><p><code>awk &#39;{print $4}&#39;</code>:只保留第四列 。</p><p><strong>（4）.字符判断</strong></p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>=</td><td>比较字符串内容是否相同</td></tr><tr><td>!=</td><td>比较字符串内容是否不同</td></tr><tr><td>-z</td><td>判断字符串内容是否为空</td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# [ fkjdk &#x3D; dslfk ]</span><br><span class="line">root@tian-virtual-machine:~# echo $?</span><br><span class="line">1</span><br><span class="line">root@tian-virtual-machine:~# [ ff &#x3D; ff ]</span><br><span class="line">root@tian-virtual-machine:~# echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="2-4流程控制语句"><a href="#2-4流程控制语句" class="headerlink" title="2.4流程控制语句"></a>2.4流程控制语句</h3><p><strong>（1）if 条件测试语句</strong>  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713214739410.png" alt="image-20200713214739410" style="zoom:80%;" /><p><strong>例子</strong>：</p><p>为了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据包的发送间隔，以及使用-W 参数定义等待超时时间  ，192.168.231.134是虚拟机ip地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# vim test_ping.sh</span><br><span class="line">#!bin&#x2F;bash</span><br><span class="line">ping -c 3 -i 0.2 -w 3 $1 &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;Host $1 is On-line&quot;</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">        echo &quot;Host $1 is off-line&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;test_ping.sh&quot; 10L, 135C 已写入                                                                                                 </span><br><span class="line">root@tian-virtual-machine:~# bash test_ping.sh 192.168.231.134</span><br><span class="line">Host 192.168.231.134 is On-line</span><br><span class="line">root@tian-virtual-machine:~# bash test_ping.sh 192.168.231.133</span><br><span class="line">Host 192.168.231.133 is off-line</span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713215013499.png" alt="image-20200713215013499" style="zoom:80%;" /><p><strong>（2）for 条件循环语句</strong>  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713222547486.png" alt="image-20200713222547486" style="zoom:80%;" /><p><strong>例子</strong>：尝试让脚本从文本中自动读取主机列表（ip_test.txt），然后自动逐个测试这些主机是否在线。  </p><p><strong>$（命令）</strong>:执行括号或双引号括起来的命令。  </p><p><strong>/dev/null</strong> 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# vim ip_test.txt</span><br><span class="line">192.168.231.134</span><br><span class="line"></span><br><span class="line">192.168.231.135</span><br><span class="line"></span><br><span class="line">192.168.231.136</span><br><span class="line">root@tian-virtual-machine:~# vim ip_test.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">HLIST&#x3D;$(cat ip_test.txt)</span><br><span class="line">for IP in $HLIST</span><br><span class="line">do</span><br><span class="line">        ping -c 3 -i 0.2 -w 3 $IP &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">        if [ $? -eq 0 ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;HOST $IP is On-line&quot;</span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">                echo &quot;HOST $IP is off-line&quot;</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;ip_test.sh&quot; 13L, 197C 已写入                                                                                                   </span><br><span class="line">root@tian-virtual-machine:~# bash ip_test.sh</span><br><span class="line">HOST 192.168.231.134 is off-line</span><br><span class="line">HOST 192.168.231.135 is On-line</span><br><span class="line">HOST 192.168.231.136 is off-line</span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><p><strong>(3)while 条件循环语句</strong>  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713232222990.png" alt="image-20200713232222990" style="zoom:80%;" /><p><strong>例子</strong>：编写一个用来猜测数值大小的脚本 guess.sh。  </p><p><strong>$RANDOM</strong>：调取出一个随机的数值（范围为 0～32767） </p><p><strong>expr</strong>：使用 expr 命令取得$RANDOM结果  </p><p><strong>read -p</strong>：读入用户输入的信息到后面的变量（INT），-p是添加提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# vim guess.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">PRICE&#x3D;$(expr $RANDOM % 1000)</span><br><span class="line">TIMES&#x3D;0</span><br><span class="line">echo &quot;我这里有个宝贝价格在0~999之间，猜猜看是多少？&quot;</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">        read -p &quot;请输入你猜测的价格：&quot; INT</span><br><span class="line">        let TIMES++</span><br><span class="line">        if [ $INT -eq $PRICE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;恭喜你答对了！实际价格是$PRICE&quot;</span><br><span class="line">                echo &quot;你共猜了$TIMES次&quot;</span><br><span class="line">                exit 0</span><br><span class="line">        elif [ $INT -gt $PRICE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;太高了！&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;太低了！&quot;</span><br><span class="line">        fi</span><br><span class="line">done</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">&quot;guess.sh&quot; 20L, 408C 已写入                                                                                                     </span><br><span class="line">root@tian-virtual-machine:~# bash guess.sh</span><br><span class="line">我这里有个宝贝价格在0~999之间，猜猜看是多少？</span><br><span class="line">请输入你猜测的价格：500</span><br><span class="line">太低了！</span><br><span class="line">请输入你猜测的价格：750</span><br><span class="line">太低了！</span><br><span class="line">请输入你猜测的价格：875</span><br><span class="line">太高了！</span><br><span class="line">请输入你猜测的价格：812</span><br><span class="line">太低了！</span><br><span class="line">请输入你猜测的价格：840</span><br><span class="line">太低了！</span><br><span class="line">请输入你猜测的价格：858</span><br><span class="line">太高了！</span><br><span class="line">请输入你猜测的价格：850</span><br><span class="line">太低了！</span><br><span class="line">请输入你猜测的价格：854</span><br><span class="line">太高了！</span><br><span class="line">请输入你猜测的价格：852</span><br><span class="line">恭喜你答对了！实际价格是852</span><br><span class="line">你共猜了9次</span><br></pre></td></tr></table></figure><p><strong>（4）case 条件测试语句</strong>  </p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200713234812734.png" alt="image-20200713234812734" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxprobe ~]# vim Checkkeys.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;请输入一个字符，并按 Enter 键确认： &quot; KEY</span><br><span class="line">case &quot;$KEY&quot; in</span><br><span class="line">[a-z]|[A-Z])</span><br><span class="line">echo &quot;您输入的是 字母。 &quot;</span><br><span class="line">;;</span><br><span class="line">[0-9])</span><br><span class="line">echo &quot;您输入的是 数字。 &quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;您输入的是 空格、功能键或其他控制字符。 &quot;</span><br><span class="line">esac</span><br><span class="line">[root@linuxprobe ~]# bash Checkkeys.sh</span><br><span class="line">请输入一个字符，并按 Enter 键确认： 6</span><br><span class="line">您输入的是 数字。</span><br><span class="line">[root@linuxprobe ~]# bash Checkkeys.sh</span><br><span class="line">请输入一个字符，并按 Enter 键确认： p</span><br><span class="line">您输入的是 字母。</span><br><span class="line">[root@linuxprobe ~]# bash Checkkeys.sh</span><br><span class="line">请输入一个字符，并按 Enter 键确认： ^[[15~</span><br><span class="line">您输入的是 空格、功能键或其他控制字符。</span><br></pre></td></tr></table></figure><h2 id="2-5计划任务服务程序"><a href="#2-5计划任务服务程序" class="headerlink" title="2.5计划任务服务程序"></a>2.5计划任务服务程序</h2><h1 id="四、——用户身份与文件权限"><a href="#四、——用户身份与文件权限" class="headerlink" title="四、——用户身份与文件权限"></a>四、——用户身份与文件权限</h1><h2 id="1-用户身份与能力"><a href="#1-用户身份与能力" class="headerlink" title="1.用户身份与能力"></a>1.用户身份与能力</h2><h3 id="1-1-useradd-命令"><a href="#1-1-useradd-命令" class="headerlink" title="1.1 useradd 命令"></a>1.1 useradd 命令</h3><p>useradd 命令用于创建新的用户，格式为“useradd [选项] 用户名”。  </p><div align="center">useradd 命令中的用户参数以及作用</div><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>指定用户的家目录（默认为/home/username）</td></tr><tr><td>-e</td><td>账户的到期时间，格式为 YYYY-MM-DD.</td></tr><tr><td>-u</td><td>指定该用户的默认 UID</td></tr><tr><td>-g</td><td>指定一个初始的用户基本组（必须已存在）</td></tr><tr><td>-G</td><td>指定一个或多个扩展用户组</td></tr><tr><td>-N</td><td>不创建与用户同名的基本用户组</td></tr><tr><td>-s</td><td>指定该用户的默认 Shell 解释器</td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# useradd -d &#x2F;tian&#x2F;zhu zhu</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhu</span><br><span class="line">uid&#x3D;1001(zhu) gid&#x3D;1001(zhu) 组&#x3D;1001(zhu)</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian#</span><br></pre></td></tr></table></figure><h3 id="1-2-groupadd-命令"><a href="#1-2-groupadd-命令" class="headerlink" title="1.2 groupadd 命令"></a>1.2 groupadd 命令</h3><p>groupadd 命令用于创建用户组，格式为“groupadd [选项] 群组名”。  </p><h3 id="1-3usermod-命令"><a href="#1-3usermod-命令" class="headerlink" title="1.3usermod 命令"></a>1.3usermod 命令</h3><p>usermod 命令用于修改用户的属性，格式为“usermod [选项] 用户名”。  </p><div align="center">usermod 命令中的参数及作用 </div><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>填写用户账户的备注信息</td></tr><tr><td>-d -m</td><td>参数-m 与参数-d 连用，可重新指定用户的家目录并自动把旧的数据转移过去</td></tr><tr><td>-e</td><td>账户的到期时间，格式为 YYYY-MM-DD</td></tr><tr><td>-g</td><td>变更所属用户组</td></tr><tr><td>G</td><td>变更扩展用户组</td></tr><tr><td>-L</td><td>锁定用户禁止其登录系统</td></tr><tr><td>-U</td><td>解锁用户，允许其登录系统</td></tr><tr><td>-s</td><td>变更默认终端</td></tr><tr><td>-u</td><td>修改用户的 UID</td></tr></tbody></table><p><strong>例子</strong>：把用户zhu添加到root组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# usermod -G root zhu</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhu</span><br><span class="line">uid&#x3D;1001(zhu) gid&#x3D;1001(zhu) 组&#x3D;1001(zhu),0(root)</span><br></pre></td></tr></table></figure><h3 id="1-4passwd-命令"><a href="#1-4passwd-命令" class="headerlink" title="1.4passwd 命令"></a>1.4passwd 命令</h3><p>passwd 命令用于修改用户密码、过期时间、认证信息等，格式为“passwd [选项] [用户名]”。  </p><div align="center">usermod 命令中的参数以及作用 </div><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-l</td><td>锁定用户，禁止其登录</td></tr><tr><td>-u</td><td>解除锁定，允许用户登录</td></tr><tr><td>–stdin</td><td>允许通过标准输入修改用户密码，如 echo “NewPassWord” | passwd –stdin Username</td></tr><tr><td>-d</td><td>使该用户可用空密码登录系统</td></tr><tr><td>-e</td><td>强制用户在下次登录时修改密码</td></tr><tr><td>-S</td><td>显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td></tr></tbody></table><h3 id="1-5userdel-命令"><a href="#1-5userdel-命令" class="headerlink" title="1.5userdel 命令"></a>1.5userdel 命令</h3><p>userdel 命令用于删除用户，格式为“userdel [选项] 用户名”  。</p><div align="center">userdel 命令的参数以及作用 </div><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-f</td><td>强制删除用户</td></tr><tr><td>-r</td><td>同时删除用户及用户家目录</td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# userdel zhu</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhu</span><br><span class="line">id: &quot;zhu&quot;: no such user</span><br></pre></td></tr></table></figure><h2 id="2-文件权限与归属"><a href="#2-文件权限与归属" class="headerlink" title="2.文件权限与归属"></a>2.文件权限与归属</h2><p>在 Linux 系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。    </p><p>文件的读、写、执行权限可以简写为 rwx，亦可分别用数字 4、 2、 1 来表示  。例如，若某个文件的权限为 7 则代表可读、可写、可执行（4+2+1）；若权限为 6 则代表可读、可写（4+2）。  </p><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -l tian.txt</span><br><span class="line">-rw-rw-r-- 1 tian tian 14 7月  11 14:20 tian.txt</span><br></pre></td></tr></table></figure><p>这里表示文件的所有者、所有组以及其他人对tian.txt的权限分别是读写、读写、读。</p><h2 id="3-文件的特殊权限"><a href="#3-文件的特殊权限" class="headerlink" title="3.文件的特殊权限"></a>3.文件的特殊权限</h2><h3 id="3-1-SUID"><a href="#3-1-SUID" class="headerlink" title="3.1 SUID"></a>3.1 SUID</h3><p>SUID 可以让二进制程序的执行者临时拥有属主的权限 （就是root） </p><p>平时用户的密码是存储在shadow文件中，通过查看可以发现，其他人对shadow三个权限都没有，那普通用户为什么可以通过passwd命令更改自己的密码呢？就是因为在passwd加上了SUID 特殊权限位  ，这样就可以使得普通用户在使用passwd命令时暂时地获得root权限，进行密码更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# ls -l &#x2F;etc&#x2F;shadow</span><br><span class="line">-rw-r----- 1 root shadow 1393 7月  14 23:26 &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><h3 id="3-2-SGID"><a href="#3-2-SGID" class="headerlink" title="3.2 SGID"></a>3.2 SGID</h3><p>SGID和SUID很像，只是SGID临时获得的是组的全线</p><p>SGID 主要实现如下两种功能：</p><blockquote><p><strong>(1)</strong>让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）。<br><strong>(2)</strong>在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。</p></blockquote><p>  <strong>功能（1）例子</strong>：创建public_tian目录，并且更改目录权限</p><p>下面用到<strong>chmod</strong> 命令，能够用来设置文件或目录的权限，格式为“chmod [参数] 权限 文件或目录名称”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建public_tian目录</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# mkdir public_tian</span><br><span class="line"># 查看权限</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tian</span><br><span class="line">drwxr-xr-x 2 root root 4096 7月  15 13:08 public_tian</span><br><span class="line"># 更改目录的权限为777，即rwxrwxrwx，</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chmod -Rf 777 public_tian</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tian</span><br><span class="line">drwxrwxrwx 2 root root 4096 7月  15 13:08 public_tian</span><br><span class="line"># 添加SGID权限位</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chmod -Rf g+s public_tian</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tian</span><br><span class="line">drwxrwsrwx 2 root root 4096 7月  15 13:08 public_tian</span><br></pre></td></tr></table></figure><p><strong>功能（2）例子</strong>：</p><p>使用命令为 chown，其格式为“chown [参数] 所有者:所属组 文件或目录名称”。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home# ls -ald zhu</span><br><span class="line">drwxrwxrwx 2 root root 4096 7月  15 14:02 zhu</span><br><span class="line"># 将目录zhu的所有者和所属组更改为zhu</span><br><span class="line">root@tian-virtual-machine:&#x2F;home# chown zhu:zhu &#x2F;home&#x2F;zhu</span><br><span class="line">root@tian-virtual-machine:&#x2F;home# ls -ald zhu</span><br><span class="line">drwxrwxrwx 2 zhu zhu 4096 7月  15 14:02 zhu</span><br></pre></td></tr></table></figure><h3 id="3-3-SBIT"><a href="#3-3-SBIT" class="headerlink" title="3.3 SBIT"></a>3.3 SBIT</h3><p>SBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。  </p><p>想对其他目录来设置 SBIT 特殊权限位，用 chmod 命令就可以了。对应的参数 o+t 代表设置 SBIT 粘滞位权限  </p><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;zhu# ls -ald new</span><br><span class="line">drwxr-xr-x 2 root root 4096 7月  15 14:50 new</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;zhu# chmod -R o+t new</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;zhu# ls -ald new</span><br><span class="line">drwxr-xr-t 2 root root 4096 7月  15 14:50 new</span><br></pre></td></tr></table></figure><h2 id="4-文件的隐藏属性"><a href="#4-文件的隐藏属性" class="headerlink" title="4.文件的隐藏属性"></a>4.文件的隐藏属性</h2><h3 id="4-1-chattr-命令"><a href="#4-1-chattr-命令" class="headerlink" title="4.1 chattr 命令"></a>4.1 chattr 命令</h3><p>chattr 命令用于设置文件的隐藏权限，格式为“chattr [参数] 文件”。  </p><p>如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。  </p><div align="center">chattr 命令中用于隐藏权限的参数及其作用   </div><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而 不能新建或删除文件</td></tr><tr><td>a</td><td>仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）</td></tr><tr><td>S</td><td>文件内容在变更后立即同步到硬盘（sync）</td></tr><tr><td>s</td><td>彻底从硬盘中删除，不可恢复（用 0 填充原文件所在硬盘区域）</td></tr><tr><td>A</td><td>不再修改这个文件或目录的最后访问时间（atime）</td></tr><tr><td>b</td><td>不再修改文件或目录的存取时间</td></tr><tr><td>D</td><td>检查压缩文件中的错误</td></tr><tr><td>d</td><td>使用 dump 命令备份时忽略本文件/目录</td></tr><tr><td>c</td><td>默认将文件或目录进行压缩</td></tr><tr><td>u</td><td>当删除该文件后依然保留其在硬盘中的数据，方便日后恢复</td></tr><tr><td>t</td><td>让文件系统支持尾部合并（tail-merging）</td></tr><tr><td>X</td><td>可以直接访问压缩文件中的内容</td></tr></tbody></table><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看目录，tian.txt存在</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls</span><br><span class="line">hh.txt  public_tian  tian  tiana.sh  tian.gz  tian.txt  users_test.txt  zhu  公共的  模板  视频  图片  文档  下载  音乐  桌面</span><br><span class="line"># 使用chattr给tian.txt添加+a参数</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr +a tian.txt</span><br><span class="line"># 尝试删除，无法删除</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# rm tian.txt</span><br><span class="line">rm: 无法删除&#39;tian.txt&#39;: 不允许的操作</span><br><span class="line"># 利用-a参数将限制去掉</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr -a tian.txt</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# rm tian.txt</span><br><span class="line"># 查看目录，tian.txt已经被删除</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls</span><br><span class="line">hh.txt  public_tian  tian  tiana.sh  tian.gz  users_test.txt  zhu  公共的  模板  视频  图片  文档  下载  音乐  桌面</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian#</span><br></pre></td></tr></table></figure><h3 id="4-2-lsattr-命令"><a href="#4-2-lsattr-命令" class="headerlink" title="4.2 lsattr 命令"></a>4.2 lsattr 命令</h3><p>lsattr 命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”。  </p><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# touch tian.txt</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr +a tian.txt</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# lsattr tian.txt</span><br><span class="line">-----a--------e--- tian.txt</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr -a tian.txt</span><br><span class="line">root@tian-virtual-machine:&#x2F;home&#x2F;tian# lsattr tian.txt</span><br><span class="line">--------------e--- tian.txt</span><br></pre></td></tr></table></figure><h2 id="5-文件访问控制列表"><a href="#5-文件访问控制列表" class="headerlink" title="5.文件访问控制列表"></a>5.文件访问控制列表</h2><p>如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。  </p><h3 id="5-1-setfacl-命令"><a href="#5-1-setfacl-命令" class="headerlink" title="5.1 setfacl 命令"></a>5.1 setfacl 命令</h3><ul><li><p>setfacl 命令用于管理文件的 ACL 规则，格式为“setfacl [参数] 文件名称”。  </p></li><li><p>使用 setfacl 命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。  </p></li><li><p>针对目录文件需要使用-R 递归参数；针对普通文件则使用-m 参数；如果想要删除某个文件的 ACL，则可以使用-b 参数。  </p></li></ul><h3 id="5-2-getfacl-命令"><a href="#5-2-getfacl-命令" class="headerlink" title="5.2 getfacl 命令"></a>5.2 getfacl 命令</h3><p>getfacl 命令用于显示文件上设置的 ACL 信息，格式为“getfacl 文件名称”。  </p><p><strong>例子</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# getfacl &#x2F;home&#x2F;tian&#x2F;zhu</span><br><span class="line">getfacl: 从绝对路径名尾部去除&quot; &#x2F; &quot;字符。</span><br><span class="line"># file: home&#x2F;tian&#x2F;zhu</span><br><span class="line"># owner: root</span><br><span class="line"># group: root</span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><h2 id="6-su-命令与-sudo-服务"><a href="#6-su-命令与-sudo-服务" class="headerlink" title="6. su 命令与 sudo 服务"></a>6. su 命令与 sudo 服务</h2><h3 id="6-1-su-命令"><a href="#6-1-su-命令" class="headerlink" title="6.1 su 命令"></a>6.1 su 命令</h3><p>su 命令可以切换用户身份，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从 root 管理员切换至普通用户：</p><p><strong>例子</strong>：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@tian-virtual-machine:~# su - zhu</span><br><span class="line">$ su - root</span><br><span class="line">密码： </span><br><span class="line">root@tian-virtual-machine:~#</span><br></pre></td></tr></table></figure><p>上面的 su 命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。  </p><h3 id="6-2-sudo-服务"><a href="#6-2-sudo-服务" class="headerlink" title="6.2 sudo 服务"></a>6.2 sudo 服务</h3><p>普通用户可以完全切换到 root 管理员身份来完成相应工作，但这将暴露 root 管理员的密码，从而增大了系统密码被黑客获取的几率；这并不是最安全的方案。  </p><p>sudo 命令用于给普通用户提供额外的权限来完成原本 root 管理员才能完成的任务，格式为“sudo [参数] 命令名称”。  </p><div align="center"> sudo 服务中的可用参数以及作用 </div>  <table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-h</td><td>列出帮助信息</td></tr><tr><td>-l</td><td>列出当前用户可执行的命令</td></tr><tr><td>-u 用户名或 UID 值</td><td>以指定的用户身份执行命令</td></tr><tr><td>-k</td><td>清空密码的有效时间，下次执行 sudo 时需要再次进行密码验证</td></tr><tr><td>-b</td><td>在后台执行指定的命令</td></tr><tr><td>-p</td><td>更改询问密码的提示语</td></tr></tbody></table><h1 id="五、存储结构与磁盘划分"><a href="#五、存储结构与磁盘划分" class="headerlink" title="五、存储结构与磁盘划分"></a>五、存储结构与磁盘划分</h1><h2 id="1-常见的目录"><a href="#1-常见的目录" class="headerlink" title="1.常见的目录"></a>1.常见的目录</h2><div align="center"> Linux 系统中常见的目录名称以及相应内容  </div><table><thead><tr><th>目录名称</th><th>应放置文件的内容</th></tr></thead><tbody><tr><td>/boot</td><td>开机所需文件—内核、开机菜单以及所需配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放任何设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的目录</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的“共享”临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux 系统开机时不会使用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放经常变化的文件，如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td></tr></tbody></table><ul><li>绝对路径指的是从根目录（/）开始写起的文件或目录名称</li></ul><h2 id="2-物理设备的命名规则"><a href="#2-物理设备的命名规则" class="headerlink" title="2.物理设备的命名规则"></a>2.物理设备的命名规则</h2><div align="center">常见的硬件设备及其文件名称  </div><table><thead><tr><th>硬件设备</th><th>文件名称</th></tr></thead><tbody><tr><td>IDE 设备</td><td>/dev/hd[a-d]</td></tr><tr><td>SCSI/SATA/U 盘</td><td>/dev/sd[a-p]</td></tr><tr><td>软驱</td><td>/dev/fd[0-1]</td></tr><tr><td>打印机</td><td>/dev/lp[0-15]</td></tr><tr><td>光驱</td><td>/dev/cdrom</td></tr><tr><td>鼠标</td><td>/dev/mouse</td></tr><tr><td>磁带机</td><td>/dev/st0 或/dev/ht0</td></tr></tbody></table><h2 id="3-文件系统与数据资料"><a href="#3-文件系统与数据资料" class="headerlink" title="3.文件系统与数据资料"></a>3.文件系统与数据资料</h2><p>这一章剩下的暂时省略，学下面的先</p><h1 id="七、——使用-RAID-与-LVM-磁盘阵列技术"><a href="#七、——使用-RAID-与-LVM-磁盘阵列技术" class="headerlink" title="七、——使用 RAID 与 LVM 磁盘阵列技术"></a>七、——使用 RAID 与 LVM 磁盘阵列技术</h1><p>也先省略</p><h1 id="第八章——iptables-与-firewalld-防火墙"><a href="#第八章——iptables-与-firewalld-防火墙" class="headerlink" title="第八章——iptables 与 firewalld 防火墙"></a>第八章——iptables 与 firewalld 防火墙</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo问题解决</title>
      <link href="/2020/09/06/Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/06/Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<div align="center">这里有一些hexo功能的使用方法以及注意点（我踩过的坑...）</div><a id="more"></a><h1 id="1-如何给文章添加标签"><a href="#1-如何给文章添加标签" class="headerlink" title="1.如何给文章添加标签"></a>1.如何给文章添加标签</h1><h2 id="1-1-方法一"><a href="#1-1-方法一" class="headerlink" title="1.1 方法一"></a>1.1 方法一</h2><h2 id="1-2-方法二"><a href="#1-2-方法二" class="headerlink" title="1.2 方法二"></a>1.2 方法二</h2><p><strong>建立一个标签配置文件</strong></p><blockquote><p>在博客文件夹下，执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>执行后，会在source文件夹里创建一个tags文件夹，tags文件夹里会生成一个index.md文件，这个文件是用来配置你的标签的，文件内容参考下面的样例进行更改</p><p><strong>注意</strong>：冒号“:”后面要有一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 博客搭建与运营</span><br><span class="line">date: 2020-07-05 01:04:45</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>如上所示，<strong>title</strong>对应你的标签名，你想要啥名字就写啥。<strong>type: “tags”</strong>是用来说明这是在配置标签的，不要改动。</p></blockquote><p><strong>给文章添加标签</strong></p><blockquote><p>打开文章，在文章开头添加下列文本。这里的tags后面就是你希望这个文章打上的标签名</p><p><strong>注意</strong>：冒号“:”后面要有一个空格，不然“tags: [博客搭建与运营]”会被当成文章内容显示，并且不会归类到[博客搭建与运营]标签上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tags: [博客搭建与运营]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="2-github打不开"><a href="#2-github打不开" class="headerlink" title="2. github打不开"></a>2. github打不开</h1><p><strong>事情是这样的：</strong>本来博客是好好的，但是突然有一天我发现博客打不开了，错误提示如下：</p><p><strong>谷歌浏览器：</strong></p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200907152640300.png" alt="image-20200907152640300" style="zoom: 80%;" /><p><strong>搜狗浏览器：</strong></p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200907152229038.png" alt="image-20200907152229038"></p><p>后来发现，把电脑的DNS服务器地址改为某些地址时，博客就可以打开，例如：<code>1.1.1.1</code>。通过让朋友尝试发现，有的网络可以打开，有的不行。基于此，虽然不知道具体原因，但是知道大概是一些运营商网络无法访问到github服务器。于是，我找到了一个解决方法：<strong>使用<a href="https://vercel.com/" target="_blank" rel="noopener">vercel</a>进行间接访问</strong></p><p>教程在这篇博客：<a href="https://colsrch.top/posts/56951997/index.html#%E8%81%94%E9%80%9A%E7%BA%BF%E8%B7%AF" target="_blank" rel="noopener">点这里</a></p><p>说明：</p><p><strong>1.</strong>qq邮箱无法注册vercel,163邮箱和谷歌邮箱都可以，因此，如果你的github绑定的是你的qq邮箱，需要去github官网把邮箱换一下。</p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200907155607549.png" alt="image-20200907155607549" style="zoom: 67%;" /><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200907155939926.png" alt="image-20200907155939926" style="zoom:67%;" /><p>添加邮箱并设置为主要邮箱之后就可以使用github账号注册了。</p><p><strong>2.</strong>如果没有自己的域名的话，那做完Deploy那一步也就可以了，之后，你就可以使用 <code>vercel项目名.vercel.app</code>进行访问你的博客了。之后你更新博客的话，一样是把你的博客推到github仓库，vercel会自动部署。</p><h1 id="3-如何在一台电脑使用2个github账号部署2个博客"><a href="#3-如何在一台电脑使用2个github账号部署2个博客" class="headerlink" title="3.如何在一台电脑使用2个github账号部署2个博客"></a>3.如何在一台电脑使用2个github账号部署2个博客</h1><p>请转至另一篇博客，<a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" target="_blank" rel="noopener">点这里</a></p><h1 id="4-博客里某一篇文章打不开"><a href="#4-博客里某一篇文章打不开" class="headerlink" title="4. 博客里某一篇文章打不开"></a>4. 博客里某一篇文章打不开</h1><p>我曾经出现过这个问题，后来发现是文章的文件名（是文件名，不是文章的title）包含了特殊字符导致的（比如<code>+</code>），把文件名的一些特殊字符去掉就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建与运营 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome here</title>
      <link href="/2020/09/06/hello-world/"/>
      <url>/2020/09/06/hello-world/</url>
      
        <content type="html"><![CDATA[<div align="center">————欢迎来到我的博客~————</di<a id="more"></a><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/wallls.com_220462.jpg"  style="zoom:50%;" /><div align="center"> 愿你乘风破浪，踏遍黄沙海洋 </div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++面试常见题目</title>
      <link href="/2020/09/06/cpp%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/06/cpp%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<div align="center">一些c++面试常见题目，包括基础知识点，操作系统，计算机网络等</div><a id="more"></a><h1 id="一、常见（典型）题目"><a href="#一、常见（典型）题目" class="headerlink" title="一、常见（典型）题目"></a>一、常见（典型）题目</h1><h2 id="1-写出strcpy函数"><a href="#1-写出strcpy函数" class="headerlink" title="1.写出strcpy函数"></a>1.写出strcpy函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">( <span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert((strDest!=<span class="literal">NULL</span>)&amp;&amp;(strSrc!=<span class="literal">NULL</span>));<span class="comment">//如果assert函数括号里的结果是0，终止程序。</span></span><br><span class="line">    <span class="keyword">char</span> *address=strDest;</span><br><span class="line">    <span class="keyword">while</span>((* strDest++=* strSrc)!=<span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-字符串循环右移"><a href="#2-字符串循环右移" class="headerlink" title="2.字符串循环右移"></a>2.字符串循环右移</h2><p>编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefg” 函数头是这样的：<br>//pStr是指向以’\0’结尾的字符串的指针<br>//steps是要求移动的n </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoopMove</span><span class="params">(<span class="keyword">char</span> *pStr,<span class="keyword">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(pStr)-steps;</span><br><span class="line">    <span class="keyword">char</span> tmp[MAX_LEN];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp,pStr+n);</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp+steps,pStr);</span><br><span class="line">    *(tmp+<span class="built_in">strlen</span>(pStr))=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(pStr,tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-判断一个数是否为2的倍数"><a href="#3-判断一个数是否为2的倍数" class="headerlink" title="3.判断一个数是否为2的倍数"></a>3.判断一个数是否为2的倍数</h2><p>可以用：a % 2 == 0 或者a &amp; 0x0001 == 0</p><p>（0x0001是16进制数，换算成二进制是0000000000000001,）</p><h1 id="二、C-知识点"><a href="#二、C-知识点" class="headerlink" title="二、C++知识点"></a>二、C++知识点</h1><h2 id="1-c语言地址"><a href="#1-c语言地址" class="headerlink" title="1.c语言地址"></a>1.c语言地址</h2><p>现在的电脑普遍是64位的，所以地址64位的，也就是占用8个字节</p><p>一般用16进制表示，表示为ox00000000~oxffffffff</p><h2 id="2-内存对齐"><a href="#2-内存对齐" class="headerlink" title="2.内存对齐"></a>2.内存对齐</h2><p>内存对齐是什么：</p><p>先看个例子</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210125224725968.png" alt="image-20210125224725968"></p><p>可以看到，A和B中的成员是相同的，但是占用的长度不一样，A是24，B是16。原因就是内存对齐。</p><p><strong>内存对齐规则：</strong></p><p>(1)  结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小</strong>与<strong>有效对齐值（一般为4）</strong>中较小那个的整数倍。如有需要编译器会在成员之间加上填充字节。</p><p>(2)  <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>。如有需要编译器会在最末一个成员之后加上填充字节。</p><p>示例：</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">short b;</span><br><span class="line">&#125;A;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">short b;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;B;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>解释：对于A，a占用0<del>3，b因为规则（1）占用4，但是因为规则（2），现在总长度为5，不是4的倍数，所以会把5,6,7填充，所以A是占用8。对于B，b占用0，但是因为a是int，占用4字节，所以根据规则（1），1</del>3会被填充，a占用4~7。所以B长度也是8</p><h2 id="3-malloc使用注意"><a href="#3-malloc使用注意" class="headerlink" title="3.malloc使用注意"></a>3.malloc使用注意</h2><p>（1）使用malloc申请之后应该使用if语句判断内存是否申请成功。</p><p>（2）使用完malloc之后应该使用free函数进行释放</p><p>（3）free（p）之后，需要让p=NULL，避免p成为野指针（也就是指向的方向不确定的指针）。</p><h2 id="4-float与零值比较"><a href="#4-float与零值比较" class="headerlink" title="4. float与零值比较"></a>4. float与零值比较</h2><p>float与零值比较并不能像int类型那样直接用if(a==0)。因为float类型是有精度的，一个float类型的数有可能是0.00000001，如果直接用<code>==</code>来比较，得到的结果是不等于0，但是按照实际情况，0.00000001可以当做0了，所以float与零值比较应该使用比较的方式，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> EPSINON = <span class="number">0.00001</span>;<span class="comment">//EPSINON是用来表示精度的，不一定是0.00001</span></span><br><span class="line"><span class="keyword">if</span> ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)</span><br></pre></td></tr></table></figure><p>因此，比较两个float类型的变量是否相等，也应该用两个变量相减然后与EPSINON对比。</p><h2 id="5-extern-“C”的作用"><a href="#5-extern-“C”的作用" class="headerlink" title="5.extern “C”的作用"></a>5.extern “C”的作用</h2><p>因为C++支持函数重载，其原理就是编译器会在编译的时候根据函数的含函数名以及参数来命名函数。比如，<code>int add(int a,int b)</code>这个函数编译后的名字可能是_addii。</p><p>但是，在c语言中，没有函数重载，所以c语言的编译器上面那个函数的名字可能就是_add。因此，假如在c++项目中，使用了gcc（c语言编译器，不会考虑函数重载）编译的C模块，就会出现连接错误，因为链接器会去C模块中寻找 _addii,但是在C模块中，因为是使用了gcc编译，没有 _addii，它有的只是 _add,最终导致链接错误。</p><p>所以，如果我们在C++项目中使用gcc编译的C模块，就应该使用extern “C” </p><h2 id="6-const作用"><a href="#6-const作用" class="headerlink" title="6.const作用"></a>6.const作用</h2><p>1.使用const关键字定义变量，就类似宏定义，初始化之后，变量的值就无法改变了。</p><p>2.对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const。</p><p>3.在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。</p><p>4.可以定义类的成员函数为常函数，常函数不可以修改类的成员变量。</p><p>5.可以定义常对象。常对象不允许修改成员属性，也不可以调用普通成员函数</p><h2 id="7-static作用"><a href="#7-static作用" class="headerlink" title="7.static作用"></a>7.static作用</h2><p>1.<strong>定义全局静态变量：</strong>全局静态变量在声明它的文件之外是不可见的，也就是作用域只在声明它的文件里</p><p><strong>2.定义局部静态变量：</strong>作用域仍然是局部的，但是在离开作用域后，局部静态变量并没有销毁，等到函数再度调用的时候，局部静态变量的值不变</p><p><strong>3.定义静态函数</strong>：静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p><p><strong>4.定义类的静态成员</strong>：某个类的某个成员变量如果是静态成员，那么这个类的所有对象的静态成员值都是相等的。</p><p><strong>5.定义类的静态函数</strong>：类的静态函数不能直接引用类中的非静态成员。</p><h2 id="8-c-中的四种类型转换"><a href="#8-c-中的四种类型转换" class="headerlink" title="8.c++中的四种类型转换"></a>8.c++中的四种类型转换</h2><p><strong>1.dynamic_cast</strong></p><p>使得能够在类层次结构中进行向上转换（向上转换是由子类转换为基类），而 不允许其他转换。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这行代码要合法的话，需要满足：假设 High 和 Low 是 两个 类， 而 ph 和 pl 的 类型 分别为 High* 和 Low*， 则 仅 当 Low 是 High 的 可 访问 基 类（ 直接 或 间接） 时 */</span></span><br><span class="line">pl = dynamic_ cast&lt; Low *&gt; ph;</span><br></pre></td></tr></table></figure><p><strong>2.const_cast</strong></p><p>用于将const变量转为非const。如果类型的其他方面也被修改了，类型转换就会出错（也就是不合法的,转不了)</p><p><strong>3.static_cast</strong></p><p>用于各种隐式转换。比如基类和子类指针之间的转换，double和int之间的转换。</p><p><strong>4.reinterpret_cast</strong></p><p>可以进行很多转换，比如讲指针类型转换为足以存放指针表示的整型。</p><h2 id="9-指针和引用的区别"><a href="#9-指针和引用的区别" class="headerlink" title="9.指针和引用的区别"></a>9.指针和引用的区别</h2><p>1.指针有自己的一块空间，而引用只是一个别名。</p><p>2.指针在使用中可以改变指向，但是引用只能是一个对象的引用，无法改变。</p><p>3.指针可以有多级指针，但是引用只有一级。</p><h2 id="10-智能指针"><a href="#10-智能指针" class="headerlink" title="10.智能指针"></a>10.智能指针</h2><p><strong>（1）四个智能指针</strong></p><p>智能指针（Smart Pointer）本质是一个类，行为类似普通指针，都可以解引用。它把指向对象的普通指针和对象的内存管理封装起来，自动管理对象的生存期。它们可以自动处理内存分配和释放问题，避免空悬指针，野指针，内存泄露，分配内存失败等问题，</p><p>四个指针指针是：auto_ptr,unique_ptr,shared_ptr,weak_ptr</p><p><strong>auto_ptr</strong>在c++11中已经被废弃。</p><p><strong>unique_ptr</strong>只允许一根指针“独占式”地指向所指对象。</p><p><strong>shared_ptr</strong>允许多个指针指向同一个对象。</p><p><strong>weak_ptr</strong> 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。</p><p><strong>（2）智能指针有没有内存泄露的情况</strong></p><p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p><p><strong>（3）智能指针的内存泄漏如何解决</strong></p><p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h2 id="11-虚析构函数"><a href="#11-虚析构函数" class="headerlink" title="11.虚析构函数"></a>11.虚析构函数</h2><p><strong>虚析构函数的作用？</strong></p><p>在对父类的析构没使用<code>virtual</code>关键字时，是普通析构，普通析构是不会调用子类的析构函数的。如果一个类的析构函数是虚析构函数，当它作为父类时，释放父类指针，子类的析构函数也会被调用，从而释放掉子类的空间，防止内存泄漏。</p><p><strong>为什么C++默认的析构函数不是虚函数？</strong></p><p>因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。</p><h2 id="12-函数指针"><a href="#12-函数指针" class="headerlink" title="12.函数指针"></a>12.函数指针</h2><p>函数指针就是指向函数的指针变量。函数被编译时会有入口地址，函数指针就是指向这个入口地址的。</p><h2 id="13-map和set"><a href="#13-map和set" class="headerlink" title="13.map和set"></a>13.map和set</h2><h2 id="14-C-中struct和class"><a href="#14-C-中struct和class" class="headerlink" title="14.C++中struct和class"></a>14.C++中struct和class</h2><p><strong>区别</strong>：struct的默认继承权限和默认访问权限是public的。class的默认继承权限和默认访问权限是private的。</p><p>另外class关键字还可以用来定义模板的形参。</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void fun(T &amp;a,T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    tmp&#x3D;a;</span><br><span class="line">    a&#x3D;b;</span><br><span class="line">    b&#x3D;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-include后的“-”与-lt-gt-的区别"><a href="#15-include后的“-”与-lt-gt-的区别" class="headerlink" title="15.include后的“ ”与&lt;&gt;的区别"></a>15.include后的“ ”与&lt;&gt;的区别</h2><p>1、使用尖括号的话，编译时会先在系统include目录里搜索，如果找不到才会在源代码所在目录搜索。</p><p>2、使用双引号则相反，会先在源代码目录里搜索，如果未找到则去系统默认目录查找，通常用于包含程序作者编写的头文件。</p><p>这就意味着，当系统里（如/usr/include/里）有一个叫做math.h的头文件，而你的源代码目录里也有一个你自己写的math.h头文件，那么使用尖括号时用的就是系统里的；而使用双引号的话则会使用你自己写的那个。</p><h2 id="16-C-的内存管理"><a href="#16-C-的内存管理" class="headerlink" title="16.C++的内存管理"></a>16.C++的内存管理</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p><p><strong>代码段</strong>：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码（也就是高级语言代码编译后的代码）。</p><p><strong>数据段</strong>：存储程序中<u><strong>已初始</strong></u>化的全局变量和静态变量</p><p><strong>bss 段</strong>：存储<strong>未初始化</strong>的全局变量和静态变量（局部+全局），以及所有被<strong>初始化为0</strong>的全局变量和静态变量。</p><p><strong>堆区</strong>：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p><p><strong>映射区</strong>：存储动态链接库以及调用mmap函数进行的文件映射</p><p><strong>栈</strong>：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p><h2 id="17-如何判断内存泄漏？"><a href="#17-如何判断内存泄漏？" class="headerlink" title="17.如何判断内存泄漏？"></a>17.如何判断内存泄漏？</h2><p>1.可以使用linux环境下的内存泄漏检查工具Valgrind。</p><p>2.写代码时可以添加内存申请的释放的计数功能，看看当前申请和释放的内存是否一致。</p><h2 id="18-段错误"><a href="#18-段错误" class="headerlink" title="18.段错误"></a>18.段错误</h2><p>段错误就是指访问的内存超出了系统所给这个程序的内存空间。</p><p>段错误通常发生在访问非法内存地址的时候，比如使用野指针、试图修改字符串常量的内容</p><h2 id="19-new和malloc的区别"><a href="#19-new和malloc的区别" class="headerlink" title="19.new和malloc的区别"></a>19.new和malloc的区别</h2><p>1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</p><p>2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</p><p>3、new不仅分配一段内存，而且会调用构造函数，malloc不会。</p><p>4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</p><p>5、new是一个操作符可以重载，malloc是一个库函数。</p><p>6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</p><p>7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</p><p>8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</p><h2 id="20-说一下静态函数和虚函数的区别"><a href="#20-说一下静态函数和虚函数的区别" class="headerlink" title="20.说一下静态函数和虚函数的区别"></a>20.说一下静态函数和虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p><h2 id="21-编译与连接"><a href="#21-编译与连接" class="headerlink" title="21.编译与连接"></a>21.编译与连接</h2><p>事实上，C语言的编译都可以分解为4个步骤，分别为预编译（Preprocess），编译（Compilation），汇编（Assembly）和链接（Linking）。</p><ul><li><strong>预编译</strong>：主要处理那些源代码中以“#”开始的预编译指令，比如#include，#define，以及条件编译##if，#ifdef，#elif，#else，#endfi。</li><li><strong>编译</strong>：编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后产生相应的汇编代码文件，这个过程往往是我们所说的最核心也最复杂的部分。</li><li><strong>汇编</strong>：汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。</li><li><strong>链接</strong>：简单来说，就是把一个项目中的各个文件或者一个文件中的各个函数，把它们链接起来成为一个独立的函数。</li></ul><h1 id="三、操作系统知识点"><a href="#三、操作系统知识点" class="headerlink" title="三、操作系统知识点"></a>三、操作系统知识点</h1><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h2><p><strong>1.说一下进程和线程的概念</strong></p><p>进程是对运行时程序的封装，也就是程序一次执行过程。进程是系统资源分配的基本单位。</p><p>线程是进程的子任务，可以理解为轻量化进程。是CPU调度的基本单位。</p><p><strong>2.进程和线程的区别</strong></p><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3.进程是资源分配的最小单位，线程是CPU调度的最小单位；</p><p>4.创建、切换、撤销进程导致的系统开销比线程要大。</p><p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p><p>6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p><p>7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p><p>8.进程适应于多核、多机分布；线程适用于多核</p><h2 id="2-说一说操作系统中的缺页中断"><a href="#2-说一说操作系统中的缺页中断" class="headerlink" title="2.说一说操作系统中的缺页中断"></a>2.说一说操作系统中的缺页中断</h2><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。就会触发缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><h2 id="3-说一说并发和并行"><a href="#3-说一说并发和并行" class="headerlink" title="3.说一说并发和并行"></a>3.说一说并发和并行</h2><p><strong>并发</strong>：指两个或者多个时间在同一时间间隔内发生，在宏观上这些事情是同时发生的，但是在微观中，这些事情是交替发生的。</p><p><strong>并行</strong>：指两个或者多个事件同一时刻发生。</p><h2 id="4-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#4-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="4.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>4.线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h2><p>线程在切换的过程中需要保存当前线程Id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址</p><p>PC:程序计数器，存储下一条将要执行的指令</p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p><h2 id="5-说一下多进程和多线程的使用场景"><a href="#5-说一下多进程和多线程的使用场景" class="headerlink" title="5.说一下多进程和多线程的使用场景"></a>5.说一下多进程和多线程的使用场景</h2><p>多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p><p>多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p><h2 id="6-发生死锁的条件以及如何解决死锁"><a href="#6-发生死锁的条件以及如何解决死锁" class="headerlink" title="6.发生死锁的条件以及如何解决死锁"></a>6.发生死锁的条件以及如何解决死锁</h2><p><strong>死锁发生的条件</strong>：</p><p>1.互斥：某个资源只能被互斥地访问</p><p>2.不可剥夺：进程获得的资源在未使用完之前不可被剥夺，只能进程主动释放</p><p>3.请求和保持：进程已经保持至少一个资源，并且对其他资源提出申请，而且该资源被其他进程占用了</p><p>4.循环等待：存在一种资源的循环等待链</p><p><strong>如何解决死锁</strong>：</p><p>可以使用银行家算法避免死锁的产生</p><h2 id="7-说一说操作系统中的结构体对齐，字节对齐"><a href="#7-说一说操作系统中的结构体对齐，字节对齐" class="headerlink" title="7.说一说操作系统中的结构体对齐，字节对齐"></a>7.说一说操作系统中的结构体对齐，字节对齐</h2><p><strong>需要对齐的原因</strong>：</p><p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p><p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。（通俗点来讲就是比如cpu需要读取一个4字节长度的指令，它一般就会每次读取4个字节，如果没对齐，就有可能导致指令在第一次读取只是被读取了一部分。如下</p><p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210227225619520.png" alt="image-20210227225619520">）</p><p><strong>对齐的规则</strong>：</p><p>(1)  结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小</strong>与<strong>有效对齐值（一般为4）</strong>中较小那个的整数倍。如有需要编译器会在成员之间加上填充字节。</p><p>(2)  <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>。如有需要编译器会在最末一个成员之后加上填充字节。</p><h2 id="8-请问进程间怎么通信"><a href="#8-请问进程间怎么通信" class="headerlink" title="8.请问进程间怎么通信"></a>8.请问进程间怎么通信</h2><p>进程间通信主要包括管道，系统IPC（包括信息队列，信号量，信号，共享内存等），以及套接字socket（用于不同主机间的进程通信，例如：如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是(210.37.145.1：23)。）。</p><h2 id="9-有了进程为什么还要线程"><a href="#9-有了进程为什么还要线程" class="headerlink" title="9. 有了进程为什么还要线程"></a>9. 有了进程为什么还要线程</h2><p>目的是为了提升并发度。</p><p>为什么能够提升并发度呢？</p><p>因为启动或创建一个新进程，需要给它分配独立的地址空间，建立众多的数据表来维护它的代码段，堆栈段，数据段。但是运行在同一个进程中的线程使用的是相同的地址空间，因此创建线程、切换线程开销比进程要更加小。</p><h2 id="10-虚拟内存置换"><a href="#10-虚拟内存置换" class="headerlink" title="10.虚拟内存置换"></a>10.虚拟内存置换</h2><p><strong>1）最佳置换算法——OPT</strong></p><p>这个算法无法实现。</p><p><strong>思想</strong>：假如知道进程接下来访问的页面，就可以知道哪个页面最后才被访问到，就把最后才会被访问的页面置换成新访问的页面。</p><p><strong>无法实现原因</strong>：因为需要“预知未来”，需要知道进程接下来会访问到的页面才行。</p><p><strong>（2）先进先出置换算法——FIFO</strong></p><p><strong>思想</strong>：每次淘汰的是最早进入内存的页面</p><p><strong>实现方法</strong>：把调入内存的页面根据进入的顺序排成一个队列，每次淘汰队头就可以</p><p><strong>缺点</strong>：算法性能差，无法体现页面冷热信息（就是被使用的频繁度）</p><p><strong>（3）最近最久未使用置换算法——LRU</strong></p><p><strong>思想</strong>：每次淘汰的页面是最近这段时间内最久未使用的页面。也就是从开始需要置换的地方开始往回检查，最迟出现的页面就是“最近最久未使用置换算法“</p><p><strong>实现方法</strong>：</p><blockquote><p>方法1：使用一个栈，新页面或者被使用的页面，就移动到栈底，每次替换栈顶的缓存页面。</p><p>方法2：赋予每个页面对用的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面的时候，选择t最大的页面即可。</p></blockquote><p>前面的三种算法，OPT性能最好，但是无法实现。FIFO实现最简单，但是算法性能差。LRU算法性能好，但是实现起来不容易，开销比较大。所以，需要一个比较均衡的算法——clock</p><p><strong>（3）时钟置换算法——clock</strong></p><p><strong>思想</strong>：为每个在内存里的页面设置一个访问位，访问位有1和0两种情况，1代表最近访问过，0代表最近没访问过。再将内存中的页面都通过链接指针链接成一个循环队列。接下来就是操作：新加入的页面访问位都置为1。被访问的页面也置为1。当需要置换的时候，就开始循环扫描，如果页面访问位是0，说明少用，被置换。是1的话说明最近使用过，不被置换，但是访问位变0。</p><h2 id="11-线程同步的几种方式"><a href="#11-线程同步的几种方式" class="headerlink" title="11.线程同步的几种方式"></a>11.线程同步的几种方式</h2><p>1、临界区：</p><p>通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p><p>2、互斥量 Synchronized/Lock：</p><p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p><p>3、信号量 Semphare：</p><p>为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p><p>4、事件(信号)，Wait/Notify：</p><p>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p><h1 id="四、Linux"><a href="#四、Linux" class="headerlink" title="四、Linux"></a>四、Linux</h1><h2 id="1-linux虚拟地址空间"><a href="#1-linux虚拟地址空间" class="headerlink" title="1.linux虚拟地址空间"></a>1.linux虚拟地址空间</h2><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p><p>每个进程创建加载时，内核只是为进程“创建”了虚拟内存布局。等运行到对应程序时，才会通过缺页异常来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc，也只是分配了虚拟内存，等进程真正访问到这个数据的时候，才引发缺页异常。</p><h1 id="五、mySQL"><a href="#五、mySQL" class="headerlink" title="五、mySQL"></a>五、mySQL</h1><h2 id="1-MySQL端口号"><a href="#1-MySQL端口号" class="headerlink" title="1.MySQL端口号"></a>1.MySQL端口号</h2><p>mysql的默认端口是3306。修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
