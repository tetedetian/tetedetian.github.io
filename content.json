{"meta":{"title":"特特的天","subtitle":"生活就像心电图——一帆风顺说明你挂了","description":"","author":"John Doe","url":"https://tetedetian.github.io","root":"/"},"pages":[{"title":"","date":"2020-09-10T18:09:04.438Z","updated":"2020-07-17T09:52:17.000Z","comments":true,"path":"css/style.css","permalink":"https://tetedetian.github.io/css/style.css","excerpt":"","text":"@supports (backdrop-filter: blur(20px)) { .blur { background: rgba(255,255,255,0.9) !important; backdrop-filter: saturate(200%) blur(20px); } } .shadow { box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } .shadow.floatable { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .shadow.floatable:hover { box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } @font-face { font-family: 'UbuntuMono'; src: url(\"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf\"); font-weight: 'normal'; font-style: 'normal'; } @font-face { font-family: 'Varela Round'; src: url(\"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf\"); font-weight: 'normal'; font-style: 'normal'; } * { box-sizing: border-box; outline: none; margin: 0; padding: 0; } html { color: #444; width: 100%; height: 100%; font-family: UbuntuMono, \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif; font-size: 16px; } html >::-webkit-scrollbar { height: 4px; width: 4px; } html >::-webkit-scrollbar-track-piece { background: transparent; } html >::-webkit-scrollbar-thumb { background: #2196f3; cursor: pointer; border-radius: 2px; } html >::-webkit-scrollbar-thumb:hover { background: #ff5722; } body { background-color: #f4f4f4; text-rendering: optimizelegibility; -webkit-tap-highlight-color: rgba(0,0,0,0); line-height: 1.65; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; } body.modal-active { overflow: hidden; } @media screen and (max-width: 680px) { body.modal-active { position: fixed; top: 0; right: 0; bottom: 0; left: 0; } } ::-moz-selection { background: rgba(33,150,243,0.2); } ::selection { background: rgba(33,150,243,0.2); } h1 { font-size: 1.625rem; } h2 { font-size: 1.375rem; } h3 { font-size: 1.25rem; } h4 { font-size: 1.125rem; } h5 { font-size: 1rem; } h6 { font-size: 1rem; } h1, h2, h3, h4, h6 { font-weight: normal; } a { color: #2196f3; cursor: pointer; text-decoration: none; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } a:hover { color: #ff5722; } a:active, a:hover { outline: 0; } a:not([href]) { cursor: default; } pre { tab-size: 4; -moz-tab-size: 4; -o-tab-size: 4; -webkit-tab-size: 4; } img { max-width: 100%; } .clearfix { zoom: 1; } .clearfix:before, .clearfix:after { content: \" \"; display: table; } .clearfix:after { clear: both; } .hidden { text-indent: -9999px; visibility: hidden; display: none; } .inner { position: relative; width: 80%; max-width: 710px; margin: 0 auto; } .vertical { display: table-cell; vertical-align: middle; } ul, ol { padding-left: 0; } ul li, ol li { list-style: none; } article, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary { display: block; } abbr[title] { border-bottom: 1px dotted; } b, strong { font-weight: bold; } dfn { font-style: italic; } h1 { font-size: 2em; margin: 0.67em 0; } mark { background: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 50%; line-height: 1em; } sup { vertical-align: text-top; } sub { vertical-align: text-bottom; } img { border: 0; background: none; max-width: 100%; } svg:not(:root) { overflow: hidden; } figure { margin: 1em 40px; } hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; border: 0; border-radius: 1px; border-bottom: 1px solid rgba(68,68,68,0.1); } pre { overflow: auto; } code, kbd, pre, samp { font-family: monospace, monospace; font-size: 1em; } button, input, optgroup, select, textarea { color: inherit /* 1 */; font: inherit /* 2 */; margin: 0 /* 3 */; } button { overflow: visible; } button, select { text-transform: none; } button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button /* 2 */; cursor: pointer /* 3 */; } button[disabled], html input[disabled] { cursor: default; } button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; } input[type=\"checkbox\"], input[type=\"radio\"] { box-sizing: border-box /* 1 */; padding: 0 /* 2 */; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { height: auto; } input[type=\"search\"] { -webkit-appearance: textfield /* 1 */; -moz-box-sizing: content-box; -webkit-box-sizing: content-box /* 2 */; box-sizing: content-box; } input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; } legend { border: 0 /* 1 */; padding: 0 /* 2 */; } textarea { overflow: auto; } optgroup { font-weight: bold; } table { border-collapse: collapse; overflow: auto; display: inline-block; max-width: 100%; margin-right: 0.4rem; vertical-align: text-top; } table::-webkit-scrollbar { height: 4px; width: 4px; } table::-webkit-scrollbar-track-piece { background: transparent; } table::-webkit-scrollbar-thumb { background: rgba(118,118,118,0.4); cursor: pointer; border-radius: 2px; } table::-webkit-scrollbar-thumb:hover { background: #767676; } table th { background-color: #f1f1f1; } table td, table th { padding: 8px 16px; border: 2px solid #f1f1f1; line-height: 1.5; font-size: 90%; } table tr { word-break: keep-all; background-color: #fefefe; } table tbody >tr { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } table tbody >tr:hover { background-color: #f1f1f1; } td, th { padding: 0; } span.btn { display: inline; } span.btn >a { display: inline-block; background: #2196f3; color: #fff; padding: 4px 4px 2px 4px; margin: 2px; line-height: 1.1; border-radius: 2px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } span.btn >a i { margin-right: 2px; } span.btn >a:hover { color: #fff; background: #ff5722; } span.btn >a:not([href]) { opacity: 0.5; } span.btn >a:not([href]):hover { cursor: not-allowed; } span.btn.regular >a { padding: 8px 12px 6px 12px; } span.btn.regular >a i { margin-right: 4px; } span.btn.large >a { padding: 12px 36px 10px 36px; } span.btn.large >a i { margin-right: 8px; } span.btn.center { display: block; text-align: center; } div.btns { margin: 0 -8px; display: flex; flex-wrap: wrap; align-items: flex-start; overflow: visible; line-height: 1.8; } div.btns, div.btns p, div.btns a { font-size: 0.8125rem; color: #555; } div.btns b { font-size: 0.875rem; } div.btns.wide>a { padding-left: 32px; padding-right: 32px; } div.btns.fill>a { flex-grow: 1; width: auto; } div.btns.around { justify-content: space-around; } div.btns.center { justify-content: center; } div.btns.grid2>a { width: calc(100%/2 - 16px); } @media screen and (max-width: 1024px) { div.btns.grid2>a { width: calc(100%/2 - 16px); } } @media screen and (max-width: 768px) { div.btns.grid2>a { width: calc(100%/2 - 16px); } } @media screen and (max-width: 500px) { div.btns.grid2>a { width: calc(100%/1 - 16px); } } div.btns.grid3>a { width: calc(100%/3 - 16px); } @media screen and (max-width: 1024px) { div.btns.grid3>a { width: calc(100%/3 - 16px); } } @media screen and (max-width: 768px) { div.btns.grid3>a { width: calc(100%/3 - 16px); } } @media screen and (max-width: 500px) { div.btns.grid3>a { width: calc(100%/1 - 16px); } } div.btns.grid4>a { width: calc(100%/4 - 16px); } @media screen and (max-width: 1024px) { div.btns.grid4>a { width: calc(100%/3 - 16px); } } @media screen and (max-width: 768px) { div.btns.grid4>a { width: calc(100%/3 - 16px); } } @media screen and (max-width: 500px) { div.btns.grid4>a { width: calc(100%/2 - 16px); } } div.btns.grid5>a { width: calc(100%/5 - 16px); } @media screen and (max-width: 1024px) { div.btns.grid5>a { width: calc(100%/4 - 16px); } } @media screen and (max-width: 768px) { div.btns.grid5>a { width: calc(100%/3 - 16px); } } @media screen and (max-width: 500px) { div.btns.grid5>a { width: calc(100%/2 - 16px); } } div.btns a { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; margin: 8px; margin-top: calc(1.25 * 16px + 32px); min-width: 120px; font-weight: bold; display: flex; justify-content: flex-start; align-content: center; align-items: center; flex-direction: column; padding: 8px; text-align: center; background: #f6f6f6; border-radius: 4px; } div.btns a>img:first-child, div.btns a>i:first-child { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; height: 64px; width: 64px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); margin: 16px 8px 4px 8px; margin-top: calc(-1.25 * 16px - 32px); border: 2px solid #fff; background: #fff; line-height: 60px; font-size: 28px; } div.btns a>img:first-child.auto, div.btns a>i:first-child.auto { width: auto; } div.btns a>i:first-child { color: #fff; background: #2196f3; } div.btns a p, div.btns a b { margin: 0.25em; font-weight: normal; line-height: 1.25; word-wrap: break-word; } div.btns a b { font-weight: bold; line-height: 1.3; } div.btns a img { margin: 0.4em auto; } div.btns a:not([href]) { cursor: default; color: inherit; } div.btns a[href]:hover { background: rgba(255,87,34,0.15); } div.btns a[href]:hover, div.btns a[href]:hover b { color: #ff5722; } div.btns a[href]:hover>img:first-child, div.btns a[href]:hover>i:first-child { transform: scale(1.1) translateY(-8px); box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1); } div.btns a[href]:hover>i:first-child { background: #ff5722; } div.btns.circle a>img:first-child, div.btns.circle a>i:first-child { border-radius: 32px; } div.btns.rounded a>img:first-child, div.btns.rounded a>i:first-child { border-radius: 16px; } article .checkbox { display: flex; font-size: 0.9375rem; align-items: center; /* Checkbox */ /* Radio */ /* Colors */ } article .checkbox input { transform: translate(0, -1px); -webkit-appearance: none; -moz-appearance: none; -ms-appearance: none; -o-appearance: none; appearance: none; position: relative; height: 16px; width: 16px; transition: all 0.15s ease-out 0s; cursor: pointer; display: inline-block; outline: none; border-radius: 2px; flex-shrink: 0; margin-right: 8px; } article .checkbox input[type=checkbox]:before, article .checkbox input[type=checkbox]:after { position: absolute; content: \"\"; background: #fff; } article .checkbox input[type=checkbox]:before { left: 1px; top: 5px; width: 0px; height: 2px; transition: all 0.2s ease-in; transform: rotate(45deg); -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); } article .checkbox input[type=checkbox]:after { right: 7px; bottom: 3px; width: 2px; height: 0px; transition: all 0.2s ease-out; transform: rotate(40deg); -webkit-transform: rotate(40deg); -moz-transform: rotate(40deg); -ms-transform: rotate(40deg); -o-transform: rotate(40deg); transition-delay: 0.25s; } article .checkbox input[type=checkbox]:checked:before { left: 0px; top: 7px; width: 6px; height: 2px; } article .checkbox input[type=checkbox]:checked:after { right: 3px; bottom: 1px; width: 2px; height: 10px; } article .checkbox.minus input[type=checkbox]:before { transform: rotate(0); left: 1px; top: 5px; width: 0px; height: 2px; } article .checkbox.minus input[type=checkbox]:after { transform: rotate(0); left: 1px; top: 5px; width: 0px; height: 2px; } article .checkbox.minus input[type=checkbox]:checked:before { left: 1px; top: 5px; width: 10px; height: 2px; } article .checkbox.minus input[type=checkbox]:checked:after { left: 1px; top: 5px; width: 10px; height: 2px; } article .checkbox.plus input[type=checkbox]:before { transform: rotate(0); left: 1px; top: 5px; width: 0px; height: 2px; } article .checkbox.plus input[type=checkbox]:after { transform: rotate(0); left: 5px; top: 1px; width: 2px; height: 0px; } article .checkbox.plus input[type=checkbox]:checked:before { left: 1px; top: 5px; width: 10px; height: 2px; } article .checkbox.plus input[type=checkbox]:checked:after { left: 5px; top: 1px; width: 2px; height: 10px; } article .checkbox.times input[type=checkbox]:before { transform: rotate(45deg); left: 3px; top: 1px; width: 0px; height: 2px; } article .checkbox.times input[type=checkbox]:after { transform: rotate(135deg); right: 3px; top: 1px; width: 0px; height: 2px; } article .checkbox.times input[type=checkbox]:checked:before { left: 1px; top: 5px; width: 10px; height: 2px; } article .checkbox.times input[type=checkbox]:checked:after { right: 1px; top: 5px; width: 10px; height: 2px; } article .checkbox input[type=radio] { border-radius: 50%; } article .checkbox input[type=radio]:before { content: \"\"; display: block; width: 8px; height: 8px; border-radius: 50%; margin: 2px; transform: scale(0); transition: all 0.25s ease-out; } article .checkbox input[type=radio]:checked:before { transform: scale(1); } article .checkbox input { border: 2px solid #2196f3; } article .checkbox input[type=checkbox]:checked { background: #2196f3; } article .checkbox input[type=radio]:checked:before { background: #2196f3; } article .checkbox.red input { border-color: #fe5f58; } article .checkbox.red input[type=checkbox]:checked { background: #fe5f58; } article .checkbox.red input[type=radio]:checked:before { background: #fe5f58; } article .checkbox.green input { border-color: #3dc550; } article .checkbox.green input[type=checkbox]:checked { background: #3dc550; } article .checkbox.green input[type=radio]:checked:before { background: #3dc550; } article .checkbox.yellow input { border-color: #ffbd2b; } article .checkbox.yellow input[type=checkbox]:checked { background: #ffbd2b; } article .checkbox.yellow input[type=radio]:checked:before { background: #ffbd2b; } article .checkbox.cyan input { border-color: #1bcdfc; } article .checkbox.cyan input[type=checkbox]:checked { background: #1bcdfc; } article .checkbox.cyan input[type=radio]:checked:before { background: #1bcdfc; } article .checkbox.blue input { border-color: #2196f3; } article .checkbox.blue input[type=checkbox]:checked { background: #2196f3; } article .checkbox.blue input[type=radio]:checked:before { background: #2196f3; } article .checkbox p { display: inline-block; margin-top: 0 !important; margin-bottom: 0 !important; } div.dropmenu { display: inline-block; position: relative; line-height: 2.4; cursor: default; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; color: rgba(68,68,68,0.85); background: #f6f6f6; border-radius: 4px; border: 1px solid #e7e7e7; padding: 0 16px; padding-top: 1px; font-size: 0.875rem; font-weight: bold; } div.dropmenu:hover { background: #e8f4fd; border-color: #cce7fb; } div.dropmenu:hover >ul { display: block; margin-left: -8px; margin-top: -4px; } div.dropmenu ul>li { list-style: none; } div.dropmenu ul>li >a:hover { text-decoration: none !important; } div.dropmenu .list-v .list-v { left: calc(100% - 0.5 * 16px); } details { display: block; padding: 16px; margin: 0.4rem 0; border-radius: 4px; background: #fff; font-size: 95%; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; border: 1px solid #f6f6f6; } details p { font-size: 0.9375rem; } details summary { cursor: pointer; padding: 16px; margin: -16px; border-radius: 4px; color: rgba(85,85,85,0.7); font-size: 0.875rem; font-weight: bold; position: relative; line-height: normal; } details summary > p, details summary > h1, details summary > h2, details summary > h3, details summary > h4, details summary > h5, details summary > h6 { display: inline; border-bottom: none !important; } details summary:hover { color: #555; } details summary:hover:after { position: absolute; content: '+'; text-align: center; top: 50%; transform: translateY(-50%); right: 16px; } details >summary { background: #f6f6f6; } details[blue] { border-color: #e8f4fd; } details[blue] >summary { background: #e8f4fd; } details[cyan] { border-color: #e8fafe; } details[cyan] >summary { background: #e8fafe; } details[green] { border-color: #ebf9ed; } details[green] >summary { background: #ebf9ed; } details[yellow] { border-color: #fff8e9; } details[yellow] >summary { background: #fff8e9; } details[red] { border-color: #feefee; } details[red] >summary { background: #feefee; } details[open] { border-color: rgba(85,85,85,0.2); } details[open] >summary { border-bottom: 1px solid rgba(85,85,85,0.2); border-bottom-left-radius: 0; border-bottom-right-radius: 0; } details[open][blue] { border-color: rgba(33,150,243,0.3); } details[open][blue] >summary { border-bottom-color: rgba(33,150,243,0.3); } details[open][cyan] { border-color: rgba(27,205,252,0.3); } details[open][cyan] >summary { border-bottom-color: rgba(27,205,252,0.3); } details[open][green] { border-color: rgba(61,197,80,0.3); } details[open][green] >summary { border-bottom-color: rgba(61,197,80,0.3); } details[open][yellow] { border-color: rgba(255,189,43,0.3); } details[open][yellow] >summary { border-bottom-color: rgba(255,189,43,0.3); } details[open][red] { border-color: rgba(254,95,88,0.3); } details[open][red] >summary { border-bottom-color: rgba(254,95,88,0.3); } details[open] >summary { color: #555; margin-bottom: 0; } details[open] >summary:hover:after { content: '-'; } details[open] >div.content { padding: 16px; margin: -16px; margin-top: 0; } details[open] >div.content p>a:hover { text-decoration: underline; } details[open] >div.content > p:first-child, details[open] >div.content > .tabs:first-child, details[open] >div.content > ul:first-child, details[open] >div.content > ol:first-child, details[open] >div.content > .highlight:first-child, details[open] >div.content > .note:first-child, details[open] >div.content > .fancybox:first-child, details[open] >div.content > details:first-child { margin-top: 0; } details[open] >div.content > p:last-child, details[open] >div.content > .tabs:last-child, details[open] >div.content > ul:last-child, details[open] >div.content > ol:last-child, details[open] >div.content > .highlight:last-child, details[open] >div.content > .note:last-child, details[open] >div.content > .fancybox:last-child, details[open] >div.content > details:last-child { margin-bottom: 0; } audio, video { border-radius: 4px; max-width: 100%; } video { z-index: 1; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } video:hover { box-shadow: 0 4px 8px 0px rgba(0,0,0,0.24), 0 8px 16px 0px rgba(0,0,0,0.24); } div.video { line-height: 0; text-align: center; } div.videos { max-width: calc(100% + 2 * 4px); display: flex; flex-wrap: wrap; justify-content: flex-start; align-items: flex-end; margin: 0.4rem -4px; } div.videos .video, div.videos iframe { width: 100%; margin: 4px; } div.videos iframe { border-radius: 4px; width: 100%; min-height: 300px; } div.videos.left { justify-content: flex-start; } div.videos.center { justify-content: center; } div.videos.right { justify-content: flex-end; } div.videos.stretch { align-items: stretch; } div.videos[col='1'] .video, div.videos[col='1'] iframe { width: 100%; } div.videos[col='2'] .video, div.videos[col='2'] iframe { width: calc(50% - 2 * 4px); } div.videos[col='3'] .video, div.videos[col='3'] iframe { width: calc(33.33% - 2 * 4px); } div.videos[col='4'] .video, div.videos[col='4'] iframe { width: calc(25% - 2 * 4px); } div.note { position: relative; margin-top: 0.4rem; margin-bottom: 0.4rem; padding: 0.5rem 16px 0.4rem 16px; padding-left: calc(16px + 16px); border-radius: 4px; background: #f5f5f5; border-left: 4px solid #696969; } div.note h2, div.note h3, div.note h4, div.note h5, div.note h6 { margin-top: 3px; margin-bottom: 0; padding-top: 0 !important; border-bottom: initial; } div.note p, div.note ul, div.note ol, div.note blockquote, div.note img { font-size: 0.9375rem; margin-top: 0.4rem; margin-bottom: 0.4rem; } div.note::before { position: absolute; top: calc(50% - 24px * 0.5); left: 4px; width: 24px; height: 24px; text-align: center; font-weight: 600; line-height: 24px; vertical-align: middle; font-family: 'Font Awesome 5 Free'; } div.note::before { color: #696969; content: '\\f054'; } div.note::before { content: '\\f054'; } div.note.quote { background: #e8f4fd; border-color: #2196f3; } div.note.quote::before { color: #2196f3; content: '\\f10d'; } div.note.info { background: #e8f4fd; border-color: #2196f3; } div.note.info::before { color: #2196f3; content: '\\f129'; } div.note.success, div.note.done { background: #ebf9ed; border-color: #3dc550; } div.note.success::before, div.note.done::before { color: #3dc550; content: '\\f00c'; } div.note.warning { background: #fff8e9; border-color: #ffbd2b; } div.note.warning::before { color: #ffbd2b; content: '\\f12a'; } div.note.danger, div.note.error { background: #feefee; border-color: #fe5f58; } div.note.danger::before, div.note.error::before { color: #fe5f58; content: '\\f00d'; } div.note.radiation::before { content: '\\f7b9'; } div.note.bug::before { content: '\\f188'; } div.note.idea::before { content: '\\f0eb'; } div.note.link::before { content: '\\f0c1'; } div.note.paperclip::before { content: '\\f0c6'; } div.note.todo::before { content: '\\f0ae'; } div.note.message::before { content: '\\f4ad'; } div.note.guide::before { content: '\\f277'; } div.note.download::before { content: '\\f019'; } div.note.up::before { content: '\\f102'; } div.note.undo::before { content: '\\f2ea'; } div.note.play::before { content: '\\f144'; } div.note.clear { background: none; border-color: none; } div.note.light { background: #f5f5f5; border-color: #a1a1a1; } div.note.light::before { color: #a1a1a1; } div.note.gray { background: #f5f5f5; border-color: #696969; } div.note.gray::before { color: #696969; } div.note.red { background: #feefee; border-color: #fe5f58; } div.note.red::before { color: #fe5f58; } div.note.yellow { background: #fff8e9; border-color: #ffbd2b; } div.note.yellow::before { color: #ffbd2b; } div.note.green { background: #ebf9ed; border-color: #3dc550; } div.note.green::before { color: #3dc550; } div.note.cyan { background: #e8fafe; border-color: #1bcdfc; } div.note.cyan::before { color: #1bcdfc; } div.note.blue { background: #e8f4fd; border-color: #2196f3; } div.note.blue::before { color: #2196f3; } p.p.subtitle { font-weight: bold; color: #2196f3; font-size: 1rem !important; padding-top: 0.8rem; } p.p.subtitle:first-child { padding-top: 0.4rem; } span.p.logo, p.p.logo { font-family: \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Helvetica, monospace; } span.p.code, p.p.code { font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; } span.p.left, p.p.left { display: block; text-align: left; } span.p.center, p.p.center { display: block; text-align: center; } span.p.right, p.p.right { display: block; text-align: right; } span.p.small, p.p.small { font-size: 0.875rem; } span.p.large, p.p.large { font-size: 3rem; line-height: 1.4; } span.p.huge, p.p.huge { font-size: 4rem; line-height: 1.4; } span.p.ultra, p.p.ultra { font-size: 6rem; line-height: 1.4; } span.p.small, p.p.small, span.p.large, p.p.large, span.p.huge, p.p.huge, span.p.ultra, p.p.ultra { margin: 0; padding: 0; } span.p.bold, p.p.bold { font-weight: bold; } span.p.h1, p.p.h1 { font-size: 1.625rem; color: #444; padding-top: 0.8rem; } span.p.h2, p.p.h2 { font-size: 1.375rem; color: #444; padding-top: 0.8rem; border-bottom: 1px solid rgba(68,68,68,0.1); } span.p.h3, p.p.h3 { font-size: 1.25rem; color: #444; padding-top: 0.8rem; } span.p.h4, p.p.h4 { font-size: 1.125rem; color: #444; padding-top: 0.8rem; } span.p.h5, p.p.h5 { font-size: 1rem; color: #444; padding-top: 0.6rem; } span.p.red, p.p.red { color: #fe5f58; } span.p.yellow, p.p.yellow { color: #ffbd2b; } span.p.green, p.p.green { color: #3dc550; } span.p.cyan, p.p.cyan { color: #1bcdfc; } span.p.blue, p.p.blue { color: #2196f3; } span.p.gray, p.p.gray { color: #999; } div.tabs { display: block; position: relative; margin-top: 0.4rem; margin-bottom: 0.4rem; border-radius: 4px; background: #fff; border: 1px solid rgba(85,85,85,0.2); font-size: 95%; } div.tabs p { font-size: 95%; } div.tabs .highlight, div.tabs p, div.tabs ul, div.tabs ol, div.tabs div.note, div.tabs details { margin-top: 0.4rem; margin-bottom: 0.4rem; } div.tabs ul.nav-tabs { display: flex; overflow-x: auto; white-space: nowrap; justify-content: flex-start; margin: 0 !important; padding: 8px 8px 0 8px; background: #f6f6f6; border-radius: 4px 4px 0 0; line-height: 1.5; } div.tabs ul.nav-tabs li.tab { list-style-type: none; margin-top: 0; margin-bottom: 0; } div.tabs ul.nav-tabs li.tab:last-child { padding-right: 16px; } div.tabs ul.nav-tabs li.tab a { display: block; cursor: pointer; border-radius: 4px 4px 0 0; padding: 8px; text-align: center; font-size: 0.875rem; line-height: inherit; font-weight: bold; color: rgba(68,68,68,0.65); border: 1px solid transparent; } div.tabs ul.nav-tabs li.tab a:hover { color: #555; } div.tabs ul.nav-tabs li.tab a i { pointer-events: none; } div.tabs ul.nav-tabs li.tab.active a { cursor: default; color: #555; background: #fff; border: 1px solid rgba(85,85,85,0.2); border-bottom: 1px solid #fff; } div.tabs .tab-content { border-top: 1px solid rgba(85,85,85,0.2); margin-top: -1px; } div.tabs .tab-content .tab-pane { padding: 16px; } div.tabs .tab-content .tab-pane:not(.active) { display: none; } div.tabs .tab-content .tab-pane.active { display: block; } div.tabs .tab-content .tab-pane > p:first-child, div.tabs .tab-content .tab-pane > .tabs:first-child, div.tabs .tab-content .tab-pane > ul:first-child, div.tabs .tab-content .tab-pane > ol:first-child, div.tabs .tab-content .tab-pane > .highlight:first-child, div.tabs .tab-content .tab-pane > .note:first-child, div.tabs .tab-content .tab-pane > .fancybox:first-child { margin-top: 0; } div.tabs .tab-content .tab-pane > p:last-child, div.tabs .tab-content .tab-pane > .tabs:last-child, div.tabs .tab-content .tab-pane > ul:last-child, div.tabs .tab-content .tab-pane > ol:last-child, div.tabs .tab-content .tab-pane > .highlight:last-child, div.tabs .tab-content .tab-pane > .note:last-child, div.tabs .tab-content .tab-pane > .fancybox:last-child { margin-bottom: 0; } pre { position: relative; } .hljs { margin: -16px !important; padding: 16px !important; -webkit-font-smoothing: auto; -moz-osx-font-smoothing: auto; } .hljs::-webkit-scrollbar { height: 4px; width: 4px; } .hljs::-webkit-scrollbar-track-piece { background: transparent; } .hljs::-webkit-scrollbar-thumb { background: rgba(118,118,118,0.4); cursor: pointer; border-radius: 2px; } .hljs::-webkit-scrollbar-thumb:hover { background: #767676; } .hljs:before { position: absolute; top: 0; right: 0; color: rgba(68,68,68,0.65); font-size: 0.75rem; padding: 4px 8px; } .hljs.md:before, .hljs.markdown:before { content: \"md\"; } .hljs.yaml:before { content: \"YAML\"; } .hljs.json:before { content: \"JSON\"; } .hljs.html:before { content: \"HTML\"; } .hljs.js:before, .hljs.javascript:before { content: \"JS\"; } .hljs.css:before { content: \"CSS\"; } .hljs.less:before { content: \"Less\"; } .hljs.stylus:before { content: \"Stylus\"; } .hljs.bash:before { content: \"bash\"; } .hljs.shell:before { content: \"shell\"; } .hljs.sh:before { content: \"sh\"; } .hljs.ini:before { content: \"ini\"; } .hljs.c:before { content: \"C\"; } .hljs.cpp:before { content: \"C++\"; } .hljs.objc:before, .hljs.objectivec:before { content: \"Objective-C\"; } .hljs.swift:before { content: \"Swift\"; } .hljs.java:before { content: \"Java\"; } .hljs.python:before { content: \"Python\"; } .hljs.php:before { content: \"PHP\"; } .hljs.rust:before { content: \"Rust\"; } .hljs.sql:before { content: \"SQL\"; } .hljs.ruby:before { content: \"Ruby\"; } .hljs.makefile:before { content: \"Makefile\"; } .hljs.go:before { content: \"Go\"; } .hljs.typescript:before { content: \"TypeScript\"; } .highlight { position: relative; width: 100%; margin: 0.4rem 0; display: block; background: #f6f6f6; font-size: 0.8125rem; font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; border-radius: 4px; border: 1px solid #e7e7e7; line-height: 1.5; -webkit-font-smoothing: auto; -moz-osx-font-smoothing: auto; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .highlight figcaption { position: sticky; left: 0; padding: 4px 8px 4px 8px; background-color: #eaeaea; border-top-left-radius: 4px; border-top-right-radius: 4px; } .highlight >table { overflow: auto; display: block; margin: 0; background-color: transparent; border: none; } .highlight >table td, .highlight >table th { padding: 0; border: none; line-height: 1.5; } .highlight >table tr { background-color: transparent; } .highlight >table tr:hover { background-color: transparent; } .highlight >table .gutter { -moz-user-select: none; -ms-user-select: none; -webkit-user-select: none; user-select: none; padding: 0 12px; text-align: right; border-width: 0; margin-left: 0; position: sticky; left: 0; z-index: 1; background-color: #e9e9e9; } .highlight >table .gutter pre { color: rgba(68,68,68,0.65); } .highlight >table pre { background: transparent; margin: 0; padding: 0; border: none; } .highlight >table .code { padding: 16px; vertical-align: top; background-color: transparent; } .highlight >table .code:before { content: \"\"; position: absolute; top: 0; right: 0; color: rgba(68,68,68,0.65); font-size: 0.75rem; padding: 4px 8px; } .highlight.md .code:before, .highlight.markdown .code:before { content: \"md\"; } .highlight.yaml .code:before { content: \"YAML\"; } .highlight.json .code:before { content: \"JSON\"; } .highlight.diff .code:before { content: \"diff\"; } .highlight.html .code:before { content: \"HTML\"; } .highlight.js .code:before, .highlight.javascript .code:before { content: \"JS\"; } .highlight.css .code:before { content: \"CSS\"; } .highlight.less .code:before { content: \"Less\"; } .highlight.stylus .code:before { content: \"Stylus\"; } .highlight.bash .code:before { content: \"bash\"; } .highlight.shell .code:before { content: \"shell\"; } .highlight.sh .code:before { content: \"sh\"; } .highlight.ini .code:before { content: \"ini\"; } .highlight.c .code:before { content: \"C\"; } .highlight.cpp .code:before { content: \"C++\"; } .highlight.objc .code:before, .highlight.objectivec .code:before { content: \"Objective-C\"; } .highlight.swift .code:before { content: \"Swift\"; } .highlight.java .code:before { content: \"Java\"; } .highlight.python .code:before { content: \"Python\"; } .highlight.php .code:before { content: \"PHP\"; } .highlight.rust .code:before { content: \"Rust\"; } .highlight.sql .code:before { content: \"SQL\"; } .highlight.ruby .code:before { content: \"Ruby\"; } .highlight.makefile .code:before { content: \"Makefile\"; } .highlight.go .code:before { content: \"Go\"; } .highlight.typescript .code:before { content: \"TypeScript\"; } .highlight pre .line, .highlight pre .params { color: rgba(68,68,68,0.9); } .highlight pre .line .addition { color: #3fa33f; } .highlight pre .line .deletion { color: #ee2b29; } .highlight pre .marked { background-color: rgba(254,213,66,0.4); padding: 2px 8px 2px 0; border-radius: 2px; width: 100%; } .highlight pre .title, .highlight pre .attr, .highlight pre .attribute { color: #3f51b5; } .highlight pre .comment { color: rgba(85,85,85,0.5); } .highlight pre .keyword, .highlight pre .meta-keyword, .highlight pre .javascript .function { color: #9c27b0; } .highlight pre .type, .highlight pre .built_in, .highlight pre .tag .name { color: #4ba7ee; } .highlight pre .variable, .highlight pre .regexp, .highlight pre .ruby .constant, .highlight pre .xml .tag .title, .highlight pre .xml .pi, .highlight pre .xml .doctype, .highlight pre .html .doctype, .highlight pre .css .id, .highlight pre .css .class, .highlight pre .css .pseudo { color: #fd8607; } .highlight pre .number, .highlight pre .preprocessor, .highlight pre .literal, .highlight pre .constant { color: #fd8607; } .highlight pre .class, .highlight pre .ruby .class .title, .highlight pre .css .rules .attribute { color: #ff9800; } .highlight pre .string, .highlight pre .meta-string { color: #449e48; } .highlight pre .value, .highlight pre .inheritance, .highlight pre .header, .highlight pre .ruby .symbol, .highlight pre .xml .cdata { color: #4caf50; } .highlight pre .css .hexcolor { color: #6cc; } .highlight pre .function, .highlight pre .python .decorator, .highlight pre .python .title, .highlight pre .ruby .function .title, .highlight pre .ruby .title .keyword, .highlight pre .perl .sub, .highlight pre .javascript .title, .highlight pre .coffeescript .title { color: #69c; } .highlight.html .line .tag .name, .highlight.css .line .tag .name, .highlight.less .line .tag .name, .highlight.stylus .line .tag .name, .highlight.html .line .selector-tag, .highlight.css .line .selector-tag, .highlight.less .line .selector-tag, .highlight.stylus .line .selector-tag { color: #ee2b29; } .highlight.html .line .selector-class, .highlight.css .line .selector-class, .highlight.less .line .selector-class, .highlight.stylus .line .selector-class, .highlight.html .line .selector-attr, .highlight.css .line .selector-attr, .highlight.less .line .selector-attr, .highlight.stylus .line .selector-attr { color: #fd8607; } .highlight.html .line .attribute, .highlight.css .line .attribute, .highlight.less .line .attribute, .highlight.stylus .line .attribute { color: #3f51b5; } .highlight.html .line .number, .highlight.css .line .number, .highlight.less .line .number, .highlight.stylus .line .number { color: #17afca; } .highlight.objc .line .meta, .highlight.objectivec .line .meta, .highlight.swift .line .meta, .highlight.c .line .meta { color: #9c27b0; } .highlight.objc .line .meta-string, .highlight.objectivec .line .meta-string, .highlight.swift .line .meta-string, .highlight.c .line .meta-string, .highlight.objc .line .string, .highlight.objectivec .line .string, .highlight.swift .line .string, .highlight.c .line .string { color: #fb3f1b; } .highlight.objc .line .class, .highlight.objectivec .line .class, .highlight.swift .line .class, .highlight.c .line .class { color: rgba(68,68,68,0.9); } .highlight.objc .line .class .title, .highlight.objectivec .line .class .title, .highlight.swift .line .class .title, .highlight.c .line .class .title { color: #1e80f0; } .highlight.objc .line .comment, .highlight.objectivec .line .comment, .highlight.swift .line .comment, .highlight.c .line .comment { color: #3fa33f; } .highlight.json .line .attr { color: #e24f5a; } .highlight.json .line .literal { color: #3f51b5; } .highlight.yaml .line .attr { color: #e24f5a; } .alert { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 999; text-align: center; padding: 30px 36px 29px 36px; border-radius: 8px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); font-weight: bold; font-size: 1.125rem; } .alert.alert-success { color: #247830; background: #daf4de; } .alert.alert-info { color: #028baf; background-color: #e4f9ff; } .alert.alert-warning { color: #c48700; background-color: #fffdf7; } .alert.alert-danger { color: #ef0b01; background-color: #fff; } @media screen and (max-width: 500px) { .l_header .list-v .aplayer, .l_header .list-v .aplayer-pic { border-radius: 4px; width: 64px; height: 64px; } } .highlight { position: relative; } .btn-copy { z-index: 1; display: inline-block; cursor: pointer; border: none; -moz-user-select: none; -ms-user-select: none; -webkit-user-select: none; user-select: none; -webkit-appearance: none; font-family: Menlo, Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; font-size: calc(0.8125rem - 1px); font-weight: bold; padding: 4px 8px; color: rgba(68,68,68,0.65); background: #fff; border-radius: 2px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); position: absolute; top: 0; right: 0; opacity: 0; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .btn-copy >i { margin-right: 4px; } .btn-copy:hover { color: #ff5722; background: #ffeee8; } .highlight:hover .btn-copy { opacity: 1; } .article pre:hover .btn-copy { opacity: 1; } .darkmode-toggle { z-index: 100000; } .darkmode--activated .MiniValine .vpage .more { background: #21232f; } .darkmode--activated img { filter: brightness(30%); } .darkmode--activated .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment.expand:before { background: linear-gradient(180deg, rgba(246,246,246,0), rgba(0,0,0,0.9)); } .darkmode--activated .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment.expand:after { background: rgba(0,0,0,0.9); } .darkmode--activated .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment pre { background: #282c34; border: 1px solid #282c34; } .darkmode--activated .MiniValine .vinputs-area .vextra-area .vsmile-icons { background: transparent; } .darkmode--activated .container { background: #21232f; } .darkmode--activated .blur { background: #21232f !important; } .darkmode--activated .loading-bar-wrapper { background: #21232f; } .darkmode--activated .nav-main .u-search-input { background: #87ceeb !important; } .darkmode--activated .list-v { background: #21232f; } .darkmode--activated .vsubmit { background: #21232f; } .darkmode--activated .l_header ul>li>a:hover { background: rgba(33,150,243,0.2); } .darkmode--activated #archive-page .archive .archive-post a:hover { background: rgba(33,150,243,0.2); } .darkmode--activated .l_main .article .prev-next>a { background: #21232f; } .darkmode--activated .article blockquote { background: #21232f; } .darkmode--activated .highlight>table { background: #282c34; } .darkmode--activated .gutter { background: #282c34 !important; background-color: #282c34 !important; } .darkmode--activated .highlight figcaption { background-color: #21252b; } .darkmode--activated .highlight { border: 1px solid #21252b !important; background: #282c34; } .darkmode--activated details>summary { background: #282c34; } .darkmode--activated details { border: 1px solid #282c34; background: #282c34; } .darkmode--activated .note { background: #282c34 !important; } .darkmode--activated .nav-tabs { background: #282c34 !important; } .darkmode--activated .tabs { background: #282c34 !important; } .darkmode--activated .btns a { background: #282c34 !important; } .darkmode--activated .tab.active a { background: #87ceeb !important; } .darkmode--activated .widget>.content ul.entry a:hover, .darkmode--activated .widget>.content ul.popular-posts a:hover { background: rgba(33,150,243,0.2); } div.gallery { margin: 0.4rem 0; overflow: hidden; } div.gallery >.fancybox, div.gallery >p>.fancybox { margin: 1px; padding: 0; position: relative; } div.gallery >.fancybox .image-caption, div.gallery >p>.fancybox .image-caption { opacity: 0; transform: translateY(100%); transition: all 0.3s ease; pointer-events: none; position: absolute; width: 100%; bottom: 0; text-align: center; background: rgba(0,0,0,0.3); color: #fff; } div.gallery >.fancybox .image-caption:empty, div.gallery >p>.fancybox .image-caption:empty { display: none; } div.gallery >.fancybox:hover .image-caption, div.gallery >p>.fancybox:hover .image-caption { opacity: 1; transform: translateY(0); } div.gallery, div.gallery >p { display: flex; justify-content: center; align-items: center; flex-wrap: nowrap; padding: 0 !important; align-items: stretch; } div.gallery[col]>p { flex-wrap: wrap; justify-content: flex-start; } div.gallery[col='2']>p>.fancybox { width: calc(50% - 2 * 1px); } div.gallery[col='3']>p>.fancybox { width: calc(33.33% - 2 * 1px); } div.gallery[col='4']>p>.fancybox { width: calc(25% - 2 * 1px); } div.gallery[col='5']>p>.fancybox { width: calc(20% - 2 * 1px); } div.gallery[col='6']>p>.fancybox { width: calc(16.66% - 2 * 1px); } div.gallery[col='7']>p>.fancybox { width: calc(14.2857% - 2 * 1px); } div.gallery[col='8']>p>.fancybox { width: calc(12.5% - 2 * 1px); } div.gallery >p { margin: 0; } div.gallery.left, div.gallery.left>p { justify-content: flex-start; } div.gallery.center, div.gallery.center>p { justify-content: center; } div.gallery.right, div.gallery.right>p { justify-content: flex-end; } div.gallery.stretch, div.gallery.stretch>p { align-items: stretch; } div.gallery.stretch img, div.gallery.stretch>p img { transform: scale(1.5); } .fancybox-container .fancybox-stage { cursor: zoom-out; } .fancybox { display: flex; flex-direction: column; justify-content: center; align-items: center; flex-wrap: nowrap; padding: 0 !important; overflow: hidden; border-radius: 2px; } @media screen and (max-width: 500px) { .fancybox { border-radius: 1px; } } .fancybox a { line-height: 0; margin: 0; align-items: stretch; cursor: zoom-in; } .fancybox .gallery { overflow: hidden; } .fancybox .image-caption { font-size: 0.8125rem; padding-top: 0.4rem; padding-bottom: 0.4rem; color: rgba(68,68,68,0.65); } .article mjx-container { font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; background: rgba(255,255,255,0); padding: 16px 8px; border-radius: 4px; min-width: 0 !important; } .article mjx-container[jax=\"CHTML\"][display=\"true\"], .article .has-jax { overflow: auto hidden; } .article mjx-container + br { display: none; } #loading-bar-wrapper { position: fixed; width: 100%; top: 0; height: 2px; z-index: 99999; } .loading-circle { display: none; height: 100%; width: 100%; position: fixed; top: 0; left: 0; z-index: 999999; background-color: rgba(250,250,250,0.9); } .loading-circle img { width: 280px; height: 210px; position: relative; top: 45%; left: 50%; margin-left: -140px; margin-top: -105px; } #loader-circle { display: block; position: relative; left: 50%; top: 50%; width: 150px; height: 150px; margin: -75px 0 0 -75px; border-radius: 50%; border: 3px solid transparent; border-top-color: #ff5a5a; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; } #loader-circle:before { content: \"\"; position: absolute; top: 5px; left: 5px; right: 5px; bottom: 5px; border-radius: 50%; border: 3px solid transparent; border-top-color: #5af33f; -webkit-animation: spin 3s linear infinite; animation: spin 3s linear infinite; } #loader-circle:after { content: \"\"; position: absolute; top: 15px; left: 15px; right: 15px; bottom: 15px; border-radius: 50%; border: 3px solid transparent; border-top-color: #6dc9ff; -webkit-animation: spin 2s linear infinite; animation: spin 2s linear infinite; } @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg); } } @-moz-keyframes spin { 0% { -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg); } } @-webkit-keyframes spin { 0% { -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg); } } @-o-keyframes spin { 0% { -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg); } } @keyframes spin { 0% { -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg); } } .l_main #comments { position: relative; } .l_main #comments #valine_container >i { display: block; margin: 16px auto; } .l_main #comments #valine_container img { display: inline; } .l_main #comments #valine_container .vwrap { border-radius: 8px; border-style: dashed; border: 1px dashed rgba(68,68,68,0.3); transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main #comments #valine_container .vwrap:hover { border: 1px dashed #2196f3; } .l_main #comments #valine_container .vwrap .cancel-reply { margin-top: 0; margin-bottom: 0; } .l_main #comments #valine_container .vwrap .vheader .vinput { border-radius: 0; border-bottom: 1px dashed rgba(68,68,68,0.3); } .l_main #comments #valine_container .vwrap .vheader .vinput:hover { border-bottom: 1px dashed #2196f3; } .l_main #comments #valine_container .vwrap .vheader .vinput:focus { border-bottom: 1px solid #2196f3; } .l_main #comments #valine_container .vwrap .vedit .vicon { height: 22px; } .l_main #comments #valine_container .vwrap .vemojis, .l_main #comments #valine_container .vwrap .vpreview { background: #f6f6f6; border-radius: 4px; padding: 8px; } .l_main #comments #valine_container .vwrap .vemojis::-webkit-scrollbar, .l_main #comments #valine_container .vwrap .vpreview::-webkit-scrollbar { height: 4px; width: 4px; } .l_main #comments #valine_container .vwrap .vemojis::-webkit-scrollbar-track-piece, .l_main #comments #valine_container .vwrap .vpreview::-webkit-scrollbar-track-piece { background: transparent; } .l_main #comments #valine_container .vwrap .vemojis::-webkit-scrollbar-thumb, .l_main #comments #valine_container .vwrap .vpreview::-webkit-scrollbar-thumb { background: rgba(118,118,118,0.4); cursor: pointer; border-radius: 2px; } .l_main #comments #valine_container .vwrap .vemojis::-webkit-scrollbar-thumb:hover, .l_main #comments #valine_container .vwrap .vpreview::-webkit-scrollbar-thumb:hover { background: #767676; } .l_main #comments #valine_container .vwrap .vemojis .vemoji, .l_main #comments #valine_container .vwrap .vpreview .vemoji { max-height: 22px; max-width: 100px; } .l_main #comments #valine_container .vwrap .vemojis i, .l_main #comments #valine_container .vwrap .vpreview i { width: auto; padding: 8px; border-radius: 4px; transition: box-shadow 0.2s ease-out, background 0.2s ease-out; } .l_main #comments #valine_container .vwrap .vemojis i:hover, .l_main #comments #valine_container .vwrap .vpreview i:hover { background: #fbfbfb; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(255,255,255,0.5), inset 8px 8px 16px rgba(0,0,0,0.05), inset -8px -8px 16px rgba(255,255,255,0.4); } .l_main #comments #valine_container .vwrap .vemojis i:active, .l_main #comments #valine_container .vwrap .vpreview i:active { background: #f1f1f1; box-shadow: 0px 0px 0px rgba(0,0,0,0.1), 0px 0px 0px rgba(255,255,255,0.8), inset 2px 2px 4px rgba(0,0,0,0.1), inset -2px -2px 4px #fff, inset -8px -8px 16px rgba(255,255,255,0.4); } .l_main #comments #valine_container .vwrap .vedit .vctrl span { padding: 0; margin: 10px; } .l_main #comments #valine_container .vwrap .vedit span { fill: #555; } .l_main #comments #valine_container .vwrap .vedit span.actived { fill: #2196f3; } .l_main #comments #valine_container .vcount { color: #555; font-size: 0.875rem; padding: 0; font-weight: inherit; } .l_main #comments #valine_container .vcount .vnum { color: #555; font-size: 1.375rem; } .l_main #comments #valine_container button { border: none; padding: 4px 2rem; border-radius: 4px; background: #f1f1f1; color: #444; line-height: 2; font-size: 14px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main #comments #valine_container button:hover { color: #ff5722; background: #ffeee8; } .l_main #comments #valine_container button.vmore { width: 100%; padding: 8px 2rem; } .l_main #comments #valine_container .vcards .vquote { border-left: none; } .l_main #comments #valine_container .vcards .vh { border-bottom: 1px dashed rgba(68,68,68,0.1); } .l_main #comments #valine_container .vcards .vimg { border: 1px solid #fff; padding: 0; background: #f6f6f6; } .l_main #comments #valine_container .vcards .vcontent.expand:before { background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(246,246,246,0.9)); } .l_main #comments #valine_container .vcards .vcontent.expand:after { background: rgba(246,246,246,0.9); color: #444; } .l_main #comments #valine_container .vcards .vhead span.vnick { color: #6e6e6e; cursor: default; } .l_main #comments #valine_container .vcards .vhead a.vnick { color: #ff9800; font-weight: bold; } .l_main #comments #valine_container .vcards .vhead a.vnick:hover { color: #ff5722; } .l_main #comments #valine_container .vcards .vhead .vsys { margin: 2px; padding: 1px 8px; background-color: #f6f6f6; } .l_main #comments #valine_container .vcards .vmeta .vat { font-weight: bold; color: #2196f3; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main #comments #valine_container .vcards .vmeta .vat:hover { color: #ff5722; text-decoration: underline; } .l_main #comments #valine_container .vcards .vcontent blockquote { padding-top: 0.4rem; padding-bottom: 0.4rem; background: #e8f4fd; border-left: 4px solid #2196f3; border-radius: 4px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main #comments #valine_container .vcards .vcontent code { color: #555; font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; } .l_main #comments #valine_container .vcards .vcontent pre { background: #f6f6f6; } .l_main #comments #valine_container .vcards .vcontent pre code { border: none; } .l_main #comments #valine_container .vcards .vcontent a { color: #2196f3; line-height: inherit; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main #comments #valine_container .vcards .vcontent a:hover { color: #ff5722; text-decoration: underline; } .l_main #comments #valine_container .vcards .vcontent p { color: #555; margin-top: 0.4rem; margin-bottom: 0.4rem; line-height: inherit; } .l_main #comments #valine_container .vcards .vcontent .vemoji { max-height: 24px; border-radius: 0; margin-top: -10px; max-width: 100px; } .l_main #comments #valine_container .vempty { color: rgba(68,68,68,0.65); } .l_main #comments #valine_container .vpower, .l_main #comments #valine_container .vpower a { font-size: 0.75rem; } .l_main #comments #valine_container .vpower a { color: #555; } .l_main #comments #valine_container .vpower a:hover { text-decoration: underline; color: #ff5722; } .l_main #comments #valine_container .vinput { color: #444; } .l_main #comments #valine_container p { color: #444; } #archive-page { margin-bottom: 32px; } #archive-page .archive .archive-year { margin-top: 4em; margin-bottom: 1em; } #archive-page .archive .archive-year:first-child { margin-top: 0em; padding-top: 0; } #archive-page .archive .archive-year h2 { margin-top: 1em; } #archive-page .archive .archive-post a { color: #444; width: 100%; display: inline-flex; flex-flow: row nowrap; justify-content: flex-start; align-items: flex-start; background: transparent; border-left: 2px solid transparent; border-radius: 2px; vertical-align: middle; font-size: 0.875rem; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } #archive-page .archive .archive-post a.child { padding-left: 32px; } #archive-page .archive .archive-post a:hover { background: #e8f4fd; border-left: 2px solid #2196f3; } #archive-page .archive .archive-post a:active { border-left: 4px solid #2196f3; } #archive-page .archive .archive-post time { flex: none; vertical-align: middle; padding: 0.4em; padding-left: 2em; color: rgba(68,68,68,0.65); } @media screen and (max-width: 500px) { #archive-page .archive .archive-post time { padding-left: 1em; } } #archive-page .archive .archive-post .title { flex: auto; padding: 0.4em; } #archive-page .archive .archive-post .title i { color: #ff5722; } #archive-page .archive .archive-post .title i.red { color: #fe5f58; } #archive-page .archive .archive-post .title i.green { color: #3dc550; } #archive-page .archive .archive-post .title i.yellow { color: #ffbd2b; } #archive-page .archive .archive-post .title i.blue { color: #1bcdfc; } #archive-page .archive .archive-post .title i.theme { color: #2196f3; } #archive-page .archive .archive-post .title i.accent { color: #ff5722; } #archive-page .archive .archive-post .title i.orange { color: #ff5722; } #archive-page .archive .all-categories time { color: #444; } #archive-page .archive .all-categories .title { color: rgba(68,68,68,0.65); } #archive-page .archive .all-tags { display: flex; flex-wrap: wrap; align-items: flex-start; justify-content: flex-start; align-items: baseline; word-spacing: 8px; text-align: center; } #archive-page .archive .all-tags >a { color: rgba(68,68,68,0.65); margin-right: 16px; } #archive-page .archive .all-tags >a:hover, #archive-page .archive .all-tags >a:active, #archive-page .archive .all-tags >a.active { color: #ff5722 !important; } .article .article-entry >a:hover, .article .article-entry >p>a:hover, .article .article-entry blockquote a:hover, .article .article-entry div.note a:hover { text-decoration: underline; } .article .article-entry >ul>li >a:hover, .article .article-entry >ol>li >a:hover, .article .article-entry tbody tr td >a:hover, .article .article-entry >ul>li >p>a:hover, .article .article-entry >ol>li >p>a:hover, .article .article-entry tbody tr td >p>a:hover { text-decoration: underline; } .article .article-entry div.tab-pane >p >a:hover, .article .article-entry div.tab-pane li >a:hover { text-decoration: underline; } .article { color: #555; word-wrap: break-word; } .article img { position: relative; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .article img.inline { display: inline; vertical-align: middle; transform: translateY(-4px); } @media screen and (max-width: 500px) { .article img { box-shadow: none; } } .article div>img, .article p>img { display: block; margin: auto; border-radius: 4px; } @media screen and (max-width: 500px) { .article div>img, .article p>img { border-radius: 2px; } } .article span img { display: inline; margin: auto; } .article a { word-break: break-word; } .article h1:first-child, .article h2:first-child, .article h3:first-child, .article h4:first-child, .article h5:first-child, .article h6:first-child { margin-top: 0.4rem; padding-top: 0; } .article h1.title, .article h2.title, .article h3.title, .article h4.title, .article h5.title, .article h6.title { left: 0; } .article h1.title:before, .article h2.title:before, .article h3.title:before, .article h4.title:before, .article h5.title:before, .article h6.title:before { content: none; } .article h1, .article h2 { padding-bottom: 0.2em; margin-bottom: 0.5em; border-bottom: 1px solid rgba(68,68,68,0.1); } .article h1 { text-align: left; color: #444; margin-top: 48px; } .article h2 { text-align: left; color: #444; margin-top: 48px; } .article h3 { text-align: left; color: #444; margin-top: 24px; } .article h4 { text-align: left; color: #444; margin-top: 16px; } .article h5 { font-weight: bold; color: #444; margin-top: 0.6rem; } .article h6 { color: #444; margin-top: 0.6rem; } .article center, .article center p { text-align: center; } .article .aplayer { margin: 0.4rem 0; display: inline-block; width: 400px; max-width: 100%; border-radius: 4px; color: #666; } .article p.small-img img, .article div.small-img img { width: auto; max-width: 100%; margin: 0; box-shadow: none; } .article s, .article del { opacity: 0.7; } .article u { color: #ff5722; } .article psw { color: #6e6e6e; background: #6e6e6e; border-radius: 2px; } .article psw:hover { background: none; } .article kbd { border-radius: 2px; border: 1px solid #e7e7e7; background: #f6f6f6; padding-left: 4px; padding-right: 4px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .article kbd:hover { cursor: default; border-color: #2196f3; background: #2196f3; color: #fff; } .article p { margin-top: 0.6rem; margin-bottom: 0.6rem; text-align: justify; max-width: 100%; line-height: inherit; } .article ul, .article ol { font-size: 95%; list-style: initial; padding-left: 8px; margin-left: 16px; margin-top: 2px; margin-bottom: 2px; } .article ul ul, .article ol ul, .article ul ol, .article ol ol { margin-top: 0; margin-bottom: 0; } .article ul li, .article ol li { margin-top: 0px; margin-bottom: 0px; } .article ul li li, .article ol li li { margin-top: 0; margin-bottom: 0; } .article ul li p, .article ol li p { margin-top: 4px; margin-bottom: 0; } .article ul.task-list, .article ol.task-list { padding-left: 0; margin-left: 4px; } .article ul.task-list li, .article ol.task-list li { list-style: none; } .article ul.task-list li input, .article ol.task-list li input { margin-right: 4px; } .article ul>li { list-style: initial; } .article ol>li { list-style: decimal; } .article .subtitle h6 { color: rgba(68,68,68,0.9); } .article figure figcaption span { display: inline-block; margin-right: 5px; } .article blockquote { background: #e8f4fd; border-left: 4px solid #2196f3; border-radius: 4px; } .article blockquote { position: relative; width: 100%; padding: 0.5rem 16px 0.4rem 16px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .article blockquote, .article blockquote p, .article blockquote ul, .article blockquote ol { text-align: left; word-wrap: normal; font-size: 95%; margin-top: 0.4rem; margin-bottom: 0.4rem; } .article blockquote footer { padding: 0; text-align: justify; color: inherit; font-style: italic; margin: 0.4rem 0; } .article blockquote footer cite { color: rgba(68,68,68,0.65); margin-left: 1em; } .article blockquote footer cite::before { content: '----'; padding: 0 0.3em; } .article blockquote.pullquote.right { border-left: none; border-right: 4px solid #2196f3; } .article blockquote.pullquote.right p { text-align: right; } .article pre { display: block; -moz-box-sizing: border-box; box-sizing: border-box; margin-top: 0.4rem; margin-bottom: 0.4rem; overflow: auto; background: #f6f6f6; font-size: 0.8125rem; font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; border: 1px solid #e7e7e7; padding: 16px; border-radius: 4px; } .article pre >code:not([class]) { background: transparent; } .article div>pre { border-radius: 4px; } .article div>pre>code:not([class]) { padding: 0; margin: 0; background: transparent; color: rgba(68,68,68,0.9); } .article code { font-family: Menlo, UbuntuMono, Monaco, monospace, courier, sans-serif; } .article code:not([class]) { padding: 3px 4px 1px 4px; vertical-align: middle; font-size: 0.8125rem; background: #f6f6f6; border-radius: 2px; border: 1px solid #e7e7e7; } @media screen and (max-width: 500px) { .article ul, .article ol { font-size: 0.875rem; } .article figure { font-size: 13px; line-height: 1.5; } } .article .widget { background: transparent; margin: 0.4rem 0; box-shadow: none; border-radius: 4px; cursor: auto; background: #f6f6f6; padding: 8px 0; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; width: 100%; } .article .widget:hover { box-shadow: none; } .article .widget:active { box-shadow: none; } .article .widget header { padding: 4px 0.6em; padding-bottom: 0; } .article .widget header, .article .widget header a { color: rgba(68,68,68,0.85); } .article .widget.copyright, .article .widget.qrcode { background: none; padding: 0; } .article .widget.copyright header, .article .widget.qrcode header { display: none; } .article .widget.copyright .content, .article .widget.qrcode .content { padding: 0; } .article .widget.list .content, .article .widget.related_posts .content { padding: 0 0.6em !important; } .article .widget .content { padding: 0 0.6em; margin: 0; } .article .widget .content ul { padding-left: 9px; margin-left: 16px; } .article .widget .content ul a { display: inline; border-left: none; padding: 0; padding-left: 4px; color: #2196f3; font-weight: normal; } .article .widget .content ul a:hover { text-decoration: underline; color: #ff5722; } .article .widget .content ul a:hover, .article .widget .content ul a.active, .article .widget .content ul a:active { border-left: none !important; background: none !important; } .article .widget .content .list a .name { display: inline; color: #2196f3; } .article .widget .content .list a:hover .name { text-decoration: underline; color: #ff5722; } .article .widget.qrcode > .content { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; padding-left: 16px; padding-right: 16px; margin-bottom: 4px; } .article .widget.qrcode > .content>.fancybox, .article .widget.qrcode > .content>img { margin: 0 8px; } .article .widget.qrcode > .content img { margin-bottom: 4px; } .article .article_footer { margin-top: 64px; } .article .widget-blur { backdrop-filter: none; } .article .article-entry> h1, .article .article-entry> h2, .article .article-entry> h3, .article .article-entry> h4, .article .article-entry> h5, .article .article-entry> h6 { position: relative; pointer-events: none; margin-top: 0; margin-bottom: 0.6rem; } .article .article-entry> h1 >a, .article .article-entry> h2 >a, .article .article-entry> h3 >a, .article .article-entry> h4 >a, .article .article-entry> h5 >a, .article .article-entry> h6 >a { color: inherit; pointer-events: auto; } .article .article-entry> h1 >a:hover, .article .article-entry> h2 >a:hover, .article .article-entry> h3 >a:hover, .article .article-entry> h4 >a:hover, .article .article-entry> h5 >a:hover, .article .article-entry> h6 >a:hover { color: #ff5722; } .article .article-entry> h1:before, .article .article-entry> h2:before, .article .article-entry> h3:before, .article .article-entry> h4:before, .article .article-entry> h5:before, .article .article-entry> h6:before { content: ''; display: block; margin-top: -80px; height: 80px; visibility: hidden; pointer-events: none; } .article .article-entry> h1:before, .article .article-entry> h2:before { margin-top: -32px; } .article .article-entry> h3:before { margin-top: -56px; } .article .article-entry> h4:before { margin-top: -64px; } .article .article-entry> h5 { font-weight: bold; } .article .article-entry> p { font-size: 0.9375rem; } article .readmore { margin-top: 0.6rem; } article .readmore >a { font-size: 0.875rem; } .cover-wrapper .cover { top: 0; left: 0; max-width: 100%; height: 100vh; display: flex; flex-wrap: nowrap; flex-direction: column; align-items: center; align-self: center; align-content: center; color: #555; padding: 16px; } .cover-wrapper .cover .cover-body div.b { margin-top: 8vh; margin-bottom: 8vh; } .cover-wrapper .cover.half { margin-bottom: -100px; max-height: 640px; min-height: 400px; height: calc(36vh - 64px + 200px); } .cover-wrapper .cover.half .cover-body div.b { margin-top: 10%; margin-bottom: 0; } @media screen and (max-width: 500px) { .cover-wrapper .cover.half .cover-body div.a { margin-top: 10%; } } .cover-wrapper .cover .scroll-down { width: 100%; height: 64px; position: absolute; bottom: 0; text-align: center; cursor: pointer; } .cover-wrapper .cover .scroll-down .scroll-down-effects { color: #fff; font-size: 24px; line-height: 64px; position: absolute; width: 24px; left: calc(50% - 12px); text-shadow: 0 1px 2px rgba(0,0,0,0.1); animation: scroll-down-effect 1.5s infinite; } @-moz-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; } 50% { top: -16px; opacity: 0.4; } 100% { top: 0; opacity: 1; } } @-webkit-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; } 50% { top: -16px; opacity: 0.4; } 100% { top: 0; opacity: 1; } } @-o-keyframes scroll-down-effect { 0% { top: 0; opacity: 1; } 50% { top: -16px; opacity: 0.4; } 100% { top: 0; opacity: 1; } } @keyframes scroll-down-effect { 0% { top: 0; opacity: 1; } 50% { top: -16px; opacity: 0.4; } 100% { top: 0; opacity: 1; } } .cover-wrapper .cover .cover-body { margin: auto; } .cover-wrapper .cover .cover-body, .cover-wrapper .cover .cover-body div.a, .cover-wrapper .cover .cover-body div.b { display: flex; flex-direction: column; align-items: center; justify-content: center; max-width: 100%; } .cover-wrapper .cover .cover-body .title { font-family: \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Helvetica, monospace; font-size: 3rem; line-height: 1.2; } .cover-wrapper .cover .cover-body .subtitle { font-size: 0.875rem; } .cover-wrapper .cover .cover-body .logo { max-height: 100px; max-width: calc(100% - 4 * 16px); } @media screen and (min-height: 1024px) { .cover-wrapper .cover .cover-body .title { font-size: 3.6rem; } .cover-wrapper .cover .cover-body .subtitle { font-size: 1.05rem; } .cover-wrapper .cover .cover-body .logo { max-height: 150px; } } .cover-wrapper .cover .cover-body .m_search { position: relative; max-width: calc(100% - 16px); width: 320px; vertical-align: middle; } .cover-wrapper .cover .cover-body .m_search .form { position: relative; display: block; width: 100%; } .cover-wrapper .cover .cover-body .m_search .icon, .cover-wrapper .cover .cover-body .m_search .input { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .cover-wrapper .cover .cover-body .m_search .icon { position: absolute; display: block; line-height: 2.5rem; width: 32px; top: 0; left: 5px; color: rgba(85,85,85,0.75); } .cover-wrapper .cover .cover-body .m_search .input { display: block; height: 2.5rem; width: 100%; box-shadow: none; box-sizing: border-box; font-size: 0.875rem; -webkit-appearance: none; padding-left: 36px; border-radius: 1.4rem; background: rgba(255,255,255,0.6); backdrop-filter: blur(10px); border: none; color: #444; } @media screen and (max-width: 500px) { .cover-wrapper .cover .cover-body .m_search .input { padding-left: 36px; } } .cover-wrapper .cover .cover-body .m_search .input:hover { background: rgba(255,255,255,0.8); } .cover-wrapper .cover .cover-body .m_search .input:focus { background: #fff; } .cover-wrapper .cover .cover-body .menu { margin-top: 16px; } .cover-wrapper .cover .cover-body .menu ul { display: flex; flex-wrap: wrap; align-items: baseline; justify-content: center; } .cover-wrapper .cover .cover-body .menu ul li { display: flex; flex-wrap: wrap; align-items: center; padding: 0; height: auto; } .cover-wrapper .cover .cover-body .menu ul>li>a { font-size: 0.875rem; padding: 2px; margin: 4px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; color: rgba(85,85,85,0.65); text-shadow: 0 1px 2px rgba(0,0,0,0.05); border-bottom: 2px solid transparent; } .cover-wrapper .cover .cover-body .menu ul>li>a i { margin-right: 4px; } .cover-wrapper .cover .cover-body .menu ul>li>a:hover, .cover-wrapper .cover .cover-body .menu ul>li>a.active, .cover-wrapper .cover .cover-body .menu ul>li>a:active { color: #555; border-bottom: 2px solid #555; } .cover-wrapper .cover .cover-body .switcher > li a:hover { background: rgba(68,68,68,0.15); } footer { position: relative; padding: 40px 10px 120px 10px; width: 100%; color: rgba(102,102,102,0.5); margin: 0px auto; overflow: hidden; text-align: center; } footer, footer p { font-size: 0.8125rem; } footer .licenses { color: fade(, 50%); text-decoration: underline; } footer .codename { text-decoration: underline; } footer .social-wrapper { display: flex; justify-content: center; flex-wrap: wrap; margin: 4px 8px; font-size: 16px; } footer a { color: rgba(102,102,102,0.75); padding: 0; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } footer a:hover { color: #666; } footer a.social { position: relative; display: inline-block; text-align: center; display: flex; justify-content: center; align-items: center; width: 36px; height: 36px; margin: 4px; border-radius: 100px; color: rgba(102,102,102,0.75); } footer a.social:hover { background: rgba(102,102,102,0.1); color: #666; } footer .copyright { margin-top: 16px; } footer .copyright p { font-size: 0.75rem; } @media screen and (max-width: 768px) { footer { justify-content: center; } } .article.article-entry.l_friends .friends-group .friend-content { display: flex; flex-wrap: wrap; margin: -8px; border-radius: 8px; align-items: flex-start; line-height: 1.3; } .article.article-entry.l_friends .friends-group .friend-content .friend-card { display: flex; border-radius: 4px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); padding: 8px 0; margin: 8px; margin-top: calc(2.25 * 16px + 32px); color: rgba(68,68,68,0.65); background: #f6f6f6; justify-content: flex-start; align-content: flex-start; flex-direction: column; width: calc(100%/4 - 16px); } @media screen and (max-width: 1024px) { .article.article-entry.l_friends .friends-group .friend-content .friend-card { width: calc(100%/4 - 16px); } } @media screen and (max-width: 768px) { .article.article-entry.l_friends .friends-group .friend-content .friend-card { width: calc(100%/3 - 16px); } } @media screen and (max-width: 500px) { .article.article-entry.l_friends .friends-group .friend-content .friend-card { width: calc(100%/2 - 16px); } } .article.article-entry.l_friends .friends-group .friend-content .friend-card:hover .friend-left .avatar { transform: scale(1.2) rotate(12deg); box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-left { display: flex; align-self: center; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-left .avatar { width: 64px; height: 64px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); margin: 16px 8px 4px 8px; margin-top: calc(-1.25 * 16px - 32px); border-radius: 100%; border: 2px solid #fff; background: #fff; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right { margin: 4px 8px; display: flex; flex-direction: column; text-align: center; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right p { text-align: center; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right .friend-tags-wrapper { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; margin-left: -2px; word-break: break-all; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right p { margin: 0; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right p.friend-name { font-size: 0.8125rem; padding-top: 4px; font-weight: bold; } .article.article-entry.l_friends .friends-group .friend-content .friend-card .friend-right p.tags { font-size: 0.75rem; display: inline; background: none; word-wrap: break-word; padding-right: 4px; } .l_body { position: relative; margin: 16px; } .l_body.nocover { margin-top: 64px; } @media screen and (max-width: 425px) { .l_body { margin: 80px 0 16px; } .l_body.nocover { margin-top: 48px; } } .l_body .s-top { transition: all 0.6s ease; -moz-transition: all 0.6s ease; -webkit-transition: all 0.6s ease; -o-transition: all 0.6s ease; z-index: 9; position: fixed; width: 48px; height: 48px; line-height: 48px; border-radius: 100%; bottom: 32px; right: 32px; transform: translateY(100px) scale(0); transform-origin: bottom; color: #444; } @media screen and (max-width: 768px) { .l_body .s-top { right: 16px; } } .l_body .s-top.show { transform: translateY(0) scale(1); } .l_body .s-top.show.hl { background: #2196f3; color: #fff; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } @media screen and (min-width: 768px) { .l_body .s-top:hover { transform: scale(1.2); border-radius: 25%; background: #2196f3; color: #fff; box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } .l_body .s-top:hover.hl { box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } } .l_main { width: calc(100% - 1 * 240px); padding-right: 16px; float: left; } @media screen and (max-width: 768px) { .l_main { width: 100%; } } .l_main.no_sidebar { width: 100%; padding-right: 0; max-width: 840px; margin: auto; } @media screen and (min-width: 2048px) { .l_main.no_sidebar { max-width: calc(55vw - 240px); } } .l_main.no_sidebar ~.l_side { display: none; } .l_main .post-list { position: relative; margin: 16px auto; column-gap: 16px; } .l_main .post-list.multiple-columns { columns: 320px; } .l_main .post-wrapper { column-break-inside: avoid; break-inside: avoid-column; } .l_main .post-wrapper { margin-bottom: 16px; } .l_main .post-wrapper .post div.meta { margin-bottom: 16px; } .l_main .post-wrapper .post div.meta .title { font-size: 1.375rem; } .l_main .post-wrapper .post div.meta .title a { font-size: 1.375rem; } @media screen and (max-width: 500px) { .l_main .post-wrapper .post div.meta .title { font-size: 1.25rem; } } @media screen and (max-width: 500px) and (max-width: 500px) { .l_main .post-wrapper .post { padding: 24px 16px; } } .l_main .widget .content p, .l_main .widget .content ul, .l_main .widget .content ol, .l_main .widget .content table, .l_main .widget .content .tabs, .l_main .widget .content details { margin-top: 0.4rem; margin-bottom: 0.4rem; } .l_main .widget .content .post { padding-top: 0; padding-bottom: 0; margin-top: 0.4rem; margin-bottom: 0.4rem; } .l_main .widget.grid .content .grid.fixed a { width: calc(100%/8 - 0 * 16px); } @media screen and (max-width: 1024px) { .l_main .widget.grid .content .grid.fixed a { width: calc(100%/7 - 0 * 16px); } } @media screen and (max-width: 768px) { .l_main .widget.grid .content .grid.fixed a { width: calc(100%/6 - 0 * 16px); } } @media screen and (max-width: 500px) { .l_main .widget.grid .content .grid.fixed a { width: calc(100%/5 - 0 * 16px); } } @media screen and (max-width: 425px) { .l_main .widget.grid .content .grid.fixed a { width: calc(100%/4 - 0 * 16px); } } @media screen and (max-width: 375px) { .l_main .widget.grid .content .grid.fixed a { width: calc(100%/3 - 0 * 16px); } } .l_main .post { position: relative; margin: 16px auto; padding: 24px; border-radius: 8px; } @media screen and (max-width: 425px) { .l_main .post { border-radius: 0; } } .l_main .post h1 { font-weight: normal; font-size: 1.625rem; } .l_main .post section.meta { color: rgba(68,68,68,0.65); margin-bottom: 16px; line-height: normal; } .l_main .post section.meta#header-meta { margin-top: 0; margin-bottom: 16px; } .l_main .post section.meta#footer-meta { margin-top: 32px; margin-bottom: 8px; } .l_main .post section.meta .aplayer, .l_main .post section.meta .thumbnail { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; width: 65px; height: 65px; border-radius: 100%; float: right; margin: 4px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } .l_main .post section.meta .aplayer:hover, .l_main .post section.meta .thumbnail:hover { border-radius: 25%; transform: scale(1.1); box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); } @media screen and (max-width: 500px) { .l_main .post section.meta .aplayer:hover, .l_main .post section.meta .thumbnail:hover { border-radius: 100%; transform: scale(1); box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } } .l_main .post section.meta .thumbnail { width: auto; border-radius: 4px; box-shadow: none; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main .post section.meta .thumbnail:hover { border-radius: 4px; transform: scale(1.1) rotate(4deg); box-shadow: none; } .l_main .post section.meta .title { transition: all 0.1s ease; -moz-transition: all 0.1s ease; -webkit-transition: all 0.1s ease; -o-transition: all 0.1s ease; margin: 0; color: #444; } .l_main .post section.meta .title p.h1, .l_main .post section.meta .title p.h2 { margin-top: 1rem; border-bottom: none; } .l_main .post section.meta .title p.h1 { font-size: 1.7875rem; } .l_main .post section.meta .title p.h2 { font-size: 1.5125rem; } .l_main .post section.meta .title a { display: inline; font-weight: normal; color: #444; } .l_main .post section.meta .title a:hover { color: #ff5722; } .l_main .post section.meta .new-meta-box { transition: all 0.1s ease; -moz-transition: all 0.1s ease; -webkit-transition: all 0.1s ease; -o-transition: all 0.1s ease; padding-top: 4px; padding-bottom: 8px; display: flex; align-items: center; flex-wrap: wrap; -webkit-font-smoothing: auto; -moz-osx-font-smoothing: auto; } .l_main .post section.meta .new-meta-box, .l_main .post section.meta .new-meta-box p, .l_main .post section.meta .new-meta-box i { font-size: 0.8125rem; } .l_main .post section.meta .new-meta-box .new-meta-item { color: rgba(68,68,68,0.65); display: flex; align-items: baseline; justify-content: center; margin: 0 16px 0 0; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns { display: flex; flex-wrap: wrap; justify-content: flex-start; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn { color: #fff; padding: 1px 4px; border-radius: 2px; margin: 2px; line-height: 1.5; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn:hover { box-shadow: 0 4px 8px 0 rgba(0,0,0,0.1), 0 8px 16px 0 rgba(0,0,0,0.1); } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn i { padding-left: 3px; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn p { color: #fff; padding-top: 3px; padding-right: 2px; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn:hover { color: #fff; } .l_main .post section.meta .new-meta-box .new-meta-item.link-btns .btn:hover p { color: #fff; } .l_main .post section.meta .new-meta-box .new-meta-item .notlink { cursor: default; } .l_main .post section.meta .new-meta-box .new-meta-item .notlink:hover { color: rgba(68,68,68,0.65); } .l_main .post section.meta .new-meta-box .new-meta-item .notlink:hover p { color: rgba(68,68,68,0.65); } .l_main .post section.meta .new-meta-box .new-meta-item:last-child { margin-right: 0; } .l_main .post section.meta .new-meta-box .new-meta-item img, .l_main .post section.meta .new-meta-box .new-meta-item i { display: inline; } .l_main .post section.meta .new-meta-box .new-meta-item i { margin-right: 4px; border-radius: 0; } .l_main .post section.meta .new-meta-box .new-meta-item i.fa-hashtag { margin-right: 2px; } .l_main .post section.meta .new-meta-box .new-meta-item p, .l_main .post section.meta .new-meta-box .new-meta-item a { color: rgba(68,68,68,0.65); padding: 3px 0; } .l_main .post section.meta .new-meta-box .new-meta-item a { display: flex; justify-content: center; align-items: center; } .l_main .post section.meta .new-meta-box .new-meta-item a img { height: 16px; width: 16px; margin-right: 5px; } .l_main .post section.meta .new-meta-box .new-meta-item a p { margin: 0; font-weight: normal; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_main .post section.meta .new-meta-box .new-meta-item a:hover { color: #ff5722; } .l_main .post section.meta .new-meta-box .new-meta-item a:hover p { color: #ff5722; } .l_main .post section.meta .new-meta-box .author img, .l_main .post section.meta .new-meta-box .author i { border-radius: 100%; } .l_main .post section.meta .new-meta-box .author img { transform: translateY(-0.5px); } @media screen and (max-width: 500px) { .l_main .post section.meta .new-meta-box .share { width: 100%; margin-top: 16px; background: #f6f6f6; } } .l_main .post section.meta .new-meta-box .share-body { position: relative; display: flex; justify-content: center; margin: 0; padding: 0 2px; border-radius: 2px; } .l_main .post section.meta .new-meta-box .share-body a { padding: 0; margin: 0 1px; } .l_main .post section.meta .new-meta-box .share-body a img { margin: 2px; height: 24px; width: auto; background: transparent; } @media screen and (max-width: 500px) { .l_main .post section.meta .new-meta-box .share-body a img { height: 32px; margin: 8px; } } .l_main .post span>img { display: inline-block; } .l_main .post a img { display: inline; } @media screen and (max-width: 768px) { .l_main { padding-right: 0; } .l_main .post div.meta .title { font-size: 1.25rem; } } @media screen and (max-width: 768px) and (max-width: 500px) { .l_main { width: 100%; } } @media screen and (max-width: 768px) and (max-width: 500px) { .l_main .post { padding: 24px 16px; } } .body-wrapper { position: relative; display: flex; width: 100%; max-width: 1080px; margin: 0 auto; flex-wrap: wrap; justify-content: space-between; align-items: stretch; } @media screen and (min-width: 2048px) { .body-wrapper { max-width: 55vw; } } div.hoverbox >div.target { display: none; position: absolute; background: #fff; border-radius: 8px; box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1); padding: 8px; left: 50%; top: -20px; transform: translate(-50%, -100%); } div.hoverbox >div.target >img { margin: 0; padding: 0; height: 128px; width: 128px; min-width: 128px; } div.hoverbox:hover >div.target { display: flex; } @media screen and (max-width: 500px) { div.hoverbox >div.target { position: absolute; } } .comments .article p[ct] { margin-top: 0; margin-bottom: 0.4rem; font-size: 1.125rem; color: #444; } .comments .article p[cst] { margin-top: 0.4rem; margin-bottom: 0.4rem; font-size: 0.875rem; } .white-box { background: #fff; } .reveal { visibility: hidden; } .l_header { position: fixed; z-index: 1000; top: 0; width: 100%; height: 64px; background: #fff; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); } .l_header.hide { transform: translateY(100px) scale(0); } .l_header.show { transform: translateY(0) scale(1); } .l_header .container { margin-left: 16px; margin-right: 16px; } .l_header .wrapper { height: 100%; -moz-user-select: none; -ms-user-select: none; -webkit-user-select: none; user-select: none; } .l_header .wrapper .nav-main, .l_header .wrapper .nav-sub { display: flex; flex-wrap: nowrap; justify-content: space-between; align-items: center; } .l_header .wrapper .nav-main { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_header .wrapper.sub .nav-main { transform: translateY(-64px); } .l_header .wrapper .nav-sub { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; opacity: 0; width: calc(100% - 2 * 16px); position: absolute; } @media screen and (min-width: 2048px) { .l_header .wrapper .nav-sub { max-width: 55vw; margin: auto; } } .l_header .wrapper.sub .nav-sub { opacity: 1; } .l_header .wrapper .title { position: relative; color: #444; padding-left: 24px; max-height: 64px; } .l_header .wrapper .nav-main .title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 0; line-height: 64px; padding: 0 24px; font-size: 1.25rem; font-family: \"Varela Round\", \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Helvetica, monospace; } .l_header .wrapper .nav-main .title img { height: 64px; } .l_header .nav-sub { max-width: 1080px; margin: auto; } .l_header .nav-sub .title { font-size: 0.9375rem; font-family: UbuntuMono, \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif; line-height: 1.2; max-height: 64px; white-space: normal; flex-shrink: 1; } .l_header .switcher { display: none; line-height: 64px; align-items: center; } .l_header .switcher .s-toc { display: none; } @media screen and (max-width: 768px) { .l_header .switcher .s-toc { display: flex; } } .l_header .switcher >li { height: 48px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; margin: 2px; } @media screen and (max-width: 500px) { .l_header .switcher >li { margin: 0 1px; height: 48px; } } .l_header .switcher >li >a { display: flex; justify-content: center; align-items: center; width: 48px; height: 48px; padding: 0.85em 1.1em; border-radius: 100px; border: none; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; color: #2196f3; } .l_header .switcher >li >a:hover { border: none; } .l_header .switcher >li >a.active, .l_header .switcher >li >a:active { border: none; background: #e8f4fd; } @media screen and (max-width: 500px) { .l_header .switcher >li >a { width: 32px; height: 48px; } } .l_header .nav-sub .switcher { display: flex; } .l_header .m_search { display: flex; height: 64px; width: 240px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } @media screen and (max-width: 1024px) { .l_header .m_search { width: 44px; min-width: 44px; } .l_header .m_search input::placeholder { opacity: 0; } .l_header .m_search:hover { width: 240px; } .l_header .m_search:hover input::placeholder { opacity: 1; } } @media screen and (min-width: 500px) { .l_header .m_search:hover .input { width: 100%; } .l_header .m_search:hover .input::placeholder { opacity: 1; } } @media screen and (max-width: 500px) { .l_header .m_search { min-width: 0; } .l_header .m_search input::placeholder { opacity: 1; } } .l_header .m_search .form { position: relative; display: flex; width: 100%; align-items: center; } .l_header .m_search .icon { position: absolute; width: 32px; left: 5px; color: rgba(68,68,68,0.7); } @media screen and (max-width: 500px) { .l_header .m_search .icon { display: none; } } .l_header .m_search .input { display: block; padding-top: 8px; padding-bottom: 8px; line-height: 1.3; width: 100%; color: #444; background: #fafafa; box-shadow: none; box-sizing: border-box; padding-left: 36px; font-size: 0.875rem; border-radius: 8px; border: none; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } @media screen and (min-width: 500px) { .l_header .m_search .input:focus { box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1); } } @media screen and (max-width: 500px) { .l_header .m_search .input { background: #f6f6f6; padding-left: 8px; border: none; } .l_header .m_search .input:hover, .l_header .m_search .input:focus { border: none; } } @media (max-width: 500px) { .l_header .m_search { left: 0; width: 0; overflow: hidden; position: absolute; background: #fff; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_header .m_search .input { border-radius: 32px; margin-left: 16px; padding-left: 16px; } .l_header.z_search-open .m_search { width: 100%; } .l_header.z_search-open .m_search .input { width: calc(100% - 112px); } } ul.nav-list-h li:hover >ul.list-v, ul.list-v li:hover >ul.list-v { display: block; } ul.nav-list-h { display: flex; align-items: stretch; height: 64px; } ul.nav-list-h>li { position: relative; justify-content: center; } ul.nav-list-h>li >a { height: 100%; line-height: 64px; border-bottom: 2px solid transparent; } ul.list-v { z-index: 1; display: none; position: absolute; background: #fff; box-shadow: 0 0 1px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1); margin-top: -6px; border-radius: 4px; padding: 8px 0; } ul.list-v >hr { margin-top: 8px; margin-bottom: 8px; } ul.list-v >li { white-space: nowrap; word-break: keep-all; } ul.list-v >li.header { font-size: 0.75rem; font-weight: bold; line-height: 2em; color: rgba(68,68,68,0.65); margin: 8px 16px 4px; } ul.list-v >li.header i { margin-right: 8px; } ul.list-v >li ul { margin-left: 0; display: none; margin-top: -40px; } ul.list-v .aplayer-container { min-height: 64px; padding: 6px 16px; } ul.list-v >li>a { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; display: block; color: #696969; font-size: 0.875rem; font-weight: bold; line-height: 33px; padding: 0 20px 0 16px; height: 32px; border-left: 2px solid transparent; text-overflow: ellipsis; } ul.list-v >li>a:hover, ul.list-v >li>a.active, ul.list-v >li>a:active { color: #2196f3; border-left: 2px solid #2196f3; border-bottom: none; } ul.list-v >li>a >i { margin-right: 8px; } ul.list-v >li>a.current { border-left-color: rgba(33,150,243,0.8); border-bottom-color: rgba(33,150,243,0.8); } ul.list-v >li>a:hover { color: #2196f3; border-left-color: #2196f3; border-bottom-color: #2196f3; background: #e8f4fd; } ul.list-v >li>a:active, ul.list-v >li>a.active { color: #2196f3; border-left-color: #2196f3; border-bottom-color: #2196f3; } .l_header .menu >ul>li>a { display: block; padding: 0 8px; } .l_header .menu >ul>li>a >i { margin-right: 4px; } .l_header ul>li>a { color: #696969; } .l_header ul>li>a.current { border-left-color: rgba(33,150,243,0.8); border-bottom-color: rgba(33,150,243,0.8); } .l_header ul>li>a:hover { color: #2196f3; border-left-color: #2196f3; border-bottom-color: #2196f3; background: #e8f4fd; } .l_header ul>li>a:active, .l_header ul>li>a.active { color: #2196f3; border-left-color: #2196f3; border-bottom-color: #2196f3; } .l_header ul>li>a i.music { animation: rotate-effect 1.5s linear infinite; } @-moz-keyframes rotate-effect { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); } } @-webkit-keyframes rotate-effect { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); } } @-o-keyframes rotate-effect { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); } } @keyframes rotate-effect { 0% { transform: rotate(0); } 25% { transform: rotate(90deg); } 50% { transform: rotate(180deg); } 75% { transform: rotate(270deg); } 100% { transform: rotate(360deg); } } .menu-phone li ul.list-v { right: calc(100% - 0.5 * 16px); } .menu-phone li ul.list-v ul { right: calc(100% - 0.5 * 16px); } .l_header .wrapper { max-width: 1080px; margin: auto; } @media screen and (min-width: 2048px) { .l_header .wrapper { max-width: 55vw; } } .l_header .wrapper .menu { flex: 1 1 auto; margin: 0 16px 0 0; } .l_header .wrapper .menu .list-v ul { left: calc(100% - 0.5 * 16px); } .menu-phone { display: none; margin-top: 16px; right: 8px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .menu-phone ul { right: calc(100% - 0.5 * 16px); } @media screen and (max-width: 500px) { .menu-phone { display: block; } } .cover-wrapper .l_header { transition: all 0.5s ease; -moz-transition: all 0.5s ease; -webkit-transition: all 0.5s ease; -o-transition: all 0.5s ease; transform: translateY(-128px); } .cover-wrapper .l_header.show { transform: translateY(0); } @media screen and (min-width: 2048px) { .l_header { max-width: 65vw; left: calc((100% - 65vw) * 0.5); border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; } } @media screen and (max-width: 500px) { .l_header .container { margin-left: 0; margin-right: 0; } .l_header .wrapper .nav-main .title { padding-left: 16px; padding-right: 16px; } .l_header .wrapper .nav-sub { width: 100%; } .l_header .wrapper .nav-sub .title { overflow-y: scroll; margin-top: 2px; padding: 8px 16px; } .l_header .wrapper .switcher { display: flex; margin-right: 8px; } .l_header .menu { display: none; } } @media screen and (max-width: 500px) { .list-v li { max-width: 270px; } } .l_main .prev-next { width: 100%; display: flex; justify-content: space-between; align-items: baseline; color: rgba(68,68,68,0.65); margin: 0; font-size: 0.9375rem; } .l_main .prev-next .prev { text-align: left; border-top-right-radius: 32px; border-bottom-right-radius: 32px; } .l_main .prev-next .next { text-align: right; border-top-left-radius: 32px; border-bottom-left-radius: 32px; } .l_main .prev-next p { margin: 16px; } .l_main .prev-next section { color: rgba(68,68,68,0.65); padding: 16px; border-radius: 8px; } .l_main .prev-next section:hover { color: #ff5722; } @media screen and (max-width: 425px) { .l_main .prev-next section { border-radius: 0; } } .l_main .article .prev-next { width: 100%; display: flex; justify-content: space-between; align-content: flex-start; margin-top: 8px; } .l_main .article .prev-next >a { width: 100%; padding: 8px; color: rgba(68,68,68,0.65); background: #f6f6f6; border-radius: 4px; } .l_main .article .prev-next >a:hover { background: #ffeee8; } .l_main .article .prev-next >a:hover p.title { color: #ff5722; } .l_main .article .prev-next >a p.title { margin: 8px 0.5rem; font-weight: bold; font-size: 1rem; } .l_main .article .prev-next >a p.title >i { width: 1rem; } .l_main .article .prev-next >a p.content { font-size: 0.875rem; margin: 0 0.5rem; text-align: justify; word-break: break-all; } .l_main .article .prev-next >a:only-child { margin-left: 0; margin-right: 0; } .l_main .article .prev-next .prev { margin-left: 0; margin-right: 8px; } .l_main .article .prev-next .prev p.title { text-align: left; } .l_main .article .prev-next .next { margin-left: 8px; margin-right: 0; } .l_main .article .prev-next .next p.title { text-align: right; } #u-search { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; padding: 60px 20px; z-index: 1001; } @media screen and (max-width: 680px) { #u-search { padding: 0px; } } #u-search .modal { position: fixed; height: 80%; width: 100%; max-width: 640px; left: 50%; top: 0; margin: 64px 0px 0px -320px; background: #fff; z-index: 3; border-radius: 4px; overflow: hidden; } @media screen and (max-width: 680px) { #u-search .modal { box-shadow: none; max-width: none; top: 0; left: 0; margin: 0; height: 100%; border-radius: 0; } } #u-search .modal-ajax-content { opacity: 0; visibility: hidden; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } #u-search .modal-ajax-content.loaded { opacity: 1; visibility: visible; } #u-search .modal-header { position: relative; width: 100%; height: 64px; z-index: 3; border-top-left-radius: 4px; border-top-right-radius: 4px; font-size: 16px; box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1); background: #fff; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } @media screen and (max-width: 680px) { #u-search .modal-header { border-radius: 0; padding: 0px; } } #u-search .modal-header .btn-close { display: block; position: absolute; width: 55px; height: 64px; top: 0; right: 0; color: #2196f3; cursor: pointer; text-align: center; line-height: 64px; vertical-align: middle; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; z-index: 2; } #u-search .modal-header .btn-close:hover { transform: rotate(90deg); } #u-search .modal-header .modal-loading { position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: transparent; z-index: 1; } #u-search .modal-header .modal-loading .modal-loading-bar { display: block; position: relative; width: 0%; height: 100%; background: #2196f3; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } #u-search .modal-header #u-search-modal-form { position: relative; width: 100%; height: 100%; z-index: 2; } #u-search .modal-header #u-search-modal-form #u-search-modal-input { margin: 16px 50px; padding: 0 8px; width: calc(100% - 100px - 16px); line-height: 2rem; border-radius: 4px; vertical-align: middle; border: none; appearance: none; box-shadow: none; background: transparent; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } @media screen and (max-width: 680px) { #u-search .modal-header #u-search-modal-form #u-search-modal-input { padding: 0; } } #u-search .modal-header #u-search-modal-form #u-search-modal-input:focus { border-top-left-radius: 4px; border-top-right-radius: 4px; } #u-search .modal-header #u-search-modal-btn-submit { position: absolute; top: 0; left: 0; padding-left: 5px; padding-top: 2px; background: transparent; border: none; width: 50px; height: 64px; vertical-align: middle; color: #2196f3; z-index: 2; } #u-search .modal-footer { position: absolute; display: none; bottom: 0; left: 0; width: 100%; height: 50px; padding: 0px 15px; background: #fff; } #u-search .modal-footer .logo { position: absolute; top: 0; left: 0; width: 100%; height: 100%; text-align: center; z-index: 0; } #u-search .modal-footer .logo a { display: inline-block; height: 50px; } #u-search .modal-footer .logo.google img { height: 24px; margin-top: 13px; } #u-search .modal-footer .logo.baidu img { height: 22px; margin-top: 14px; } #u-search .modal-footer .logo img { position: relative; display: inline-block; width: auto; height: 18px; margin-top: 16px; } #u-search .modal-footer .modal-error { position: relative; float: left; vertical-align: middle; line-height: 50px; font-size: 13px; z-index: 1; } #u-search .modal-footer .modal-metadata { position: relative; float: left; vertical-align: middle; line-height: 50px; font-size: 13px; z-index: 1; } #u-search .modal-footer .nav { position: relative; display: block; float: right; vertical-align: middle; font-size: 0.875rem; font-weight: bold; line-height: 50px; color: rgba(68,68,68,0.65); cursor: pointer; z-index: 1; } #u-search .modal-footer .nav:hover { color: #ff5722; } #u-search .modal-footer .nav.btn-next { margin-left: 16px; } #u-search .modal-footer .nav .icon { font-size: 0.875rem; } #u-search .modal-body { position: absolute; padding: 16px; width: 100%; height: calc(100% - 64px); top: 64px; left: 0; overflow-y: scroll; -webkit-overflow-scrolling: touch; background: #fff; border-radius: 4px; } #u-search .modal-body::-webkit-scrollbar { height: 4px; width: 4px; } #u-search .modal-body::-webkit-scrollbar-track-piece { background: transparent; } #u-search .modal-body::-webkit-scrollbar-thumb { background: rgba(118,118,118,0.4); cursor: pointer; border-radius: 2px; } #u-search .modal-body::-webkit-scrollbar-thumb:hover { background: #767676; } #u-search .modal-body .modal-results { list-style: none; } #u-search .modal-body .modal-results .result { position: relative; display: block; padding: 16px; border-radius: 4px; } #u-search .modal-body .modal-results .result b[mark] { color: #0c7cd5; text-decoration: underline; } #u-search .modal-body .modal-results .result:hover { background: #e8f4fd; } #u-search .modal-body .modal-results .result .title { display: inline-block; max-width: 100%; color: #5e5e5e; font-weight: bold; padding: 1px; margin-bottom: 2px; white-space: normal; overflow: hidden; text-overflow: ellipsis; font-size: 1.125rem; } #u-search .modal-body .modal-results .result .digest { display: block; white-space: inherit; overflow: hidden; word-break: break-all; text-overflow: ellipsis; font-size: 0.8125rem; color: rgba(68,68,68,0.65); } #u-search .modal-body .modal-results .result .icon { position: absolute; top: 50%; right: 0; margin-top: -4px; font-size: 11px; color: #808080; } #u-search .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1; } .l_side { width: 240px; float: right; position: relative; display: flex; flex-direction: column; } @media screen and (max-width: 768px) { .l_side { width: 100%; } } .l_side .widget { overflow: hidden; } .l_side .widget >.content { max-height: calc(100vh - 144px); overflow: auto; text-align: justify; font-size: 0.875rem; max-width: 100%; } @media screen and (max-width: 768px) { .l_side .widget >.content { max-height: none; } } .l_side .widget >.content::-webkit-scrollbar { height: 4px; width: 4px; } .l_side .widget >.content::-webkit-scrollbar-track-piece { background: transparent; } .l_side .widget >.content::-webkit-scrollbar-thumb { background: rgba(118,118,118,0.4); cursor: pointer; border-radius: 2px; } .l_side .widget >.content::-webkit-scrollbar-thumb:hover { background: #767676; } .widget { z-index: 0; background: #fff; margin-top: 16px; border-radius: 8px; width: 100%; display: none; } .widget ul li, .widget ol li { margin-top: 0; margin-bottom: 0; } .widget.desktop { display: block; } @media screen and (max-width: 768px) { .widget { display: none !important; } .widget.mobile { display: block !important; } } @media screen and (max-width: 425px) { .widget { width: calc(100% - 2 * 16px); margin: 16px 16px 0 16px; display: none !important; } .widget.mobile { display: block !important; } } .widget header { border-top-left-radius: 8px; border-top-right-radius: 8px; padding: calc(16px - 2px); font-weight: bold; padding-bottom: 0; } .widget header, .widget header a { color: #2196f3; } .widget header >a:hover { color: #ff5722; } .widget header span.name { margin-left: 8px; } .widget >.content { padding: 8px 0; } .widget >.content p { margin-top: 0.4rem; margin-bottom: 0.4rem; } .widget >.content ul>li a { color: rgba(68,68,68,0.65); padding: 0 16px; padding-left: 12px; line-height: 2; display: flex; justify-content: space-between; align-content: center; border-left: 2px solid transparent; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .widget >.content ul.entry, .widget >.content ul.popular-posts { list-style: none; } .widget >.content ul.entry a .name, .widget >.content ul.popular-posts a .name { flex: auto; color: rgba(68,68,68,0.8); } .widget >.content ul.entry a .badge, .widget >.content ul.popular-posts a .badge { flex: none; font-weight: normal; font-size: 0.875rem; color: rgba(68,68,68,0.7); } .widget >.content ul.entry a:hover, .widget >.content ul.popular-posts a:hover { border-left: 2px solid #2196f3; background: #e8f4fd; } .widget >.content ul.entry a.active, .widget >.content ul.popular-posts a.active { border-left: 2px solid #2196f3; } .widget >.content ul.entry a.active .name, .widget >.content ul.popular-posts a.active .name { color: #2196f3; } .widget >.content ul.entry a.active .badge, .widget >.content ul.popular-posts a.active .badge { color: rgba(33,150,243,0.9); } .widget >.content ul.entry a:active, .widget >.content ul.popular-posts a:active { border-left: 4px solid #2196f3; } .widget >.content ul.entry a.child, .widget >.content ul.popular-posts a.child { padding-left: 32px; } .widget.blogger { transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .widget.blogger .content { padding: 0; text-align: center; display: flex; flex-direction: column; align-items: stretch; } .widget.blogger .content >.avatar { align-self: center; overflow: hidden; position: relative; border-top-left-radius: 8px; border-top-right-radius: 8px; line-height: 0; } .widget.blogger .content >.avatar.circle { border-radius: 100%; width: 128px; height: 128px; margin-top: 32px; margin-bottom: 0.4rem; } .widget.blogger .content >.avatar.circle img { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } @media screen and (max-width: 768px) { .widget.blogger .content >.avatar { width: 80px; height: 80px; border-radius: 100%; border: 2px solid #fff; } .widget.blogger .content >.avatar img { display: block; top: 50%; left: 50%; transform: translate(-50%, -50%); position: absolute; } } .widget.blogger .content .text :first-child { margin-top: 16px; } .widget.blogger .content h2 { font-weight: bold; margin: 8px; } @media screen and (max-width: 768px) { .widget.blogger .content h2 { margin: 8px; } } .widget.blogger .content p { font-weight: bold; margin: 8px 8px 0 8px; empty-cells: hide; } .widget.blogger .content .social-wrapper { display: flex; justify-content: space-between; flex-wrap: wrap; margin: 4px 4px; } .widget.blogger .content .social-wrapper a { color: rgba(68,68,68,0.65); padding: 0; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .widget.blogger .content .social-wrapper a:hover { color: #ff5722; } .widget.blogger .content .social-wrapper a.social { font-size: 0.9375rem; display: flex; justify-content: center; align-items: center; width: 32px; height: 32px; margin: 4px; border-radius: 100px; } .widget.blogger .content .social-wrapper a.social:hover { background: #e8f4fd; color: #2196f3; } @media screen and (max-width: 768px) { .widget.blogger .content .social-wrapper { justify-content: center; display: none; } } @media screen and (max-width: 768px) { .widget.blogger { box-shadow: none; background: transparent !important; margin-top: 32px; backdrop-filter: none; color: #555; } } .widget.text .content { padding: 4px 16px; } .widget.text .content, .widget.text .content p { font-size: 0.875rem; word-break: break-all; } .widget.text .content a { color: #2196f3; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .widget.text .content a:hover { color: #ff5722; text-decoration: underline; } .widget.text .content a:active { color: #d93400; } .widget.list .content { padding: 8px 0; } .widget.list .content a { font-size: 0.875rem; font-weight: bold; line-height: 1.5; padding-top: 6px; padding-bottom: 6px; } .widget.list .content a img, .widget.list .content a i { margin-right: 4px; } .widget.list .content a i { margin-left: 1px; } .widget.list .content a img { vertical-align: middle; height: 20px; width: 20px; margin-bottom: 4px; } .widget.list .content a img#round { border-radius: 100%; } .widget.grid .content .grid { border: none; display: flex; flex-wrap: wrap; justify-content: space-around; padding: 4px 16px; } .widget.grid .content .grid a { text-align: center; border-radius: 2px; margin: 0; padding: 4px 8px; display: flex; flex-direction: column; align-items: center; font-size: 0.75rem; font-weight: bold; color: rgba(68,68,68,0.7); line-height: 1.5; word-wrap: break-word; } .widget.grid .content .grid a i { margin-top: 0.3em; margin-bottom: 0.3em; font-size: 1.8em; } .widget.grid .content .grid a img { display: inline; vertical-align: middle; margin-bottom: 4px; } .widget.grid .content .grid a img#round { border-radius: 100%; } .widget.grid .content .grid a.active { color: #2196f3; background: #e8f4fd; } .widget.grid .content .grid a:hover { color: #2196f3; border-radius: 2px; background: #e8f4fd; } .widget.grid .content .grid.fixed a { width: calc(100%/3 - 0 * 16px); } @media screen and (max-width: 768px) { .widget.grid .content .grid.fixed a { width: calc(100%/6 - 0 * 16px); } } @media screen and (max-width: 500px) { .widget.grid .content .grid.fixed a { width: calc(100%/5 - 0 * 16px); } } @media screen and (max-width: 425px) { .widget.grid .content .grid.fixed a { width: calc(100%/4 - 0 * 16px); } } @media screen and (max-width: 375px) { .widget.grid .content .grid.fixed a { width: calc(100%/3 - 0 * 16px); } } .widget.tagcloud .content { text-align: justify; padding: 8px 16px; } .widget.tagcloud .content a { display: inline-block; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; line-height: 1.6em; } .widget.tagcloud .content a:hover { color: #ff5722 !important; text-decoration: underline; } .widget.related_posts .content { font-weight: bold; } .widget.related_posts .content ul { margin-top: 8px; margin-bottom: 8px; } .widget.related_posts .content h3 { font-size: 0.875rem; font-weight: bold; margin: 0; } .widget.related_posts .content h3 a { line-height: inherit; padding-top: 4px; padding-bottom: 4px; } .widget.qrcode .content { display: flex; flex-wrap: wrap; align-items: center; justify-content: space-around; padding-left: 16px; padding-right: 16px; } .widget.qrcode .content, .widget.qrcode .content img { margin-bottom: 4px; } .l_side>.widget.page >.content { padding-top: 0; padding-left: 12px; padding-right: 12px; } .aplayer-container { display: flex; justify-content: center; min-height: 100px; } .aplayer-container meting-js { max-width: 100%; } .aplayer { max-width: 500px; border-radius: 4px; color: #444; font-family: UbuntuMono, \"PingFang SC\", \"Microsoft YaHei\", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif; } .aplayer .aplayer-list { text-align: left; } @media screen and (max-width: 500px) { .aplayer { border-radius: 8px; } } .l_side .toc-wrapper { z-index: 1; overflow: hidden; border-radius: 8px; position: sticky; top: 80px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; line-height: 1.6; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } .l_side .toc-wrapper header { position: sticky; width: 100%; top: 0; padding-bottom: 4px; } .l_side .toc-wrapper .content { max-height: calc(100vh - 144px); } .l_side .toc-wrapper .content a { border-left: 2px solid transparent; } .l_side .toc-wrapper .content a:hover { background: #e8f4fd; border-left: 2px solid #2196f3; } .l_side .toc-wrapper .content a:active { border-left: 4px solid #2196f3; } .l_side .toc-wrapper .content a.active { color: #2196f3; border-left: 2px solid #2196f3; } @media screen and (max-width: 768px) { .l_side .toc-wrapper { z-index: 1001; position: fixed; max-height: 1000px; width: auto; max-width: calc(100% - 2 * 16px); top: 32px; right: 16px; border-radius: 4px; box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1); border: 1px solid #e7e7e7; visibility: hidden; transform: scale(0, 0); transform-origin: right top; } .l_side .toc-wrapper.active { visibility: visible; transform: scale(1, 1); } } @media screen and (max-width: 425px) { .l_side .toc-wrapper { right: 0; } } .l_side .toc-wrapper a { padding-left: 8px; color: rgba(68,68,68,0.65); font-size: 0.875rem; display: inline-block; } .l_side .toc-wrapper ul .toc-child a, .l_side .toc-wrapper ol .toc-child a { font-weight: normal; } .l_side .toc-wrapper ul .toc-item.toc-level-1 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-1 .toc-child a { padding-left: 12.8px; } .l_side .toc-wrapper ul .toc-item.toc-level-2 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-2 .toc-child a { padding-left: 25.6px; } .l_side .toc-wrapper ul .toc-item.toc-level-3 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-3 .toc-child a { padding-left: 38.4px; } .l_side .toc-wrapper ul .toc-item.toc-level-4 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-4 .toc-child a { padding-left: 51.2px; } .l_side .toc-wrapper ul .toc-item.toc-level-5 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-5 .toc-child a { padding-left: 64px; } .l_side .toc-wrapper ul .toc-item.toc-level-6 .toc-child a, .l_side .toc-wrapper ol .toc-item.toc-level-6 .toc-child a { padding-left: 76.8px; } .l_side .toc-wrapper ul li, .l_side .toc-wrapper ol li { width: auto; text-align: left; } .l_side .toc-wrapper ul li a, .l_side .toc-wrapper ol li a { padding: 0 8px 0 11px; font-weight: bold; width: 100%; } .l_side .toc-wrapper:empty { display: none; }"},{"title":"","date":"2020-09-10T18:09:04.538Z","updated":"2020-07-17T09:52:17.000Z","comments":true,"path":"js/app.js","permalink":"https://tetedetian.github.io/js/app.js","excerpt":"","text":"/* eslint-disable */ var customSearch; (function ($) { \"use strict\"; // 校正页面定位（被导航栏挡住的区域） var scrollCorrection = 80; // (header height = 64px) + (gap = 16px) var $headerAnchor = $('.l_header', '.cover-wrapper'); if ($headerAnchor[0]) { scrollCorrection = $headerAnchor[0].clientHeight + 16; } // 尝试： 重设数据值 function restData() { scrollCorrection = 80; $headerAnchor = $('.l_header', '.cover-wrapper'); if ($headerAnchor[0]) { scrollCorrection = $headerAnchor[0].clientHeight + 16; } } // 校正页面定位（被导航栏挡住的区域） function scrolltoElement(elem, correction = scrollCorrection) { const $elem = elem.href ? $(elem.getAttribute('href')) : $(elem); $('html, body').animate({ 'scrollTop': $elem.offset().top - correction }, 500); } // 设置滚动锚点 function setScrollAnchor() { const $postsBtn = $('.menu .active'); // 一级导航上的当前激活的按钮 const $topBtn = $('.s-top'); // 向上 const $titleBtn = $('h1.title', '#header-meta'); // 文章内标题 const $bodyAnchor = $('.l_body'); // 页面主体 if ($postsBtn.length && $bodyAnchor) { $postsBtn.click(e => { e.preventDefault(); e.stopPropagation(); if($postsBtn.attr(\"href\") != \"/\") // TODO: fix it scrolltoElement($bodyAnchor); e.stopImmediatePropagation(); $postsBtn.unbind('click'); }); } if ($titleBtn.length && $bodyAnchor) { $titleBtn.click(e => { e.preventDefault(); e.stopPropagation(); scrolltoElement($bodyAnchor); e.stopImmediatePropagation(); $titleBtn.unbind('click'); }); } if ($topBtn.length && $bodyAnchor) { $topBtn.click(e => { e.preventDefault(); e.stopPropagation(); scrolltoElement($bodyAnchor); e.stopImmediatePropagation(); }); } //========================================== const $coverAnchor = $('.cover-wrapper'); var enableCover = $('#pjax-enable-cover').text(); // Pjax 处理 var showHeaderPoint = 0; if ($coverAnchor[0]) { if(enableCover == \"true\" && $('.cover.half').css('display') !== 'none') // Pjax 处理 showHeaderPoint = $coverAnchor[0].clientHeight - 180; } var pos = document.body.scrollTop; if(enableCover == \"true\" && $('.cover.half').css('display') === 'none') pos += 180; // Pjax 处理 $(document, window).scroll(() => { let scrollTop = $(window).scrollTop(); // 滚动条距离顶部的距离 if(enableCover == \"true\" && $('.cover.half').css('display') === 'none') scrollTop += 180; // Pjax 处理 const del = scrollTop - pos; pos = scrollTop; if (scrollTop > 180) { $topBtn.addClass('show'); if (del > 0) { $topBtn.removeClass('hl'); } else { $topBtn.addClass('hl'); } } else { $topBtn.removeClass('show').removeClass('hl'); } if (scrollTop > showHeaderPoint) { $headerAnchor.addClass('show'); } else { $headerAnchor.removeClass('show'); } }); //========================================== } // 设置导航栏 function setHeader() { var HEXO_ISPAGE = $.trim($('#pjax-ispage').text()); if(HEXO_ISPAGE == 'true') window.subData = { title: $.trim($('#pjax-pageTitle').text()), tools: true } if (!window.subData) return; const $wrapper = $('header .wrapper'); // 整个导航栏 const $comment = $('.s-comment', $wrapper); // 评论按钮 桌面端 移动端 const $toc = $('.s-toc', $wrapper); // 目录按钮 仅移动端 $wrapper.find('.nav-sub .title').text(window.subData.title); // 二级导航文章标题 // 决定一二级导航栏的切换 let pos = document.body.scrollTop; $(document, window).scroll(() => { const scrollTop = $(window).scrollTop(); const del = scrollTop - pos; if (del >= 50 && scrollTop > 100) { pos = scrollTop; $wrapper.addClass('sub'); } else if (del { e.stopPropagation(); $tocTarget.toggleClass('active'); $toc.toggleClass('active'); }); $(document).click(function (e) { e.stopPropagation(); $tocTarget.removeClass('active'); $toc.removeClass('active'); }); $(document, window).scroll(() => { $tocTarget.removeClass('active'); $toc.removeClass('active'); }); } else $toc.remove(); } // 设置导航栏菜单选中状态 function setHeaderMenuSelection() { var $headerMenu = $('body .navigation'); // 先把已经激活的取消激活 $headerMenu.find('li a.active').removeClass('active'); // var $underline = $headerMenu.find('.underline'); function setUnderline($item) { // if (!transition) $underline.addClass('disable-trans'); if ($item && $item.length) { $item.addClass('active').siblings().removeClass('active'); } } //set current active nav var $active_link = null; // replace '%' '/' '.' var idname = location.pathname.replace(/\\/|%|\\./g, \"\"); if (idname.length == 0) { idname = \"home\"; } var page = idname.match(/page\\d{0,}$/g); if (page) { page = page[0]; idname = idname.split(page)[0]; } var index = idname.match(/index.html/); if (index) { index = index[0]; idname = idname.split(index)[0]; } if (idname && $headerMenu) { $active_link = $('#' + idname, $headerMenu); setUnderline($active_link); } } // 设置导航栏搜索框 fix √ function setHeaderSearch() { var $switcher = $('.l_header .switcher .s-search'); // 搜索按钮 移动端 var $header = $('.l_header'); // 移动端导航栏 var $search = $('.l_header .m_search'); // 搜索框 桌面端 if ($switcher.length === 0) return; $switcher.click(function (e) { e.stopPropagation(); $header.toggleClass('z_search-open'); // 激活移动端搜索框 $switcher.toggleClass('active'); // 搜索按钮 $search.find('input').focus(); }); $(document).click(function (e) { $header.removeClass('z_search-open'); $switcher.removeClass('active'); }); $search.click(function (e) { e.stopPropagation(); }); $header.ready(function () { $header.bind('keydown', function (event) { if (event.keyCode == 9) { return false; } else { var isie = (document.all) ? true : false; var key; var ev; if (isie) { //IE浏览器 key = window.event.keyCode; ev = window.event; } else { //火狐浏览器 key = event.which; ev = event; } if (key == 9) { //IE浏览器 if (isie) { ev.keyCode = 0; ev.returnValue = false; } else { //火狐浏览器 ev.which = 0; ev.preventDefault(); } } } }); }); } // 设置导航栏搜索框 function setTocToggle() { const $toc = $('.toc-wrapper'); // 侧边栏 TOC 移动端 if ($toc.length === 0) return; $toc.click((e) => { e.stopPropagation(); $toc.addClass('active'); }); $(document).click(() => $toc.removeClass('active')); $toc.on('click', 'a', (e) => { e.preventDefault(); e.stopPropagation(); if (e.target.tagName === 'A') { scrolltoElement(e.target, 0); } else if (e.target.tagName === 'SPAN') { scrolltoElement(e.target.parentElement, 0); } $toc.removeClass('active'); const $tocBtn = $('.s-toc'); if ($tocBtn.length > 0) { $tocBtn.removeClass('active'); } }); let liElements = Array.from($toc.find('li a')); //function animate above will convert float to int. let getAnchor = () => liElements.map(elem => Math.floor($(elem.getAttribute('href')).offset().top - scrollCorrection)); let anchor = getAnchor(); let domHeigth = $(document).height(); let scrollListener = () => { let scrollTop = $('html').scrollTop() || $('body').scrollTop(); if ($(document).height() != domHeigth) { // dom 高度发生变化： 普遍来说，是图片懒加载造成的 scrollTop = $('html').scrollTop() || $('body').scrollTop(); domHeigth = $(document).height(); anchor = getAnchor(); } if (!anchor) return; //binary search. let l = 0, r = anchor.length - 1, mid; while (l < r) { mid = (l + r + 1) >> 1; if (anchor[mid] === scrollTop) l = r = mid; else if (anchor[mid] < scrollTop) l = mid; else r = mid - 1; } $(liElements).removeClass('active').eq(l).addClass('active'); }; $(window).scroll(() => { scrollListener(); }); // 监听窗口改变事件 let resizeTimer = null; $(window).bind('resize', function (){ if (resizeTimer) clearTimeout(resizeTimer); resizeTimer = setTimeout(function(){ anchor = getAnchor(); scrollListener(); } , 100); }); scrollListener(); } // 设置搜索服务 function setSearchService() { if (SEARCH_SERVICE === 'google') { customSearch = new GoogleCustomSearch({ apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY, engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID, imagePath: \"/img/\" }); } else if (SEARCH_SERVICE === 'algolia') { customSearch = new AlgoliaSearch({ apiKey: ALGOLIA_API_KEY, appId: ALGOLIA_APP_ID, indexName: ALGOLIA_INDEX_NAME, imagePath: \"/img/\" }); } else if (SEARCH_SERVICE === 'hexo') { customSearch = new HexoSearch({ imagePath: \"/img/\" }); } else if (SEARCH_SERVICE === 'azure') { customSearch = new AzureSearch({ serviceName: AZURE_SERVICE_NAME, indexName: AZURE_INDEX_NAME, queryKey: AZURE_QUERY_KEY, imagePath: \"/img/\" }); } else if (SEARCH_SERVICE === 'baidu') { customSearch = new BaiduSearch({ apiId: BAIDU_API_ID, imagePath: \"/img/\" }); } } // 设置 tabs 标签 function setTabs() { const $tabs = $('.tabs'); if ($tabs.length === 0) return; let $navs = $tabs.find('.nav-tabs .tab'); for (var i = 0; i < $navs.length; i++) { let $a = $tabs.find($navs[i].children[0]); $a.addClass($a.attr(\"href\")); $a.removeAttr('href'); } $('.tabs .nav-tabs').on('click', 'a', (e) => { e.preventDefault(); e.stopPropagation(); let $tab = $(e.target.parentElement.parentElement.parentElement); $tab.find('.nav-tabs .active').removeClass('active'); $tab.find(e.target.parentElement).addClass('active'); $tab.find('.tab-content .active').removeClass('active'); $tab.find($(e.target).attr(\"class\")).addClass('active'); return false; }); } $(function () { setHeader(); setHeaderMenuSelection(); setHeaderSearch(); setTocToggle(); setScrollAnchor(); setSearchService(); setTabs(); // 全屏封面底部箭头 $('.scroll-down').on('click', function () { scrolltoElement('.l_body'); }); try { // addEventListener是先绑定先执行，此处的绑定后执行 document.addEventListener('pjax:complete', function () { $(function () { restData(); setHeader(); setHeaderMenuSelection(); setTocToggle(); setScrollAnchor(); setTabs(); // 处理点击事件 setHeaderSearch 没有重载，需要重新绑定单个事件 var $switcher = $('.l_header .switcher .s-search'); // 搜索按钮 移动端 var $header = $('.l_header'); // 移动端导航栏 if ($switcher.length !== 0) { $(document).click(function (e) { $header.removeClass('z_search-open'); $switcher.removeClass('active'); }); } }); }); } catch (error) { // console.log(error); } }); })(jQuery); /*锚点定位*/ if(window.location.hash){ var checkExist = setInterval(function() { if (typeof jQuery == 'undefined'){return;} if ($(\"#\"+decodeURI(window.location.hash.split(\"#\")[1]).replace(/\\ /g,\"-\")).length) { $('html, body').animate({scrollTop: $(\"#\"+decodeURI(window.location.hash.split(\"#\")[1]).replace(/\\ /g,\"-\")).offset().top-10}, 500); clearInterval(checkExist); } }, 100); }"},{"title":"博客","date":"2020-07-06T09:50:20.000Z","updated":"2020-07-20T10:50:12.449Z","comments":true,"path":"tags/hexo博客.html","permalink":"https://tetedetian.github.io/tags/hexo%E5%8D%9A%E5%AE%A2.html","excerpt":"","text":""},{"title":"","date":"2020-09-10T18:09:04.539Z","updated":"2020-07-17T09:52:17.000Z","comments":true,"path":"js/search.js","permalink":"https://tetedetian.github.io/js/search.js","excerpt":"","text":"/* eslint-disable */ var SearchService = \"\"; (function($) { /** * A super class of common logics for all search services * @param options : (object) */ SearchService = function(options) { var self = this; self.config = $.extend({ per_page: 10, selectors: { body: \"body\", form: \".u-search-form\", input: \".u-search-input\", container: \"#u-search\", modal: \"#u-search .modal\", modal_body: \"#u-search .modal-body\", modal_footer: \"#u-search .modal-footer\", modal_overlay: \"#u-search .modal-overlay\", modal_results: \"#u-search .modal-results\", modal_metadata: \"#u-search .modal-metadata\", modal_error: \"#u-search .modal-error\", modal_loading_bar: \"#u-search .modal-loading-bar\", modal_ajax_content: \"#u-search .modal-ajax-content\", modal_logo: '#u-search .modal-footer .logo', btn_close: \"#u-search .btn-close\", btn_next: \"#u-search .btn-next\", btn_prev: \"#u-search .btn-prev\" }, brands: { 'hexo': {logo: '', url: ''}, 'google': {logo: 'google.svg', url: 'https://cse.google.com'}, 'algolia': {logo: 'algolia.svg', url: 'https://www.algolia.com'}, 'baidu': {logo: 'baidu.svg', url: 'http://zn.baidu.com/cse/home/index'}, 'azure': {logo: 'azure.svg', url: 'https://azure.microsoft.com/en-us/services/search/'} }, imagePath: ROOT + \"img/\" }, options); self.dom = {}; self.percentLoaded = 0; self.open = false; self.queryText = \"\"; self.nav = { next: -1, prev: -1, total: 0, current: 1 }; self.parseSelectors = function() { for (var key in self.config.selectors) { self.dom[key] = $(self.config.selectors[key]); } }; self.beforeQuery = function() { if (!self.open) { self.dom.container.fadeIn(); // self.dom.body.addClass('modal-active'); // 上面的是去除了文章的滚动条，我觉得没必要 } self.dom.input.each(function(index,elem) { $(elem).val(self.queryText); }); document.activeElement.blur(); self.dom.modal_error.hide(); self.dom.modal_ajax_content.removeClass('loaded'); self.startLoading(); }; self.afterQuery = function() { self.dom.modal_body.scrollTop(0); self.dom.modal_ajax_content.addClass('loaded'); self.stopLoading(); }; /** * Perform a complete serach operation including UI updates and query * @param startIndex {int} start index or page number */ self.search = function(startIndex, callback) { self.beforeQuery(); if (self.search instanceof Function) { self.query(self.queryText, startIndex, function() { self.afterQuery(); }); } else { console.log(\"query() does not exist.\"); self.onQueryError(self.queryText, ''); self.afterQuery(); } }; /** * Query error handler * @param queryText: (string) * @param status: (string) */ self.onQueryError = function(queryText, status) { var errMsg = \"\"; if (status === \"success\") errMsg = \"No result found for \\\"\" +queryText+ \"\\\".\"; else if (status === \"timeout\") errMsg = \"Unfortunate timeout.\"; else errMsg = \"Mysterious failure.\"; self.dom.modal_results.html(\"\"); self.dom.modal_error.html(errMsg); self.dom.modal_error.show(); }; self.nextPage = function() { if (self.nav.next !== -1) { self.search(self.nav.next); } }; self.prevPage = function() { if (self.nav.prev !== -1) { self.search(self.nav.prev); } }; self.getUrlRelativePath = function (url) { var arrUrl = url.split(\"//\"); var start = arrUrl[1].indexOf(\"/\"); var relUrl = arrUrl[1].substring(start); if (relUrl.indexOf(\"?\") != -1) { relUrl = relUrl.split(\"?\")[0]; } return relUrl; } /** * Generate html for one result * @param url : (string) url * @param title : (string) title * @param digest : (string) digest */ self.buildResult = function (url, title, digest) { var result = self.getUrlRelativePath(url); var html = \"\"; html = \"\"; html += \"\"; html += \"\" + title + \"\"; if (digest !== \"\") html += \"\" + digest + \"\"; html += \"\"; html += \"\"; return html; }; /** * Close the modal, resume body scrolling * no param */ self.close = function() { self.open = false; self.dom.container.fadeOut(); self.dom.body.removeClass('modal-active'); }; /** * Searchform submit event handler * @param queryText : (string) the query text */ self.onSubmit = function(event) { event.preventDefault(); self.queryText = $(this).find('.u-search-input').val(); if (self.queryText) { self.search(1); } }; /** * Start loading bar animation * no param */ self.startLoading = function() { self.dom.modal_loading_bar.show(); self.loadingTimer = setInterval(function() { self.percentLoaded = Math.min(self.percentLoaded+5,95); self.dom.modal_loading_bar.css('width', self.percentLoaded+'%'); }, 100); }; /** * Stop loading bar animation * no param */ self.stopLoading = function() { clearInterval(self.loadingTimer); self.dom.modal_loading_bar.css('width', '100%'); self.dom.modal_loading_bar.fadeOut(); setTimeout(function() { self.percentLoaded = 0; self.dom.modal_loading_bar.css('width', '0%'); }, 300); }; /** * Add service branding * @param service {String} service name */ self.addLogo = function(service) { var html = \"\"; if (self.config.brands[service] && self.config.brands[service].logo) { html += \"\"; html += ''; html += \"\"; self.dom.modal_logo.html(html); } }; self.destroy = function() { self.dom.form.each(function(index,elem) { $(elem).off('submit'); }); self.dom.modal_overlay.off('click'); self.dom.btn_close.off('click'); self.dom.btn_next.off('click'); self.dom.btn_prev.off('click'); self.dom.container.remove(); }; /** * Load template and register event handlers * no param */ self.init = function() { $('body').append(template); self.parseSelectors(); self.dom.modal_footer.show(); self.dom.form.each(function(index,elem) { $(elem).on('submit', self.onSubmit); }); self.dom.modal_overlay.on('click', self.close); self.dom.btn_close.on('click', self.close); self.dom.btn_next.on('click', self.nextPage); self.dom.btn_prev.on('click', self.prevPage); }; self.init(); }; var template = ' of NEXT PREV '; })(jQuery); var AlgoliaSearch; (function($) { 'use strict'; /** * Search by Algolia Search * @param options : (object) */ AlgoliaSearch = function(options) { SearchService.apply(this, arguments); var self = this; var endpoint = \"https://\" +self.config.appId+ \"-dsn.algolia.net/1/indexes/\" + self.config.indexName; self.addLogo('algolia'); /** * Generate result list html * @param data : (array) result items */ self.buildResultList = function(data) { var html = \"\"; $.each(data, function(index, row) { var url = row.permalink || row.path || \"\"; if (!row.permalink && row.path) { url = ROOT + url; } var title = row.title; var digest = \"\"; html += self.buildResult(url, title, digest, index+1); }); html += \"try{pjax.refresh(document.querySelector('#u-search'));document.addEventListener('pjax:send',function(){$('#u-search').fadeOut(500);$('body').removeClass('modal-active')});}catch(e){$('#u-search').fadeOut(500);}\"; return html; }; /** * Generate metadata after a successful query * @param data : (object) the raw search response data */ self.buildMetadata = function(data) { self.nav.current = data.page * data.hitsPerPage + 1; self.nav.currentCount = data.hits.length; self.nav.total = parseInt(data.nbHits); self.dom.modal_metadata.children('.total').html(self.nav.total); self.dom.modal_metadata.children('.range').html(self.nav.current + \"-\" + (self.nav.current+self.nav.currentCount-1)); if (self.nav.total > 0) { self.dom.modal_metadata.show(); } else { self.dom.modal_metadata.hide(); } if (data.page < data.nbPages-1) { self.nav.next = (data.page+1)+1; self.dom.btn_next.show(); } else { self.nav.next = -1; self.dom.btn_next.hide(); } if (data.page > 0) { self.nav.prev = (data.page+1)-1; self.dom.btn_prev.show(); } else { self.nav.prev = -1; self.dom.btn_prev.hide(); } }; /** * Send a GET request * @param queryText : (string) the query text * @param page : (int) the current page (start from 1) * @param callback : (function) */ self.query = function(queryText, page, callback) { $.get(endpoint, { query: queryText, page: page-1, hitsPerPage: self.config.per_page, \"x-algolia-application-id\": self.config.appId, \"x-algolia-api-key\": self.config.apiKey }, function(data, status) { if (status === 'success' && data.hits && data.hits.length > 0) { var results = self.buildResultList(data.hits); self.dom.modal_results.html(results); } else { self.onQueryError(queryText, status); } self.buildMetadata(data); if (callback) { callback(data); } }); }; return self; }; })(jQuery); var AzureSearch; (function($) { 'use strict'; /** * Search by Azure Search API * @param options : (object) */ AzureSearch = function(options) { SearchService.apply(this, arguments); var self = this; var endpoint = \"https://\" +self.config.serviceName+ \".search.windows.net/indexes/\" +self.config.indexName+ \"/docs?api-version=2015-02-28\"; self.nav.current = 1; self.addLogo('azure'); /** * Generate result list html * @param data : (array) result items */ self.buildResultList = function(data) { var html = \"\"; $.each(data, function(index, row) { var url = row.permalink || row.path || \"\"; if (!row.permalink && row.path) { url = \"/\" + url; } var title = row.title; var digest = row.excerpt || \"\"; html += self.buildResult(url, title, digest); }); html += \"try{pjax.refresh(document.querySelector('#u-search'));document.addEventListener('pjax:send',function(){$('#u-search').fadeOut(500);$('body').removeClass('modal-active')});}catch(e){$('#u-search').fadeOut(500);}\"; return html; }; /** * Generate metadata after a successful query * @param data : (object) the raw response data * @param startIndex : (int) requested start index of current query */ self.buildMetadata = function(data, startIndex) { self.nav.current = startIndex; self.nav.currentCount = data.value.length; self.nav.total = parseInt(data['@odata.count']); self.dom.modal_metadata.children('.total').html(self.nav.total); self.dom.modal_metadata.children('.range').html(self.nav.current + \"-\" + (self.nav.current+self.nav.currentCount-1)); if (self.nav.total > 0) { self.dom.modal_metadata.show(); } else { self.dom.modal_metadata.hide(); } if (self.nav.current+self.nav.currentCount 1) { self.nav.prev = self.nav.current-self.config.per_page; self.dom.btn_prev.show(); } else { self.nav.prev = -1; self.dom.btn_prev.hide(); } }; /** * Send a GET request * @param queryText : (string) the query text * @param page : (int) the current page (start from 1) * @param callback : (function) */ self.query = function(queryText, startIndex, callback) { $.ajax({ url: endpoint, headers: { \"Accept\": \"application/json\", \"api-key\": self.config.queryKey }, data: { search: queryText, $orderby: \"date desc\", $skip: startIndex-1, $top: self.config.per_page, $count: true }, type: \"GET\", success: function(data, status) { if (status === 'success' && data.value && data.value.length > 0) { var results = self.buildResultList(data.value); self.dom.modal_results.html(results); } else { self.onQueryError(queryText, status); } self.buildMetadata(data, startIndex); if (callback) { callback(data); } } }); }; return self; }; })(jQuery); var BaiduSearch; (function($) { 'use strict'; /** * TODO * Search by Baidu Search API * @param options : (object) */ BaiduSearch = function(options) { SearchService.apply(this, arguments); var self = this; var endpoint = \"\"; self.addLogo('baidu'); /** * Generate result list html * @param data : (array) result items */ self.buildResultList = function(data, queryText) { var results = [], html = \"\"; $.each(data, function(index, post) { if (self.contentSearch(post, queryText)) html += self.buildResult(post.linkUrl, post.title, post.abstract); }); html += \"try{pjax.refresh(document.querySelector('#u-search'));document.addEventListener('pjax:send',function(){$('#u-search').fadeOut(500);$('body').removeClass('modal-active')});}catch(e){$('#u-search').fadeOut(500);}\"; return html; }; /** * Generate metadata after a successful query * @param data : (object) the raw google custom search response data */ self.buildMetadata = function(data) { }; self.loadScript = function() { self.dom.input.each(function(index,elem) { $(elem).attr('disabled', true); }); var script = \"\"; self.dom.body.append(script); }; self.initBaidu = function() { self.cse = new BCse.Search(self.config.apiId); //self.cse.setPageNum(self.config.per_page); self.dom.input.each(function(index,elem) { $(elem).attr('disabled', false); }); }; /** * Get search results * @param queryText {String} * @param page {Integer} * @param callback {Function} */ self.query = function(queryText, page, callback) { self.cse.getResult(queryText, function(data) { console.log(\"Searching: \" + queryText); self.cse.getError(function(data) { console.log(data); }); if (data.length > 0) { self.buildResultList(data, queryText); self.cse.getSearchInfo(queryText, function(data) { console.log(data); self.buildMetadata(data); }); } else { self.nav.total = 0; self.nav.next = -1; self.nav.prev = -1; self.dom.modal_metadata.hide(); self.dom.btn_next.hide(); self.dom.btn_prev.hide(); self.onQueryError(queryText, \"success\"); } if (callback instanceof Function) { callback(); } }); }; self.loadScript(); return self; }; })(jQuery); var GoogleCustomSearch = \"\"; (function($) { 'use strict'; /** * Search by Google Custom Search Engine JSON API * @param options : (object) */ GoogleCustomSearch = function(options) { SearchService.apply(this, arguments); var self = this; var endpoint = \"https://www.googleapis.com/customsearch/v1\"; self.addLogo('google'); /** * Generate result list html * @param data : (array) result items */ self.buildResultList = function(data) { var html = \"\"; $.each(data, function(index, row) { var url = row.link; var title = row.title; var digest = (row.htmlSnippet || \"\").replace('',''); html += self.buildResult(url, title, digest); }); html += \"try{pjax.refresh(document.querySelector('#u-search'));document.addEventListener('pjax:send',function(){$('#u-search').fadeOut(500);$('body').removeClass('modal-active')});}catch(e){$('#u-search').fadeOut(500);}\"; return html; }; /** * Generate metadata after a successful query * @param data : (object) the raw google custom search response data */ self.buildMetadata = function(data) { if (data.queries && data.queries.request && data.queries.request[0].totalResults !== '0') { self.nav.current = data.queries.request[0].startIndex; self.nav.currentCount = data.queries.request[0].count; self.nav.total = parseInt(data.queries.request[0].totalResults); self.dom.modal_metadata.children('.total').html(self.nav.total); self.dom.modal_metadata.children('.range').html(self.nav.current + \"-\" + (self.nav.current+self.nav.currentCount-1)); self.dom.modal_metadata.show(); } else { self.dom.modal_metadata.hide(); } if (data.queries && data.queries.nextPage) { self.nav.next = data.queries.nextPage[0].startIndex; self.dom.btn_next.show(); } else { self.nav.next = -1; self.dom.btn_next.hide(); } if (data.queries && data.queries.previousPage) { self.nav.prev = data.queries.previousPage[0].startIndex; self.dom.btn_prev.show(); } else { self.nav.prev = -1; self.dom.btn_prev.hide(); } }; /** * Send a GET request * @param queryText : (string) the query text * @param startIndex : (int) the index of first item (start from 1) * @param callback : (function) */ self.query = function(queryText, startIndex, callback) { $.get(endpoint, { key: self.config.apiKey, cx: self.config.engineId, q: queryText, start: startIndex, num: self.config.per_page }, function(data, status) { if (status === 'success' && data.items && data.items.length > 0) { var results = self.buildResultList(data.items); self.dom.modal_results.html(results); } else { self.onQueryError(queryText, status); } self.buildMetadata(data); if (callback) { callback(); } }); }; return self; }; })(jQuery); var HexoSearch; (function($) { 'use strict'; /** * Search by Hexo generator json content * @param options : (object) */ HexoSearch = function(options) { SearchService.apply(this, arguments); var self = this; self.config.endpoint = ROOT + ((options||{}).endpoint || \"content.json\"); self.config.endpoint = self.config.endpoint.replace(\"//\",\"/\"); //make sure the url is correct self.cache = \"\"; /** * Search queryText in title and content of a post * Credit to: http://hahack.com/codes/local-search-engine-for-hexo/ * @param post : the post object * @param queryText : the search query */ self.contentSearch = function(post, queryText) { var post_title = post.title.trim().toLowerCase(), post_content = post.text.trim().toLowerCase(), keywords = queryText.trim().toLowerCase().split(\" \"), foundMatch = false, index_title = -1, index_content = -1, first_occur = -1; if (post_title !== '' && post_content !== '') { $.each(keywords, function(index, word) { index_title = post_title.indexOf(word); index_content = post_content.indexOf(word); if (index_title < 0 && index_content < 0) { foundMatch = false; } else { foundMatch = true; if (index_content < 0) { index_content = 0; } if (index === 0) { first_occur = index_content; } } if (foundMatch) { post_content = post.text.trim(); var start = 0, end = 0; if (first_occur >= 0) { start = Math.max(first_occur-40, 0); end = (start === 0) ? Math.min(200, post_content.length) : Math.min(first_occur + 120, post_content.length); var match_content = post_content.substring(start, end); keywords.forEach(function(keyword) { var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"\"+keyword+\"\"); }); post.digest = match_content + \"......\"; } else { end = Math.min(200, post_content.length); post.digest = post_content.trim().substring(0, end); } } }); } return foundMatch; }; /** * Generate result list html * @param data : (array) result items */ self.buildResultList = function(data, queryText) { var results = [], html = \"\"; $.each(data, function (index, post) { if (self.contentSearch(post, queryText)) html += self.buildResult(post.permalink, post.title, post.digest); }); html += \"try{pjax.refresh(document.querySelector('#u-search'));document.addEventListener('pjax:send',function(){$('#u-search').fadeOut(500);$('body').removeClass('modal-active')});}catch(e){$('#u-search').fadeOut(500);}\"; return html; }; /** * Generate metadata after a successful query * @param data : (object) the raw google custom search response data */ self.buildMetadata = function(data) { self.dom.modal_footer.hide(); }; /** * Send a GET request * @param queryText : (string) the query text * @param startIndex : (int) the index of first item (start from 1) * @param callback : (function) */ self.query = function(queryText, startIndex, callback) { if (!self.cache) { $.get(self.config.endpoint, { key: self.config.apiKey, cx: self.config.engineId, q: queryText, start: startIndex, num: self.config.per_page }, function(data, status) { if (status !== 'success' || !data || (!data.posts && !data.pages) || (data.posts.length < 1 && data.pages.length < 1) ) { self.onQueryError(queryText, status); } else { self.cache = data; var results = \"\"; results += self.buildResultList(data.pages, queryText); results += self.buildResultList(data.posts, queryText); self.dom.modal_results.html(results); } self.buildMetadata(data); if (callback) { callback(data); } }); } else { var results = \"\"; results += self.buildResultList(self.cache.pages, queryText); results += self.buildResultList(self.cache.posts, queryText); self.dom.modal_results.html(results); self.buildMetadata(self.cache); if (callback) { callback(self.cache); } } }; return self; }; })(jQuery);"},{"title":"所有标签","date":"2020-09-10T18:09:04.540Z","updated":"2020-07-20T11:20:53.533Z","comments":true,"path":"tags/index.html","permalink":"https://tetedetian.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-10T18:09:04.539Z","updated":"2020-07-17T09:52:17.000Z","comments":true,"path":"js/valine.js","permalink":"https://tetedetian.github.io/js/valine.js","excerpt":"","text":"/*! * Valine v1.4.14 * (c) 2017-2020 xCss * Released under the GPL-2.0 License. * Last Update: 2020/4/26 下午8:39:08 */ !function(e, t) { \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Valine = t() : e.Valine = t() }(this, function() { return function(e) { function t(r) { if (n[r]) return n[r].exports; var o = n[r] = { i: r, l: !1, exports: {} }; return e[r].call(o.exports, o, o.exports, t), o.l = !0, o.exports } var n = {}; return t.m = e, t.c = n, t.i = function(e) { return e } , t.d = function(e, n, r) { t.o(e, n) || Object.defineProperty(e, n, { configurable: !1, enumerable: !0, get: r }) } , t.n = function(e) { var n = e && e.__esModule ? function() { return e.default } : function() { return e } ; return t.d(n, \"a\", n), n } , t.o = function(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } , t.p = \"\", t(t.s = 63) }([function(e, t, n) { \"use strict\"; function r(e) { return e && e.__esModule ? e : { default: e } } t.__esModule = !0; var o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e } , i = n(38) , a = r(i) , s = n(28) , l = r(s) , c = n(27) , u = r(c) , d = n(42) , p = r(d) , f = document , h = navigator , v = /[&\"'`\\\\]/g , g = RegExp(v.source) , m = /&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g , y = RegExp(m.source) , b = { \"&\": \"&amp;\", \"\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\", \"`\": \"&#x60;\", \"\\\\\": \"&#x5c;\" } , w = {}; for (var x in b) w[b[x]] = x; var k = null; Array.prototype.forEach || (Array.prototype.forEach = function(e, t) { var n, r; if (null == this) throw new TypeError(\" this is null or not defined\"); var o = Object(this) , i = o.length >>> 0; if (\"function\" != typeof e) throw new TypeError(e + \" is not a function\"); for (arguments.length > 1 && (n = t), r = 0; r < i; ) { var a; r in o && (a = o[r], e.call(n, a, r, o)), r++ } } ), window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach), String.prototype.trim || (String.prototype.trim = function() { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\") } ), (0, a.default)(l.default.fn, { prepend: function(e) { return e instanceof HTMLElement || (e = e[0]), this.forEach(function(t) { t.insertAdjacentElement(\"afterBegin\", e) }), this }, append: function(e) { return e instanceof HTMLElement || (e = e[0]), this.forEach(function(t) { t.insertAdjacentElement(\"beforeEnd\", e) }), this }, remove: function() { return this.forEach(function(e) { try { e.parentNode.removeChild(e) } catch (e) {} }), this }, find: function(e) { return (0, l.default)(e, this) }, show: function() { return this.forEach(function(e) { e.style.display = \"block\" }), this }, hide: function() { return this.forEach(function(e) { e.style.display = \"none\" }), this }, on: function(e, t, n) { return l.default.fn.off(e, t, n), this.forEach(function(r) { e.split(\" \").forEach(function(e) { r.addEventListener ? r.addEventListener(e, t, n || !1) : r.attachEvent ? r.attachEvent(\"on\" + e, t) : r[\"on\" + e] = t }) }), this }, off: function(e, t, n) { return this.forEach(function(r) { e.split(\" \").forEach(function(e) { r.removeEventListener ? r.removeEventListener(e, t, n || !1) : r.detachEvent ? r.detachEvent(\"on\" + e, t) : r[\"on\" + e] = null }) }), this }, html: function(e) { return void 0 !== e ? (this.forEach(function(t) { t.innerHTML = e }), this) : this[0].innerHTML }, text: function(e) { return void 0 !== e ? (this.forEach(function(t) { t.innerText = e }), this) : this[0].innerText }, empty: function(e) { return e = e || 0, this.forEach(function(t) { setTimeout(function(e) { t.innerText = \"\" }, e) }), this }, val: function(e) { return void 0 !== e ? (this.forEach(function(t) { t.value = e }), this) : this[0].value || \"\" }, attr: function() { var e = arguments; if (\"object\" == o(arguments[0])) { var t = arguments[0] , n = this; return Object.keys(t).forEach(function(e) { n.forEach(function(n) { n.setAttribute(e, t[e]) }) }), this } return \"string\" == typeof arguments[0] && arguments.length < 2 ? this[0].getAttribute(arguments[0]) || \"\" : (this.forEach(function(t) { t.setAttribute(e[0], e[1]) }), this) }, removeAttr: function(e) { return this.forEach(function(t) { var n, r = 0, o = e && e.match(/[^\\x20\\t\\r\\n\\f\\*\\/\\\\]+/g); if (o && 1 === t.nodeType) for (; n = o[r++]; ) t.removeAttribute(n) }), this }, hasClass: function(e) { return !!this[0] && new RegExp(\"(\\\\s|^)\" + e + \"(\\\\s|$)\").test(this[0].getAttribute(\"class\")) }, addClass: function(e) { return this.forEach(function(t) { var n = (0, l.default)(t) , r = n.attr(\"class\"); n.hasClass(e) || n.attr(\"class\", r += \" \" + e) }), this }, removeClass: function(e) { return this.forEach(function(t) { var n = (0, l.default)(t) , r = n.attr(\"class\"); if (n.hasClass(e)) { var o = new RegExp(\"(\\\\s|^)\" + e + \"(\\\\s|$)\"); n.attr(\"class\", r.replace(o, \"\")) } }), this } }), (0, a.default)(l.default, { extend: a.default, noop: function() {}, navi: h, ua: h.userAgent, lang: h.language || h.languages[0], detect: u.default, store: p.default, escape: function(e) { return e && g.test(e) ? e.replace(v, function(e) { return b[e] }) : e }, unescape: function(e) { return e && y.test(e) ? e.replace(m, function(e) { return w[e] }) : e }, dynamicLoadSource: function(e, t) { if ((0, l.default)('script[src=\"' + e + '\"]').length) t && t(); else { var n = f.createElement(\"script\"); n.onload = n.onreadystatechange = function() { var e = this; e.onload = e.onreadystatechange = null, t && t(), (0, l.default)(n).remove() } , n.async = !0, n.setAttribute(\"referrerPolicy\", \"no-referrer\"); (0, l.default)(\"head\")[0].appendChild(n), n.src = e } }, sdkLoader: function(e, t, n) { t in window && window[t] ? (k && clearTimeout(k), n && n()) : l.default.dynamicLoadSource(e, function() { k = setTimeout(l.default.sdkLoader(e, t, n), 100) }) }, deleteInWin: function(e, t) { var n = function(t) { if (e in window) try { delete window[e] } catch (t) { window[e] = null } }; 0 === t ? n() : setTimeout(n, t || 500) }, ajax: function(e) { e = e || {}, e.type = (e.type || \"GET\").toUpperCase(), e.dataType = e.dataType || \"json\", e.async = e.async || !0, e.timeout = e.timeout || 8e3; var t = \"[object FormData]\" == {}.toString.call(e.data) ? e.data : function(e) { var t = []; for (var n in e) t.push(encodeURIComponent(n) + \"=\" + encodeURIComponent(e[n])); return t.push(\"t=\" + Date.now()), t.join(\"&\") }(e.data) , n = null , r = \"XMLHttpRequest\"in window ? new XMLHttpRequest : new ActiveXObject(\"Microsoft.XMLHTTP\"); r.onreadystatechange = function(t) { if (4 == r.readyState) { clearTimeout(n); var o = r.status; o >= 200 && o < 300 ? e.success && e.success(JSON.parse(r.responseText)) : e.fail && e.fail(o) } } , \"GET\" == e.type ? (r.open(\"GET\", e.url + \"?\" + t, e.async), r.send(null)) : \"POST\" == e.type && (r.open(\"POST\", e.url, e.async), void 0 == e.contentType || null == e.contentType ? r.send(t) : (r.setRequestHeader(\"Content-Type\", e.contentType), r.send(JSON.stringify(e.data)))), n = setTimeout(function(e) { clearTimeout(n), r.abort() }, e.timeout) } }), t.default = l.default } , function(e, t, n) { \"use strict\"; var r = TypeError , o = Object.getOwnPropertyDescriptor; if (o) try { o({}, \"\") } catch (e) { o = null } var i, a, s = function() { throw new r }, l = o ? function() { try { return arguments.callee, s } catch (e) { try { return o(arguments, \"callee\").get } catch (e) { return s } } }() : s, c = n(47)(), u = Object.getPrototypeOf || function(e) { return e.__proto__ } , d = i ? u(i) : void 0, p = a ? u(a) : void 0, f = a ? a() : void 0, h = \"undefined\" == typeof Uint8Array ? void 0 : u(Uint8Array), v = { \"%Array%\": Array, \"%ArrayBuffer%\": \"undefined\" == typeof ArrayBuffer ? void 0 : ArrayBuffer, \"%ArrayBufferPrototype%\": \"undefined\" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, \"%ArrayIteratorPrototype%\": c ? u([][Symbol.iterator]()) : void 0, \"%ArrayPrototype%\": Array.prototype, \"%ArrayProto_entries%\": Array.prototype.entries, \"%ArrayProto_forEach%\": Array.prototype.forEach, \"%ArrayProto_keys%\": Array.prototype.keys, \"%ArrayProto_values%\": Array.prototype.values, \"%AsyncFromSyncIteratorPrototype%\": void 0, \"%AsyncFunction%\": void 0, \"%AsyncFunctionPrototype%\": void 0, \"%AsyncGenerator%\": a ? u(f) : void 0, \"%AsyncGeneratorFunction%\": p, \"%AsyncGeneratorPrototype%\": p ? p.prototype : void 0, \"%AsyncIteratorPrototype%\": f && c && Symbol.asyncIterator ? f[Symbol.asyncIterator]() : void 0, \"%Atomics%\": \"undefined\" == typeof Atomics ? void 0 : Atomics, \"%Boolean%\": Boolean, \"%BooleanPrototype%\": Boolean.prototype, \"%DataView%\": \"undefined\" == typeof DataView ? void 0 : DataView, \"%DataViewPrototype%\": \"undefined\" == typeof DataView ? void 0 : DataView.prototype, \"%Date%\": Date, \"%DatePrototype%\": Date.prototype, \"%decodeURI%\": decodeURI, \"%decodeURIComponent%\": decodeURIComponent, \"%encodeURI%\": encodeURI, \"%encodeURIComponent%\": encodeURIComponent, \"%Error%\": Error, \"%ErrorPrototype%\": Error.prototype, \"%eval%\": eval, \"%EvalError%\": EvalError, \"%EvalErrorPrototype%\": EvalError.prototype, \"%Float32Array%\": \"undefined\" == typeof Float32Array ? void 0 : Float32Array, \"%Float32ArrayPrototype%\": \"undefined\" == typeof Float32Array ? void 0 : Float32Array.prototype, \"%Float64Array%\": \"undefined\" == typeof Float64Array ? void 0 : Float64Array, \"%Float64ArrayPrototype%\": \"undefined\" == typeof Float64Array ? void 0 : Float64Array.prototype, \"%Function%\": Function, \"%FunctionPrototype%\": Function.prototype, \"%Generator%\": i ? u(i()) : void 0, \"%GeneratorFunction%\": d, \"%GeneratorPrototype%\": d ? d.prototype : void 0, \"%Int8Array%\": \"undefined\" == typeof Int8Array ? void 0 : Int8Array, \"%Int8ArrayPrototype%\": \"undefined\" == typeof Int8Array ? void 0 : Int8Array.prototype, \"%Int16Array%\": \"undefined\" == typeof Int16Array ? void 0 : Int16Array, \"%Int16ArrayPrototype%\": \"undefined\" == typeof Int16Array ? void 0 : Int8Array.prototype, \"%Int32Array%\": \"undefined\" == typeof Int32Array ? void 0 : Int32Array, \"%Int32ArrayPrototype%\": \"undefined\" == typeof Int32Array ? void 0 : Int32Array.prototype, \"%isFinite%\": isFinite, \"%isNaN%\": isNaN, \"%IteratorPrototype%\": c ? u(u([][Symbol.iterator]())) : void 0, \"%JSON%\": \"object\" == typeof JSON ? JSON : void 0, \"%JSONParse%\": \"object\" == typeof JSON ? JSON.parse : void 0, \"%Map%\": \"undefined\" == typeof Map ? void 0 : Map, \"%MapIteratorPrototype%\": \"undefined\" != typeof Map && c ? u((new Map)[Symbol.iterator]()) : void 0, \"%MapPrototype%\": \"undefined\" == typeof Map ? void 0 : Map.prototype, \"%Math%\": Math, \"%Number%\": Number, \"%NumberPrototype%\": Number.prototype, \"%Object%\": Object, \"%ObjectPrototype%\": Object.prototype, \"%ObjProto_toString%\": Object.prototype.toString, \"%ObjProto_valueOf%\": Object.prototype.valueOf, \"%parseFloat%\": parseFloat, \"%parseInt%\": parseInt, \"%Promise%\": \"undefined\" == typeof Promise ? void 0 : Promise, \"%PromisePrototype%\": \"undefined\" == typeof Promise ? void 0 : Promise.prototype, \"%PromiseProto_then%\": \"undefined\" == typeof Promise ? void 0 : Promise.prototype.then, \"%Promise_all%\": \"undefined\" == typeof Promise ? void 0 : Promise.all, \"%Promise_reject%\": \"undefined\" == typeof Promise ? void 0 : Promise.reject, \"%Promise_resolve%\": \"undefined\" == typeof Promise ? void 0 : Promise.resolve, \"%Proxy%\": \"undefined\" == typeof Proxy ? void 0 : Proxy, \"%RangeError%\": RangeError, \"%RangeErrorPrototype%\": RangeError.prototype, \"%ReferenceError%\": ReferenceError, \"%ReferenceErrorPrototype%\": ReferenceError.prototype, \"%Reflect%\": \"undefined\" == typeof Reflect ? void 0 : Reflect, \"%RegExp%\": RegExp, \"%RegExpPrototype%\": RegExp.prototype, \"%Set%\": \"undefined\" == typeof Set ? void 0 : Set, \"%SetIteratorPrototype%\": \"undefined\" != typeof Set && c ? u((new Set)[Symbol.iterator]()) : void 0, \"%SetPrototype%\": \"undefined\" == typeof Set ? void 0 : Set.prototype, \"%SharedArrayBuffer%\": \"undefined\" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, \"%SharedArrayBufferPrototype%\": \"undefined\" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, \"%String%\": String, \"%StringIteratorPrototype%\": c ? u(\"\"[Symbol.iterator]()) : void 0, \"%StringPrototype%\": String.prototype, \"%Symbol%\": c ? Symbol : void 0, \"%SymbolPrototype%\": c ? Symbol.prototype : void 0, \"%SyntaxError%\": SyntaxError, \"%SyntaxErrorPrototype%\": SyntaxError.prototype, \"%ThrowTypeError%\": l, \"%TypedArray%\": h, \"%TypedArrayPrototype%\": h ? h.prototype : void 0, \"%TypeError%\": r, \"%TypeErrorPrototype%\": r.prototype, \"%Uint8Array%\": \"undefined\" == typeof Uint8Array ? void 0 : Uint8Array, \"%Uint8ArrayPrototype%\": \"undefined\" == typeof Uint8Array ? void 0 : Uint8Array.prototype, \"%Uint8ClampedArray%\": \"undefined\" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, \"%Uint8ClampedArrayPrototype%\": \"undefined\" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, \"%Uint16Array%\": \"undefined\" == typeof Uint16Array ? void 0 : Uint16Array, \"%Uint16ArrayPrototype%\": \"undefined\" == typeof Uint16Array ? void 0 : Uint16Array.prototype, \"%Uint32Array%\": \"undefined\" == typeof Uint32Array ? void 0 : Uint32Array, \"%Uint32ArrayPrototype%\": \"undefined\" == typeof Uint32Array ? void 0 : Uint32Array.prototype, \"%URIError%\": URIError, \"%URIErrorPrototype%\": URIError.prototype, \"%WeakMap%\": \"undefined\" == typeof WeakMap ? void 0 : WeakMap, \"%WeakMapPrototype%\": \"undefined\" == typeof WeakMap ? void 0 : WeakMap.prototype, \"%WeakSet%\": \"undefined\" == typeof WeakSet ? void 0 : WeakSet, \"%WeakSetPrototype%\": \"undefined\" == typeof WeakSet ? void 0 : WeakSet.prototype }, g = n(4), m = g.call(Function.call, String.prototype.replace), y = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g, b = /\\\\(\\\\)?/g, w = function(e) { var t = []; return m(e, y, function(e, n, r, o) { t[t.length] = r ? m(o, b, \"$1\") : n || e }), t }, x = function(e, t) { if (!(e in v)) throw new SyntaxError(\"intrinsic \" + e + \" does not exist!\"); if (void 0 === v[e] && !t) throw new r(\"intrinsic \" + e + \" exists, but is not available. Please file an issue!\"); return v[e] }; e.exports = function(e, t) { if (\"string\" != typeof e || 0 === e.length) throw new TypeError(\"intrinsic name must be a non-empty string\"); if (arguments.length > 1 && \"boolean\" != typeof t) throw new TypeError('\"allowMissing\" argument must be a boolean'); for (var n = w(e), i = x(\"%\" + (n.length > 0 ? n[0] : \"\") + \"%\", t), a = 1; a < n.length; a += 1) if (null != i) if (o && a + 1 >= n.length) { var s = o(i, n[a]); if (!(t || n[a]in i)) throw new r(\"base intrinsic for \" + e + \" exists, but the property is not available.\"); i = s ? s.get || s.value : i[n[a]] } else i = i[n[a]]; return i } } , function(e, t, n) { \"use strict\"; t.__esModule = !0; t.DEFAULT_EMOJI_CDN = \"//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/\", t.DB_NAME = \"Comment\", t.defaultConfig = { lang: \"zh-CN\", langMode: null, appId: \"\", appKey: \"\", clazzName: \"Comment\", meta: [\"nick\", \"mail\", \"link\"], path: location.pathname, placeholder: \"Just Go Go\", pageSize: 10, recordIP: !0, serverURLs: \"\", visitor: !1, emojiCDN: \"\", emojiMaps: void 0, enableQQ: !1, requiredFields: [] }, t.defaultMeta = [\"nick\", \"mail\", \"link\"], t.QQCacheKey = \"_v_Cache_Q\", t.MetaCacheKey = \"_v_Cache_Meta\", t.RandomStr = (Date.now() + Math.round(1e3 * Math.random())).toString(32), t.VERSION = \"1.4.14\" } , function(e, t, n) { function r(e, t) { return new i(t).process(e) } var o = n(7) , i = n(29); t = e.exports = r, t.FilterCSS = i; for (var a in o) t[a] = o[a]; \"undefined\" != typeof window && (window.filterCSS = e.exports) } , function(e, t, n) { \"use strict\"; var r = n(32); e.exports = Function.prototype.bind || r } , function(e, t) { e.exports = { indexOf: function(e, t) { var n, r; if (Array.prototype.indexOf) return e.indexOf(t); for (n = 0, r = e.length; n < r; n++) if (e[n] === t) return n; return -1 }, forEach: function(e, t, n) { var r, o; if (Array.prototype.forEach) return e.forEach(t, n); for (r = 0, o = e.length; r < o; r++) t.call(n, e[r], r, e) }, trim: function(e) { return String.prototype.trim ? e.trim() : e.replace(/(^\\s*)|(\\s*$)/g, \"\") }, spaceIndex: function(e) { var t = /\\s|\\n|\\t/ , n = t.exec(e); return n ? n.index : -1 } } } , function(e, t, n) { \"use strict\"; t.__esModule = !0; var r = n(2) , o = { cdn: r.DEFAULT_EMOJI_CDN, maps: n(53), parse: function(e) { return String(e).replace(new RegExp(\":(\" + Object.keys(o.maps).join(\"|\") + \"):\",\"ig\"), function(e, t) { return o.maps[t] ? o.build(t) : e }) }, build: function(e) { var t = /^(https?:)?\\/\\//i , n = o.maps[e] , r = t.test(n) ? n : o.cdn + n; return t.test(r) ? '' : \"\" } }; t.default = o } , function(e, t) { function n() { var e = {}; return e[\"align-content\"] = !1, e[\"align-items\"] = !1, e[\"align-self\"] = !1, e[\"alignment-adjust\"] = !1, e[\"alignment-baseline\"] = !1, e.all = !1, e[\"anchor-point\"] = !1, e.animation = !1, e[\"animation-delay\"] = !1, e[\"animation-direction\"] = !1, e[\"animation-duration\"] = !1, e[\"animation-fill-mode\"] = !1, e[\"animation-iteration-count\"] = !1, e[\"animation-name\"] = !1, e[\"animation-play-state\"] = !1, e[\"animation-timing-function\"] = !1, e.azimuth = !1, e[\"backface-visibility\"] = !1, e.background = !0, e[\"background-attachment\"] = !0, e[\"background-clip\"] = !0, e[\"background-color\"] = !0, e[\"background-image\"] = !0, e[\"background-origin\"] = !0, e[\"background-position\"] = !0, e[\"background-repeat\"] = !0, e[\"background-size\"] = !0, e[\"baseline-shift\"] = !1, e.binding = !1, e.bleed = !1, e[\"bookmark-label\"] = !1, e[\"bookmark-level\"] = !1, e[\"bookmark-state\"] = !1, e.border = !0, e[\"border-bottom\"] = !0, e[\"border-bottom-color\"] = !0, e[\"border-bottom-left-radius\"] = !0, e[\"border-bottom-right-radius\"] = !0, e[\"border-bottom-style\"] = !0, e[\"border-bottom-width\"] = !0, e[\"border-collapse\"] = !0, e[\"border-color\"] = !0, e[\"border-image\"] = !0, e[\"border-image-outset\"] = !0, e[\"border-image-repeat\"] = !0, e[\"border-image-slice\"] = !0, e[\"border-image-source\"] = !0, e[\"border-image-width\"] = !0, e[\"border-left\"] = !0, e[\"border-left-color\"] = !0, e[\"border-left-style\"] = !0, e[\"border-left-width\"] = !0, e[\"border-radius\"] = !0, e[\"border-right\"] = !0, e[\"border-right-color\"] = !0, e[\"border-right-style\"] = !0, e[\"border-right-width\"] = !0, e[\"border-spacing\"] = !0, e[\"border-style\"] = !0, e[\"border-top\"] = !0, e[\"border-top-color\"] = !0, e[\"border-top-left-radius\"] = !0, e[\"border-top-right-radius\"] = !0, e[\"border-top-style\"] = !0, e[\"border-top-width\"] = !0, e[\"border-width\"] = !0, e.bottom = !1, e[\"box-decoration-break\"] = !0, e[\"box-shadow\"] = !0, e[\"box-sizing\"] = !0, e[\"box-snap\"] = !0, e[\"box-suppress\"] = !0, e[\"break-after\"] = !0, e[\"break-before\"] = !0, e[\"break-inside\"] = !0, e[\"caption-side\"] = !1, e.chains = !1, e.clear = !0, e.clip = !1, e[\"clip-path\"] = !1, e[\"clip-rule\"] = !1, e.color = !0, e[\"color-interpolation-filters\"] = !0, e[\"column-count\"] = !1, e[\"column-fill\"] = !1, e[\"column-gap\"] = !1, e[\"column-rule\"] = !1, e[\"column-rule-color\"] = !1, e[\"column-rule-style\"] = !1, e[\"column-rule-width\"] = !1, e[\"column-span\"] = !1, e[\"column-width\"] = !1, e.columns = !1, e.contain = !1, e.content = !1, e[\"counter-increment\"] = !1, e[\"counter-reset\"] = !1, e[\"counter-set\"] = !1, e.crop = !1, e.cue = !1, e[\"cue-after\"] = !1, e[\"cue-before\"] = !1, e.cursor = !1, e.direction = !1, e.display = !0, e[\"display-inside\"] = !0, e[\"display-list\"] = !0, e[\"display-outside\"] = !0, e[\"dominant-baseline\"] = !1, e.elevation = !1, e[\"empty-cells\"] = !1, e.filter = !1, e.flex = !1, e[\"flex-basis\"] = !1, e[\"flex-direction\"] = !1, e[\"flex-flow\"] = !1, e[\"flex-grow\"] = !1, e[\"flex-shrink\"] = !1, e[\"flex-wrap\"] = !1, e.float = !1, e[\"float-offset\"] = !1, e[\"flood-color\"] = !1, e[\"flood-opacity\"] = !1, e[\"flow-from\"] = !1, e[\"flow-into\"] = !1, e.font = !0, e[\"font-family\"] = !0, e[\"font-feature-settings\"] = !0, e[\"font-kerning\"] = !0, e[\"font-language-override\"] = !0, e[\"font-size\"] = !0, e[\"font-size-adjust\"] = !0, e[\"font-stretch\"] = !0, e[\"font-style\"] = !0, e[\"font-synthesis\"] = !0, e[\"font-variant\"] = !0, e[\"font-variant-alternates\"] = !0, e[\"font-variant-caps\"] = !0, e[\"font-variant-east-asian\"] = !0, e[\"font-variant-ligatures\"] = !0, e[\"font-variant-numeric\"] = !0, e[\"font-variant-position\"] = !0, e[\"font-weight\"] = !0, e.grid = !1, e[\"grid-area\"] = !1, e[\"grid-auto-columns\"] = !1, e[\"grid-auto-flow\"] = !1, e[\"grid-auto-rows\"] = !1, e[\"grid-column\"] = !1, e[\"grid-column-end\"] = !1, e[\"grid-column-start\"] = !1, e[\"grid-row\"] = !1, e[\"grid-row-end\"] = !1, e[\"grid-row-start\"] = !1, e[\"grid-template\"] = !1, e[\"grid-template-areas\"] = !1, e[\"grid-template-columns\"] = !1, e[\"grid-template-rows\"] = !1, e[\"hanging-punctuation\"] = !1, e.height = !0, e.hyphens = !1, e.icon = !1, e[\"image-orientation\"] = !1, e[\"image-resolution\"] = !1, e[\"ime-mode\"] = !1, e[\"initial-letters\"] = !1, e[\"inline-box-align\"] = !1, e[\"justify-content\"] = !1, e[\"justify-items\"] = !1, e[\"justify-self\"] = !1, e.left = !1, e[\"letter-spacing\"] = !0, e[\"lighting-color\"] = !0, e[\"line-box-contain\"] = !1, e[\"line-break\"] = !1, e[\"line-grid\"] = !1, e[\"line-height\"] = !1, e[\"line-snap\"] = !1, e[\"line-stacking\"] = !1, e[\"line-stacking-ruby\"] = !1, e[\"line-stacking-shift\"] = !1, e[\"line-stacking-strategy\"] = !1, e[\"list-style\"] = !0, e[\"list-style-image\"] = !0, e[\"list-style-position\"] = !0, e[\"list-style-type\"] = !0, e.margin = !0, e[\"margin-bottom\"] = !0, e[\"margin-left\"] = !0, e[\"margin-right\"] = !0, e[\"margin-top\"] = !0, e[\"marker-offset\"] = !1, e[\"marker-side\"] = !1, e.marks = !1, e.mask = !1, e[\"mask-box\"] = !1, e[\"mask-box-outset\"] = !1, e[\"mask-box-repeat\"] = !1, e[\"mask-box-slice\"] = !1, e[\"mask-box-source\"] = !1, e[\"mask-box-width\"] = !1, e[\"mask-clip\"] = !1, e[\"mask-image\"] = !1, e[\"mask-origin\"] = !1, e[\"mask-position\"] = !1, e[\"mask-repeat\"] = !1, e[\"mask-size\"] = !1, e[\"mask-source-type\"] = !1, e[\"mask-type\"] = !1, e[\"max-height\"] = !0, e[\"max-lines\"] = !1, e[\"max-width\"] = !0, e[\"min-height\"] = !0, e[\"min-width\"] = !0, e[\"move-to\"] = !1, e[\"nav-down\"] = !1, e[\"nav-index\"] = !1, e[\"nav-left\"] = !1, e[\"nav-right\"] = !1, e[\"nav-up\"] = !1, e[\"object-fit\"] = !1, e[\"object-position\"] = !1, e.opacity = !1, e.order = !1, e.orphans = !1, e.outline = !1, e[\"outline-color\"] = !1, e[\"outline-offset\"] = !1, e[\"outline-style\"] = !1, e[\"outline-width\"] = !1, e.overflow = !1, e[\"overflow-wrap\"] = !1, e[\"overflow-x\"] = !1, e[\"overflow-y\"] = !1, e.padding = !0, e[\"padding-bottom\"] = !0, e[\"padding-left\"] = !0, e[\"padding-right\"] = !0, e[\"padding-top\"] = !0, e.page = !1, e[\"page-break-after\"] = !1, e[\"page-break-before\"] = !1, e[\"page-break-inside\"] = !1, e[\"page-policy\"] = !1, e.pause = !1, e[\"pause-after\"] = !1, e[\"pause-before\"] = !1, e.perspective = !1, e[\"perspective-origin\"] = !1, e.pitch = !1, e[\"pitch-range\"] = !1, e[\"play-during\"] = !1, e.position = !1, e[\"presentation-level\"] = !1, e.quotes = !1, e[\"region-fragment\"] = !1, e.resize = !1, e.rest = !1, e[\"rest-after\"] = !1, e[\"rest-before\"] = !1, e.richness = !1, e.right = !1, e.rotation = !1, e[\"rotation-point\"] = !1, e[\"ruby-align\"] = !1, e[\"ruby-merge\"] = !1, e[\"ruby-position\"] = !1, e[\"shape-image-threshold\"] = !1, e[\"shape-outside\"] = !1, e[\"shape-margin\"] = !1, e.size = !1, e.speak = !1, e[\"speak-as\"] = !1, e[\"speak-header\"] = !1, e[\"speak-numeral\"] = !1, e[\"speak-punctuation\"] = !1, e[\"speech-rate\"] = !1, e.stress = !1, e[\"string-set\"] = !1, e[\"tab-size\"] = !1, e[\"table-layout\"] = !1, e[\"text-align\"] = !0, e[\"text-align-last\"] = !0, e[\"text-combine-upright\"] = !0, e[\"text-decoration\"] = !0, e[\"text-decoration-color\"] = !0, e[\"text-decoration-line\"] = !0, e[\"text-decoration-skip\"] = !0, e[\"text-decoration-style\"] = !0, e[\"text-emphasis\"] = !0, e[\"text-emphasis-color\"] = !0, e[\"text-emphasis-position\"] = !0, e[\"text-emphasis-style\"] = !0, e[\"text-height\"] = !0, e[\"text-indent\"] = !0, e[\"text-justify\"] = !0, e[\"text-orientation\"] = !0, e[\"text-overflow\"] = !0, e[\"text-shadow\"] = !0, e[\"text-space-collapse\"] = !0, e[\"text-transform\"] = !0, e[\"text-underline-position\"] = !0, e[\"text-wrap\"] = !0, e.top = !1, e.transform = !1, e[\"transform-origin\"] = !1, e[\"transform-style\"] = !1, e.transition = !1, e[\"transition-delay\"] = !1, e[\"transition-duration\"] = !1, e[\"transition-property\"] = !1, e[\"transition-timing-function\"] = !1, e[\"unicode-bidi\"] = !1, e[\"vertical-align\"] = !1, e.visibility = !1, e[\"voice-balance\"] = !1, e[\"voice-duration\"] = !1, e[\"voice-family\"] = !1, e[\"voice-pitch\"] = !1, e[\"voice-range\"] = !1, e[\"voice-rate\"] = !1, e[\"voice-stress\"] = !1, e[\"voice-volume\"] = !1, e.volume = !1, e[\"white-space\"] = !1, e.widows = !1, e.width = !0, e[\"will-change\"] = !1, e[\"word-break\"] = !0, e[\"word-spacing\"] = !0, e[\"word-wrap\"] = !0, e[\"wrap-flow\"] = !1, e[\"wrap-through\"] = !1, e[\"writing-mode\"] = !1, e[\"z-index\"] = !1, e } function r(e, t, n) {} function o(e, t, n) {} function i(e, t) { return a.test(t) ? \"\" : t } var a = /javascript\\s*\\:/gim; t.whiteList = n(), t.getDefaultWhiteList = n, t.onAttr = r, t.onIgnoreAttr = o, t.safeAttrValue = i } , function(e, t) { e.exports = { indexOf: function(e, t) { var n, r; if (Array.prototype.indexOf) return e.indexOf(t); for (n = 0, r = e.length; n < r; n++) if (e[n] === t) return n; return -1 }, forEach: function(e, t, n) { var r, o; if (Array.prototype.forEach) return e.forEach(t, n); for (r = 0, o = e.length; r < o; r++) t.call(n, e[r], r, e) }, trim: function(e) { return String.prototype.trim ? e.trim() : e.replace(/(^\\s*)|(\\s*$)/g, \"\") }, trimRight: function(e) { return String.prototype.trimRight ? e.trimRight() : e.replace(/(\\s*$)/g, \"\") } } } , function(e, t, n) { \"use strict\"; var r = n(40) , o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol(\"foo\") , i = Object.prototype.toString , a = Array.prototype.concat , s = Object.defineProperty , l = function(e) { return \"function\" == typeof e && \"[object Function]\" === i.call(e) } , c = s && function() { var e = {}; try { s(e, \"x\", { enumerable: !1, value: e }); for (var t in e) return !1; return e.x === e } catch (e) { return !1 } }() , u = function(e, t, n, r) { (!(t in e) || l(r) && r()) && (c ? s(e, t, { configurable: !0, enumerable: !1, value: n, writable: !0 }) : e[t] = n) } , d = function(e, t) { var n = arguments.length > 2 ? arguments[2] : {} , i = r(t); o && (i = a.call(i, Object.getOwnPropertySymbols(t))); for (var s = 0; s < i.length; s += 1) u(e, i[s], t[i[s]], n[i[s]]) }; d.supportsDescriptors = !!c, e.exports = d } , function(e, t, n) { \"use strict\"; var r = Object.prototype.toString; e.exports = function(e) { var t = r.call(e) , n = \"[object Arguments]\" === t; return n || (n = \"[object Array]\" !== t && null !== e && \"object\" == typeof e && \"number\" == typeof e.length && e.length >= 0 && \"[object Function]\" === r.call(e.callee)), n } } , function(e, t, n) { \"use strict\"; var r = n(45) , o = n(44) , i = n(46) , a = i(\"String.prototype.replace\") , s = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+/ , l = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+$/; e.exports = function() { var e = o(r(this)); return a(a(e, s, \"\"), l, \"\") } } , function(e, t, n) { \"use strict\"; var r = n(4) , o = n(1) , i = o(\"%Function%\") , a = i.apply , s = i.call; e.exports = function() { return r.apply(s, arguments) } , e.exports.apply = function() { return r.apply(a, arguments) } } , function(e, t, n) { \"use strict\"; var r = n(11) , o = \"​\"; e.exports = function() { return String.prototype.trim && o.trim() === o ? String.prototype.trim : r } } , function(e, t) { var n; n = function() { return this }(); try { n = n || Function(\"return this\")() || (0, eval)(\"this\") } catch (e) { \"object\" == typeof window && (n = window) } e.exports = n } , function(e, t, n) { function r() { return { a: [\"target\", \"href\", \"title\"], abbr: [\"title\"], address: [], area: [\"shape\", \"coords\", \"href\", \"alt\"], article: [], aside: [], audio: [\"autoplay\", \"controls\", \"loop\", \"preload\", \"src\"], b: [], bdi: [\"dir\"], bdo: [\"dir\"], big: [], blockquote: [\"cite\"], br: [], caption: [], center: [], cite: [], code: [], col: [\"align\", \"valign\", \"span\", \"width\"], colgroup: [\"align\", \"valign\", \"span\", \"width\"], dd: [], del: [\"datetime\"], details: [\"open\"], div: [], dl: [], dt: [], em: [], font: [\"color\", \"size\", \"face\"], footer: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], header: [], hr: [], i: [], img: [\"src\", \"alt\", \"title\", \"width\", \"height\"], ins: [\"datetime\"], li: [], mark: [], nav: [], ol: [], p: [], pre: [], s: [], section: [], small: [], span: [], sub: [], sup: [], strong: [], table: [\"width\", \"border\", \"align\", \"valign\"], tbody: [\"align\", \"valign\"], td: [\"width\", \"rowspan\", \"colspan\", \"align\", \"valign\"], tfoot: [\"align\", \"valign\"], th: [\"width\", \"rowspan\", \"colspan\", \"align\", \"valign\"], thead: [\"align\", \"valign\"], tr: [\"rowspan\", \"align\", \"valign\"], tt: [], u: [], ul: [], video: [\"autoplay\", \"controls\", \"loop\", \"preload\", \"src\", \"height\", \"width\"] } } function o(e, t, n) {} function i(e, t, n) {} function a(e, t, n) {} function s(e, t, n) {} function l(e) { return e.replace(S, \"&lt;\").replace(O, \"&gt;\") } function c(e, t, n, r) { if (n = v(n), \"href\" === t || \"src\" === t) { if (\"#\" === (n = _.trim(n))) return \"#\"; if (\"http://\" !== n.substr(0, 7) && \"https://\" !== n.substr(0, 8) && \"mailto:\" !== n.substr(0, 7) && \"tel:\" !== n.substr(0, 4) && \"#\" !== n[0] && \"/\" !== n[0]) return \"\" } else if (\"background\" === t) { if (I.lastIndex = 0, I.test(n)) return \"\" } else if (\"style\" === t) { if (P.lastIndex = 0, P.test(n)) return \"\"; if (M.lastIndex = 0, M.test(n) && (I.lastIndex = 0, I.test(n))) return \"\"; !1 !== r && (r = r || A, n = r.process(n)) } return n = g(n) } function u(e) { return e.replace($, \"&quot;\") } function d(e) { return e.replace(E, '\"') } function p(e) { return e.replace(j, function(e, t) { return \"x\" === t[0] || \"X\" === t[0] ? String.fromCharCode(parseInt(t.substr(1), 16)) : String.fromCharCode(parseInt(t, 10)) }) } function f(e) { return e.replace(T, \":\").replace(C, \" \") } function h(e) { for (var t = \"\", n = 0, r = e.length; n < r; n++) t += e.charCodeAt(n) < 32 ? \" \" : e.charAt(n); return _.trim(t) } function v(e) { return e = d(e), e = p(e), e = f(e), e = h(e) } function g(e) { return e = u(e), e = l(e) } function m() { return \"\" } function y(e, t) { function n(t) { return !!r || -1 !== _.indexOf(e, t) } \"function\" != typeof t && (t = function() {} ); var r = !Array.isArray(e) , o = [] , i = !1; return { onIgnoreTag: function(e, r, a) { if (n(e)) { if (a.isClosing) { var s = \"[/removed]\" , l = a.position + s.length; return o.push([!1 !== i ? i : a.position, l]), i = !1, s } return i || (i = a.position), \"[removed]\" } return t(e, r, a) }, remove: function(e) { var t = \"\" , n = 0; return _.forEach(o, function(r) { t += e.slice(n, r[0]), n = r[1] }), t += e.slice(n) } } } function b(e) { return e.replace(R, \"\") } function w(e) { var t = e.split(\"\"); return t = t.filter(function(e) { var t = e.charCodeAt(0); return 127 !== t && (!(t"}],"posts":[{"title":"模拟空调遥控器代码","slug":"模拟空调遥控器代码","date":"2021-01-20T16:00:45.253Z","updated":"2021-01-20T16:00:45.254Z","comments":true,"path":"2021/01/21/模拟空调遥控器代码/","link":"","permalink":"https://tetedetian.github.io/2021/01/21/%E6%A8%A1%E6%8B%9F%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8%E4%BB%A3%E7%A0%81/","excerpt":"基于C51单片机的模拟空调遥控器代码","text":"基于C51单片机的模拟空调遥控器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431#include&lt;reg51.h&gt;#define uchar unsigned char#define uint unsigned int#define LCD1602_DB P0unsigned char code led_mod[10]=&#123;0x28, 0x7E, 0xA2,0x62,0x74, 0x61, 0x21,0x7A, 0x20,0x60&#125;;sbit RS=P2^0;sbit RW=P2^1;sbit E=P2^2;sbit beep=P3^5;sbit speed_led=P3^7; //⻛风速灯接⼝口uchar k=1;//按键1控制变量量uchar m=0;//按键4(模式)控制变量量uchar temperature=27; //温度变量量uchar speed_num=1; //⻛风速控制变量量uint high,low;uchar a=1; //步进电机⾥里里⾯面控制正转反转的变量量uint motor_contrl_1=0; //计算步进电机转动次数的变量量(6次⼀一反转)uchar motor_contrl_2=0; //实现步进电机⻓长按功能的辅助变量量uchar hour=1,min=59; //倒计时⼩小时和分钟变量量uchar bell_num=0,bell_hour=0,bell_min=0; //bell_num记录按了了⼏几次， bell_hour， bell_min⽤用来实现闪烁功能的/**********延时函数**********/void delay(uint z)&#123; uint i, j; for (i = 0; i &lt; z; i++) for (j = 0; j &lt; 125; j++);&#125;/**********计时器器初始化**********/void time_initialize()&#123; EA = 1; TR0 = 1; ET0 = 1; TMOD = 0x11;&#125;/**********变量量初始化函数，终于倒计时结束后的初始化**********/void all_initialize()&#123; k = 1; m = 0; temperature = 27; speed_num = 1; a = 1; motor_contrl_1 = 0; motor_contrl_2 = 0; hour = 2; min = 59; bell_num = 0; bell_hour = 0; bell_min = 0;&#125;/**********按键扫描函数**********/uchar KeyScan()&#123; uchar i; uchar h, l; //⾏值和列值存储变量量 P1 = 0xf0; //给P1置初值11110000 if ((P1 &amp; 0xf0) != 0xf0) //检测是否有按键按下 &#123; delay(40); //延时消抖 if ((P1 &amp; 0xf0) != 0xf0) //再次检测 &#123; l = P1 &amp; 0xf0; //存列列值 P1 = l | 0x0f; h = P1 &amp; 0x0f; //存⾏行行值 while ((P1 &amp; 0x0f != 0x0f)); //等待按键提起 for (i = 0; i &lt; 30; i++) //蜂鸣器器响 &#123; beep = ~beep; delay(1); &#125; return(l + h); //返回键值 &#125; &#125;&#125;/**********1602写数据函数**********/void LcdWriteData(uchar dat) &#123; RS = 1; RW = 0; LCD1602_DB = dat; delay(1); E = 1; delay(2); E = 0;&#125;/**********1602写指令函数**********/void LcdWriteCmd(uchar cmd) &#123; RS = 0; RW = 0; LCD1602_DB = cmd; delay(1); E = 1; delay(2); E = 0;&#125;/**********指针函数，控制写入位置**********/void set_cursor_pos(unsigned char x, unsigned char y) &#123; if (y == 0) &#123; LcdWriteCmd(0x80 + x); &#125; else &#123; LcdWriteCmd(0xc0 + x); &#125;&#125;/**********按键1函数，利用变量k，实现开显示与关显示**********/void key_1() &#123; if (k == 1) LcdWriteCmd(0x0c); else LcdWriteCmd(0x08); k++; if (k &gt; 2) k = 1;&#125;/**********温度写入函数**********/void Temp() &#123; set_cursor_pos(0, 0); LcdWriteData(temperature / 10 + 0x30); LcdWriteData(temperature % 10 + 0x30); LcdWriteData('C');&#125;/**********模式写⼊函数**********/void Mode() &#123; uchar n; uchar mode[3][4] = &#123; &#123;'A','U','T','O'&#125;,&#123;'C','O','O','L'&#125;,&#123;'H','O','T',' ' &#125; &#125;; if (m &gt; 2) m = 0; set_cursor_pos(5, 0); for (n = 0; n &lt; 4; n++) &#123; LcdWriteData(mode[m][n]); &#125;&#125;/**********风速显示写⼊函数**********/void Speed() &#123; uchar i; uchar speed = '&lt;'; if (speed_num &gt; 3) //按3次后清屏回到⼀一档 &#123; speed_num = 1; LcdWriteCmd(0x01); &#125; set_cursor_pos(11, 0); for (i = 0; i &lt; speed_num; i++) &#123; LcdWriteData(speed); &#125;&#125;/**********步进电机控制函数， angle为⻆角度， dir控制正转或反转**********/void Motor(uchar angle, uchar dir) &#123; uchar i; uchar tmp; //临时变量量，存储P3的中间变量量uchar index=0; //节拍输出索引 uint beats = 0; //电机转动节拍数 uchar code beatcode[8] = &#123; 0x0e,0x0c,0x0d,0x09,0x0b,0x03,0x07,0x06 &#125;; //节拍控制代码 beats = angle * 4096 / 360; if (dir == 1) &#123; for (i = 0; i &lt; beats; i++) &#123; tmp = P3; tmp = tmp &amp; 0xf0; //为了了不不影响P3另外四个接⼝口 tmp = tmp | beatcode[index]; P3 = tmp; delay(10); //延迟，给步进电机⾜足够时间 index++; if (index == 8) index = 0; //到8归0 &#125; &#125; else &#123; for (i = 0; i &lt; beats; i++) &#123; tmp = P3; tmp = tmp &amp; 0xf0; tmp = tmp | beatcode[index]; P3 = tmp; delay(10); index--; if (index == -1) index = 7; &#125; &#125;&#125;/**********风速led亮度调节函数， f为频率， p为占空⽐**********/void PWM(uint f, uchar p) &#123; unsigned long tmp; tmp = 1000000 / f; //⼀一个周期所需要的计数值 low = (tmp*(p)) / 100; //低电平需要的计数值 high = tmp - low; TH0 = (65536 - high) / 256; TL0 = (65536 - high) % 256; speed_led = 1;&#125;/**********按键6函数，实现步进电机3个功能**********/void key_6() &#123; delay(200); //⻓长按延时 if (KeyScan() == 0xdd) &#123; while (KeyScan() != 0xdd || motor_contrl_2++ &lt; 5) &#123; 1motor_contrl_2++; //⻓长按辅助变量量 if (motor_contrl_2 % 6 == 0) //实现⾃自动转6次后反转 &#123; a = ~a; &#125; Motor(1, a); &#125; motor_contrl_2 = 0; &#125; if (motor_contrl_1 % 6 == 0) //独⽴立按6次后反转⽅方向 &#123; a = ~a; &#125; motor_contrl_1++; Motor(1, a);&#125;/**********倒计时函数**********/void bell() &#123; switch (bell_num) &#123; case 1: //按键7第⼀一次 &#123; ET1 = 1; TR1 = 1; set_cursor_pos(0, 1); LcdWriteData(hour / 10 + 0x30); LcdWriteData(hour % 10 + 0x30); LcdWriteData(':'); LcdWriteData(min / 10 + 0x30); LcdWriteData(min % 10 + 0x30); &#125; break; case 2: //按键7第⼆二次 &#123; ET1 = 0; TR1 = 0; set_cursor_pos(0, 1); LcdWriteData(hour / 10 + 0x30); LcdWriteData(hour % 10 + 0x30); //写⼊入⼩小时部分 LcdWriteData(':'); if (bell_min == 0) &#123; set_cursor_pos(3, 1); LcdWriteData(min / 10 + 0x30); //写⼊入分钟部分 LcdWriteData(min % 10 + 0x30); &#125; else &#123; set_cursor_pos(3, 1); LcdWriteData(' '); //对⼩小时部分⽤用空格进⾏行行清屏 摆⻛风部分LcdWriteData(' '); &#125; &#125;break; case 3: //按键7第三次 &#123; set_cursor_pos(2, 1); LcdWriteData(':'); LcdWriteData(min / 10 + 0x30); LcdWriteData(min % 10 + 0x30); if (bell_hour == 0) &#123; set_cursor_pos(0, 1); LcdWriteData(hour / 10 + 0x30); LcdWriteData(hour % 10 + 0x30); &#125; else &#123; set_cursor_pos(0, 1); LcdWriteData(' '); LcdWriteData(' '); &#125; &#125; break; &#125; if (bell_num == 4) bell_num = 1; //第四次直接回到第⼀一次，利利⽤用第⼀一次功能实现开始倒计时&#125;/**********按键8实现函数**********/void key_8() &#123; if (bell_num == 2) //bell_num为2说明在调整分钟 &#123; min--; if (min == 0) min = 59; &#125; if (bell_num == 3) &#123; hour++; if (hour == 12) hour = 0; &#125;&#125;/**********主函数**********/void main()&#123; time_initialize(); //计时器器初始化 LcdWriteCmd(0x01); LcdWriteCmd(0x08); LcdWriteCmd(0x38); //1602初始化 LcdWriteCmd(0x06); while (1) &#123; PWM(100, 30 * speed_num); //点亮⻛风速⼩小灯，并按照⻛风速调节亮度 switch (KeyScan()) &#123; case 0xee:key_1(); break; case 0xde:temperature++; break; case 0xbe:temperature--; break; case 0x7e: m++; break; case 0xed:speed_num++; break; case 0xdd: key_6(); break; case 0xbd: bell_num++; break; case 0x7d:key_8(); break; &#125; Temp(); //显示温度 Mode(); //显示模式 Speed(); //显示⻛风速 bell(); //显示倒计时 &#125;&#125;/**********中断函数1，⽤用来实现pwm和调节倒计时时间的闪烁功能**********/void timer_0() interrupt 1 &#123; static uchar count0 = 0; if (speed_led == 1) &#123; TH0 = (65536 - low) / 256; TL0 = (65536 - low) % 256; speed_led = 0; &#125; else &#123; TH0 = (65536 - high) / 256; TL0 = (65536 - high) % 256; speed_led = 1; &#125; count0++; if (count0 == 70) //70⽤用来控制闪烁频率 &#123; count0 = 0; bell_hour = ~bell_hour; bell_min = ~bell_min; &#125;&#125;/**********中断函数2**********/void timer_1() interrupt 3 &#123; static uchar count1 = 0; TH1 = (65536 - 50000) / 256; TL1 = (65536 - 50000) % 256; //设置初值 count1++; if (count1 == 2) //每2次50ms， min变化⼀一次 &#123; count1 = 0; min--; if (min == 0) &#123; //倒计时结束 if (hour == 0) &#123; ET1 = 0; TR1 = 0; //关闭计时 all_initialize(); //把所有变量量初始化 LcdWriteCmd(0x01); //清屏 LcdWriteCmd(0x08); //关显示 &#125; hour--; min = 59; &#125; &#125;&#125;","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://tetedetian.github.io/tags/c/"}]},{"title":"机房预约系统模拟展示","slug":"机房预约模拟系统展示","date":"2021-01-16T08:35:03.697Z","updated":"2021-01-22T15:16:17.875Z","comments":true,"path":"2021/01/16/机房预约模拟系统展示/","link":"","permalink":"https://tetedetian.github.io/2021/01/16/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%B1%95%E7%A4%BA/","excerpt":"此博客展示了一个基于C++控制台的机房预约模拟系统的代码以及运行结果","text":"此博客展示了一个基于C++控制台的机房预约模拟系统的代码以及运行结果 一、头文件1.computer.h 12345678910111213141516/**********不止一个机房，所以这个头文件是声明一个机房类，可供定义机房对象时使用**********/#pragma once #include &lt;iostream&gt;using namespace std;//机房类class ComputerRoom&#123;public: int m_ComId; //机房Id号 int m_MaxNum; //机房最大容量&#125;; 2.globalFile.h 123456789101112131415/**********对存储数据的文本文件进行宏定义，方便其他文件调用**********/#pragma once//管理员信息文件#define ADMIN_FILE \"admin.txt\"//学生信息文件#define STUDENT_FILE \"student.txt\"//教师信息文件#define TEACHER_FILE \"teacher.txt\"//机房信息文件（机器数量，机房号等）#define COMPUTER_FILE \"computerRoom.txt\"//预约信息文件#define ORDER_FILE \"order.txt\" 3.Identity.h 12345678910111213141516171819202122/**********这个头文件定义了一个身份父类，声明了一些身份认证必须的成员变量和方法，可供管理员、教师、学生类继承。**********/#pragma once //防止头文件重复包含#include &lt;iostream&gt;using namespace std;//身份抽象父类（基类）class Identity&#123;public: //操作菜单，用到了纯虚函数。（virtual是虚函数标志，“=0”则表示是纯虚函数） //如果父类中有纯虚函数，子类继承父类，就必须实现纯虚函数 virtual void operMenu() = 0; //用户名 string m_Name; //密码 string m_Pwd;&#125;; 4.manager.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**********声明管理员类**********/#pragma once#include &lt;iostream&gt;using namespace std;#include \"Identity.h\"//管理员也要身份认证，肯定得用到身份类#include &lt;string&gt;#include &lt;fstream&gt;//写入txt文件需要用到的一个头文件#include \"globalFile.h\"#include &lt;vector&gt;//vertor容器头文件#include \"student.h\"#include \"teacher.h\"#include &lt;algorithm&gt;//&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等#include \"computerRoom.h\"//管理员类设计class Manager :public Identity&#123;public: //默认构造 Manager(); //有参构造 Manager(string name ,string pwd); //菜单界面 virtual void operMenu(); //添加账号 void addPerson(); //查看账号 void showPerson(); //查看机房信息 void showComputer(); //清空预约记录 void cleanFile(); //初始化容器 void initVector(); //检测重复 参数1:检测学号/职工号 参数2:检测类型 bool checkRepeat(int id , int type); //学生容器 vector&lt;Student&gt;vStu; //教师容器 vector&lt;Teacher&gt;vTea; //机房信息容器 vector&lt;ComputerRoom&gt;vCom;&#125;; 5.orderFile.h 12345678910111213141516171819202122232425262728293031/**********声明预约类**********/#pragma once#include &lt;iostream&gt;#include \"globalFile.h\"#include &lt;fstream&gt;//对txt文件读写需要用到#include &lt;map&gt;//map容器头文件#include &lt;string&gt;using namespace std;class OrderFile&#123;public: //构造函数 OrderFile(); //更新预约记录 void updateOrder(); //记录预约条数 int m_Size; //记录所有预约信息的容器(map容器) key记录条数 value 具体记录键值对信息 map&lt;int, map&lt;string, string&gt;&gt; m_orderData;&#125;; 6.student.h 123456789101112131415161718192021222324252627282930313233343536373839404142#pragma once#include &lt;iostream&gt;using namespace std;#include \"Identity.h\"#include &lt;string&gt;#include &lt;vector&gt;#include \"computerRoom.h\"#include &lt;fstream&gt;#include \"globalFile.h\"#include \"orderFile.h\"//学生类class Student : public Identity&#123;public: //默认构造 Student(); //有参构造 参数：学号、姓名、密码 Student(int id,string name,string pwd); //菜单界面 virtual void operMenu(); //申请预约 void applyOrder(); //查看自身预约 void showMyOrder(); //查看所有预约 void showAllOrder(); //取消预约 void cancelOrder(); //学生学号 int m_Id; //机房容器 vector&lt;ComputerRoom&gt; vCom;&#125;; 7.teacher.h 123456789101112131415161718192021222324252627282930#pragma once#include &lt;iostream&gt;using namespace std;#include \"Identity.h\"#include &lt;string&gt;#include \"orderFile.h\"#include &lt;vector&gt;//教师类设计class Teacher :public Identity&#123;public: //默认构造 Teacher(); //有参构造 Teacher(int empId, string name, string pwd); //菜单界面 virtual void operMenu(); //查看所有预约 void showAllOrder(); //审核预约 void validOrder(); //职工号 int m_EmpId;&#125;; 二、源文件1.manager.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include \"manager.h\"//默认构造Manager::Manager()&#123;&#125;//有参构造Manager::Manager(string name, string pwd)&#123; //初始化管理员信息 this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; //初始化容器 获取到所有文件中 学生、老师信息 this-&gt;initVector(); //初始化机房信息 ifstream ifs; ifs.open(COMPUTER_FILE, ios::in); ComputerRoom com; while (ifs &gt;&gt; com.m_ComId &amp;&amp; ifs &gt;&gt; com.m_MaxNum) &#123; vCom.push_back(com); &#125; ifs.close(); //cout &lt;&lt; \"机房的数量为：\" &lt;&lt; vCom.size() &lt;&lt; endl;&#125;//菜单界面void Manager::operMenu()&#123; cout &lt;&lt; \"欢迎管理员：\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"登录！\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t ---------------------------------\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 1.添加账号 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 2.查看账号 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 3.查看机房 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 4.清空预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 0.注销登录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t ---------------------------------\\n\"; cout &lt;&lt; \"请选择您的操作： \" &lt;&lt; endl;&#125;//添加账号void Manager::addPerson()&#123; cout &lt;&lt; \"请输入添加账号类型\" &lt;&lt; endl; cout &lt;&lt; \"1、添加学生\" &lt;&lt; endl; cout &lt;&lt; \"2、添加老师\" &lt;&lt; endl; string fileName; //操作文件名 string tip; //提示id号 string errorTip; //重复错误提示 ofstream ofs;//文件操作对象 int select = 0; cin &gt;&gt; select; //接受用户的选项 if (select == 1) &#123; //添加的是学生 fileName = STUDENT_FILE; tip = \"请输入学号：\"; errorTip = \"学号重复，请重新输入\"; &#125; else &#123; fileName = TEACHER_FILE; tip = \"请输入职工编号：\"; errorTip = \"职工号重复，请重新输入\"; &#125; //利用追加的方式 写文件 ofs.open(fileName, ios::out | ios::app); int id; //学号 /职工号 string name; //姓名 string pwd; //密码 cout &lt;&lt; tip &lt;&lt; endl; while (true) &#123; cin &gt;&gt; id; bool ret = checkRepeat(id, select); if (ret) //有重复 &#123; cout &lt;&lt; errorTip &lt;&lt; endl; &#125; else &#123; break; &#125; &#125; cout &lt;&lt; \"请输入姓名： \" &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; \"请输入密码： \" &lt;&lt; endl; cin &gt;&gt; pwd; //向文件中添加数据 ofs &lt;&lt; id &lt;&lt; \" \" &lt;&lt; name &lt;&lt; \" \" &lt;&lt; pwd &lt;&lt; \" \" &lt;&lt; endl; cout &lt;&lt; \"添加成功\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); ofs.close(); //调用初始化容器接口，从新获取文件中的数据 this-&gt;initVector();&#125;void printStudent(Student &amp; s)&#123; cout &lt;&lt; \"学号： \" &lt;&lt; s.m_Id &lt;&lt; \" 姓名： \" &lt;&lt; s.m_Name &lt;&lt; \" 密码：\" &lt;&lt; s.m_Pwd &lt;&lt; endl;&#125;void printTeacher(Teacher &amp; s)&#123; cout &lt;&lt; \"职工号： \" &lt;&lt; s.m_EmpId &lt;&lt; \" 姓名： \" &lt;&lt; s.m_Name &lt;&lt; \" 密码：\" &lt;&lt; s.m_Pwd &lt;&lt; endl;&#125;//查看账号void Manager::showPerson()&#123; cout &lt;&lt; \"请选择查看内容：\" &lt;&lt; endl; cout &lt;&lt; \"1、查看所有学生\" &lt;&lt; endl; cout &lt;&lt; \"2、查看所有老师\" &lt;&lt; endl; int select = 0; //接受用户选择 cin &gt;&gt; select; if (select == 1) &#123; //查看学生 cout &lt;&lt; \"所有学生信息如下：\" &lt;&lt; endl; for_each(vStu.begin(), vStu.end(), printStudent); &#125; else &#123; //查看老师 cout &lt;&lt; \"所有老师信息如下：\" &lt;&lt; endl; for_each(vTea.begin(), vTea.end(), printTeacher); &#125; system(\"pause\"); system(\"cls\");&#125;//查看机房信息void Manager::showComputer()&#123; cout &lt;&lt; \"机房信息如下：\" &lt;&lt; endl; for (vector&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end();it++) &#123; cout &lt;&lt; \"机房编号： \" &lt;&lt; it-&gt;m_ComId &lt;&lt; \" 机房最大容量： \" &lt;&lt; it-&gt;m_MaxNum &lt;&lt; endl; &#125; system(\"pause\"); system(\"cls\");&#125;//清空预约记录void Manager::cleanFile()&#123; ofstream ofs(ORDER_FILE, ios::trunc); ofs.close(); cout &lt;&lt; \"清空成功！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\");&#125;//初始化容器void Manager::initVector()&#123; //确保容器清空状态 vStu.clear(); vTea.clear(); //读取信息 学生 ifstream ifs; ifs.open(STUDENT_FILE, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; \"文件读取失败\" &lt;&lt; endl; return; &#125; Student s; while (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp; ifs &gt;&gt; s.m_Pwd) &#123; vStu.push_back(s); &#125;// cout &lt;&lt; \"当前学生数量为： \" &lt;&lt; vStu.size() &lt;&lt; endl; ifs.close(); //读取信息 老师 ifs.open(TEACHER_FILE, ios::in); Teacher t; while (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp; ifs &gt;&gt;t.m_Pwd) &#123; vTea.push_back(t); &#125;// cout &lt;&lt; \"当前老师数量为： \" &lt;&lt; vTea.size() &lt;&lt; endl; ifs.close();&#125;//检测重复 参数1 检测学号/职工号 参数2 检测类型bool Manager::checkRepeat(int id, int type)&#123; if (type == 1) &#123; //检测学生 for (vector&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++) &#123; if (id == it-&gt;m_Id) &#123; return true; &#125; &#125; &#125; else &#123; //检测老师 for (vector&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++) &#123; if (id == it-&gt;m_EmpId) &#123; return true; &#125; &#125; &#125; return false;&#125; 2.orderFile.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include \"orderFile.h\"//构造函数OrderFile::OrderFile()&#123; ifstream ifs; ifs.open(ORDER_FILE, ios::in); string date; // 日期 string interval;//时间段 string stuId; //学生编号 string stuName; //学生姓名 string roomId; //机房编号 string status; //预约状态 this-&gt;m_Size = 0; //记录条数 while (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp; ifs &gt;&gt; status) &#123; //cout &lt;&lt; date &lt;&lt; endl; //cout &lt;&lt; interval &lt;&lt; endl; //cout &lt;&lt; stuId &lt;&lt; endl; //cout &lt;&lt; stuName &lt;&lt; endl; //cout &lt;&lt; roomId &lt;&lt; endl; //cout &lt;&lt; status &lt;&lt; endl; //cout &lt;&lt; endl; //date:11111 string key; string value; map&lt;string, string&gt;m; int pos = date.find(\":\"); // 4 if (pos != -1) &#123; key = date.substr(0, pos); value = date.substr(pos + 1, date.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //cout &lt;&lt; \"key = \" &lt;&lt; key &lt;&lt; endl; //cout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl; //截取时间段 pos = interval.find(\":\"); // 4 if (pos != -1) &#123; key = interval.substr(0, pos); value = interval.substr(pos + 1, interval.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //截取学号 pos = stuId.find(\":\"); // 4 if (pos != -1) &#123; key = stuId.substr(0, pos); value = stuId.substr(pos + 1, stuId.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //截取姓名 pos = stuName.find(\":\"); // 4 if (pos != -1) &#123; key = stuName.substr(0, pos); value = stuName.substr(pos + 1, stuName.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //截取机房号 pos = roomId.find(\":\"); // 4 if (pos != -1) &#123; key = roomId.substr(0, pos); value = roomId.substr(pos + 1, roomId.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //截取预约状态 pos = status.find(\":\"); // 4 if (pos != -1) &#123; key = status.substr(0, pos); value = status.substr(pos + 1, status.size() - pos - 1); // size = 10 pos = 4 size - pos - 1 = 6 - 1 m.insert(make_pair(key, value)); &#125; //将小map容器放入到大的map容器中 this-&gt;m_orderData.insert(make_pair(this-&gt;m_Size, m)); this-&gt;m_Size++; &#125; ifs.close(); //测试最大map容器 //for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end(); it++) //&#123; // cout &lt;&lt; \"条数为： \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; endl; // for (map&lt;string, string&gt;::iterator mit = (*it).second.begin(); mit != it-&gt;second.end(); mit++) // &#123; // cout &lt;&lt; \" key = \" &lt;&lt; mit-&gt;first &lt;&lt; \" value = \" &lt;&lt; mit-&gt;second &lt;&lt; \" \"; // &#125; // cout &lt;&lt; endl; //&#125;&#125;//更新预约记录void OrderFile::updateOrder()&#123; if (this-&gt;m_Size == 0) &#123; return; //预约记录0条，直接return &#125; ofstream ofs(ORDER_FILE, ios::out | ios::trunc); for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; ofs &lt;&lt; \"date:\" &lt;&lt; this-&gt;m_orderData[i][\"date\"] &lt;&lt; \" \"; ofs &lt;&lt; \"interval:\" &lt;&lt; this-&gt;m_orderData[i][\"interval\"] &lt;&lt; \" \"; ofs &lt;&lt; \"stuId:\" &lt;&lt; this-&gt;m_orderData[i][\"stuId\"] &lt;&lt; \" \"; ofs &lt;&lt; \"stuName:\" &lt;&lt; this-&gt;m_orderData[i][\"stuName\"] &lt;&lt; \" \"; ofs &lt;&lt; \"roomId:\" &lt;&lt; this-&gt;m_orderData[i][\"roomId\"] &lt;&lt; \" \"; ofs &lt;&lt; \"status:\" &lt;&lt; this-&gt;m_orderData[i][\"status\"] &lt;&lt; endl; &#125; ofs.close();&#125; 3.student.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include \"student.h\"//默认构造Student::Student()&#123;&#125;//有参构造 参数：学号、姓名、密码Student::Student(int id, string name, string pwd)&#123; //初始化属性 this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; //初始化机房信息 ifstream ifs; ifs.open(COMPUTER_FILE, ios::in); ComputerRoom com; while ( ifs &gt;&gt; com.m_ComId &amp;&amp; ifs &gt;&gt; com.m_MaxNum) &#123; //将读取的信息放入到 容器中 vCom.push_back(com); &#125; ifs.close();&#125;//菜单界面void Student::operMenu()&#123; cout &lt;&lt; \"欢迎学生代表：\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"登录！\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t ----------------------------------\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 1.申请预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 2.查看我的预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 3.查看所有预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 4.取消预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 0.注销登录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t ----------------------------------\\n\"; cout &lt;&lt; \"请选择您的操作： \" &lt;&lt; endl;&#125;//申请预约void Student::applyOrder()&#123; cout &lt;&lt; \"机房开放时间为周一至周五!\" &lt;&lt; endl; cout &lt;&lt; \"请输入申请预约的时间：\" &lt;&lt; endl; cout &lt;&lt; \"1、周一\" &lt;&lt; endl; cout &lt;&lt; \"2、周二\" &lt;&lt; endl; cout &lt;&lt; \"3、周三\" &lt;&lt; endl; cout &lt;&lt; \"4、周四\" &lt;&lt; endl; cout &lt;&lt; \"5、周五\" &lt;&lt; endl; int date = 0; //日期 int interval = 0; //时间段 int room = 0; //机房编号 while (true) &#123; cin &gt;&gt; date; if (date &gt;= 1 &amp;&amp; date &lt;= 5) &#123; break; &#125; cout &lt;&lt; \"输入有误，请重新输入\" &lt;&lt; endl; &#125; cout &lt;&lt; \"请输入申请预约时间段：\" &lt;&lt; endl; cout &lt;&lt; \"1、上午\" &lt;&lt; endl; cout &lt;&lt; \"2、下午\" &lt;&lt; endl; while (true) &#123; cin &gt;&gt; interval; if (interval &gt;= 1 &amp;&amp; interval &lt;= 2) &#123; break; &#125; cout &lt;&lt; \"输入有误，请重新输入\" &lt;&lt; endl; &#125; cout &lt;&lt; \"请选择机房：\" &lt;&lt; endl; for (int i = 0; i &lt; vCom.size(); i++) &#123; cout &lt;&lt; vCom[i].m_ComId &lt;&lt; \"号机房容量为： \" &lt;&lt; vCom[i].m_MaxNum &lt;&lt; endl; &#125; while (true) &#123; cin &gt;&gt; room; if (room &gt;= 1 &amp;&amp; room &lt;= 3) &#123; break; &#125; cout &lt;&lt; \"输入有误，请重新输入\" &lt;&lt; endl; &#125; cout &lt;&lt; \"预约成功！审核中\" &lt;&lt; endl; ofstream ofs; ofs.open(ORDER_FILE, ios::app); ofs &lt;&lt; \"date:\" &lt;&lt; date &lt;&lt; \" \"; ofs &lt;&lt; \"interval:\" &lt;&lt; interval &lt;&lt; \" \"; ofs &lt;&lt; \"stuId:\" &lt;&lt; this-&gt;m_Id &lt;&lt; \" \"; ofs &lt;&lt; \"stuName:\" &lt;&lt; this-&gt;m_Name &lt;&lt; \" \"; ofs &lt;&lt; \"roomId:\" &lt;&lt; room &lt;&lt; \" \"; ofs &lt;&lt; \"status:\" &lt;&lt; 1 &lt;&lt; endl; ofs.close(); system(\"pause\"); system(\"cls\");&#125;//查看自身预约void Student::showMyOrder()&#123; OrderFile of; if (of.m_Size == 0) &#123; cout &lt;&lt; \"无预约记录！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; for (int i = 0; i &lt; of.m_Size; i++) &#123; // string 转 int // string 利用 .c_str() 转 const char * //利用 atoi ( const char *) 转 int if (this-&gt;m_Id == atoi(of.m_orderData[i][\"stuId\"].c_str())) //找到自身预约 &#123; cout &lt;&lt; \"预约日期： 周\" &lt;&lt; of.m_orderData[i][\"date\"]; cout &lt;&lt; \" 时间段： \" &lt;&lt; (of.m_orderData[i][\"interval\"] == \"1\" ? \"上午\" : \"下午\"); cout &lt;&lt; \" 机房号： \" &lt;&lt; of.m_orderData[i][\"roomId\"]; string status = \"状态： \"; // 1 审核中 2 已预约 -1 预约失败 0 取消预约 if (of.m_orderData[i][\"status\"] == \"1\") &#123; status += \"审核中\"; &#125; else if (of.m_orderData[i][\"status\"] == \"2\") &#123; status += \"预约成功\"; &#125; else if (of.m_orderData[i][\"status\"] == \"-1\") &#123; status += \"预约失败，审核未通过\"; &#125; else &#123; status += \"预约已取消\"; &#125; cout &lt;&lt; status &lt;&lt; endl; &#125; &#125; system(\"pause\"); system(\"cls\");&#125;//查看所有预约void Student::showAllOrder()&#123; OrderFile of; if (of.m_Size == 0) &#123; cout &lt;&lt; \"无预约记录\" &lt;&lt; endl; system(\"pasue\"); system(\"cls\"); return; &#125; for (int i = 0; i &lt; of.m_Size; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; \"、 \"; cout &lt;&lt; \"预约日期： 周\" &lt;&lt; of.m_orderData[i][\"date\"]; cout &lt;&lt; \" 时间段： \" &lt;&lt; (of.m_orderData[i][\"interval\"] == \"1\" ? \"上午\" : \"下午\"); cout &lt;&lt; \" 学号： \" &lt;&lt; of.m_orderData[i][\"stuId\"]; cout &lt;&lt; \" 姓名： \" &lt;&lt; of.m_orderData[i][\"stuName\"]; cout &lt;&lt; \" 机房编号： \" &lt;&lt; of.m_orderData[i][\"roomId\"]; string status = \" 状态：\"; // 1 审核中 2 已预约 -1预约失败 0 取消预约 if (of.m_orderData[i][\"status\"] == \"1\") &#123; status += \"审核中\"; &#125; else if (of.m_orderData[i][\"status\"] == \"2\") &#123; status += \"预约成功\"; &#125; else if (of.m_orderData[i][\"status\"] == \"-1\") &#123; status += \"预约失败，审核未通过\"; &#125; else &#123; status += \"预约已取消\"; &#125; cout &lt;&lt; status &lt;&lt; endl; &#125; system(\"pause\"); system(\"cls\");&#125;//取消预约void Student::cancelOrder()&#123; OrderFile of; if (of.m_Size == 0) &#123; cout &lt;&lt; \"无预约记录\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; cout &lt;&lt; \"审核中或预约成功的记录可以取消，请输入取消的记录\" &lt;&lt; endl; vector&lt;int&gt;v; //存放在最大容器中的下标编号 int index = 1; for (int i = 0; i &lt; of.m_Size; i++) &#123; //先判断是自身学号 if (this-&gt;m_Id == atoi(of.m_orderData[i][\"stuId\"].c_str())) &#123; //再筛选状态 审核中或预约成功 if (of.m_orderData[i][\"status\"] == \"1\" || of.m_orderData[i][\"status\"] == \"2\") &#123; v.push_back(i); cout &lt;&lt; index++ &lt;&lt; \"、 \"; cout &lt;&lt; \"预约日期： 周\" &lt;&lt; of.m_orderData[i][\"date\"]; cout &lt;&lt; \" 时间段： \" &lt;&lt; (of.m_orderData[i][\"interval\"] == \"1\" ? \"上午\" : \"下午\"); cout &lt;&lt; \" 机房编号： \" &lt;&lt; of.m_orderData[i][\"roomId\"]; string status = \" 状态： \"; if (of.m_orderData[i][\"status\"] == \"1\") &#123; status += \"审核中\"; &#125; else if (of.m_orderData[i][\"status\"] == \"2\") &#123; status += \"预约成功\"; &#125; cout &lt;&lt; status &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; \"请输入取消的记录，0代表返回\" &lt;&lt; endl; int select = 0; while (true) &#123; cin &gt;&gt; select; if (select &gt;= 0 &amp;&amp; select &lt;= v.size()) &#123; if (select == 0) &#123; break; &#125; else &#123; of.m_orderData[v[select - 1]][\"status\"] = \"0\"; of.updateOrder(); cout &lt;&lt; \"已取消预约\" &lt;&lt; endl; break; &#125; &#125; cout &lt;&lt; \"输入有误，请重新输入\" &lt;&lt; endl; &#125; system(\"pause\"); system(\"cls\");&#125; 4.teacher.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include \"teacher.h\"//默认构造Teacher::Teacher()&#123;&#125;//有参构造Teacher::Teacher(int empId, string name, string pwd)&#123; //初始化属性 this-&gt;m_EmpId = empId; this-&gt;m_Name = name; this-&gt;m_Pwd = pwd;&#125;//菜单界面void Teacher::operMenu()&#123; cout &lt;&lt; \"欢迎教师：\" &lt;&lt; this-&gt;m_Name &lt;&lt; \"登录！\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t ----------------------------------\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 1.查看所有预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 2.审核预约 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 0.注销登录 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t ----------------------------------\\n\"; cout &lt;&lt; \"请选择您的操作： \" &lt;&lt; endl;&#125;//查看所有预约void Teacher::showAllOrder()&#123; OrderFile of; if (of.m_Size == 0) &#123; cout &lt;&lt; \"无预约记录\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; for (int i = 0; i &lt; of.m_Size; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; \"、 \"; cout &lt;&lt; \"预约日期： 周\" &lt;&lt; of.m_orderData[i][\"date\"]; cout &lt;&lt; \" 时间段： \" &lt;&lt; (of.m_orderData[i][\"interval\"] == \"1\" ? \"上午\" : \"下午\"); cout &lt;&lt; \" 学号： \" &lt;&lt; of.m_orderData[i][\"stuId\"]; cout &lt;&lt; \" 姓名： \" &lt;&lt; of.m_orderData[i][\"stuName\"]; cout &lt;&lt; \" 机房编号： \" &lt;&lt; of.m_orderData[i][\"roomId\"]; string status = \" 状态： \"; //1 审核中 2 已预约 -1 预约失败 0 取消预约 if (of.m_orderData[i][\"status\"] == \"1\") &#123; status += \"审核中\"; &#125; else if (of.m_orderData[i][\"status\"] == \"2\") &#123; status += \"预约成功\"; &#125; else if (of.m_orderData[i][\"status\"] == \"-1\") &#123; status += \"预约失败，审核未通过\"; &#125; else &#123; status += \"预约已取消\"; &#125; cout &lt;&lt; status &lt;&lt; endl; &#125; system(\"pause\"); system(\"cls\");&#125;//审核预约void Teacher::validOrder()&#123; OrderFile of; if (of.m_Size == 0) &#123; cout &lt;&lt; \"无预约记录\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; vector&lt;int&gt;v; int index = 0; cout &lt;&lt; \"待审核的预约记录如下：\" &lt;&lt; endl; for (int i = 0; i &lt; of.m_Size; i++) &#123; if (of.m_orderData[i][\"status\"] == \"1\") &#123; v.push_back(i); cout &lt;&lt; ++index &lt;&lt; \"、 \"; cout &lt;&lt; \"预约日期： 周\" &lt;&lt; of.m_orderData[i][\"date\"]; cout &lt;&lt; \" 时间段： \" &lt;&lt; (of.m_orderData[i][\"interval\"] == \"1\" ? \"上午\" : \"下午\"); cout &lt;&lt; \" 学生编号： \" &lt;&lt; of.m_orderData[i][\"stuId\"]; cout &lt;&lt; \" 学生姓名： \" &lt;&lt; of.m_orderData[i][\"stuName\"]; cout &lt;&lt; \" 机房编号： \" &lt;&lt; of.m_orderData[i][\"roomId\"]; string status = \" 状态：审核中 \"; cout &lt;&lt; status &lt;&lt; endl; &#125; &#125; cout &lt;&lt; \"请输入审核的预约记录，0代表返回\" &lt;&lt; endl; int select = 0; //接受用户选择的预约记录 int ret = 0; //接受预约结果记录 while (true) &#123; cin &gt;&gt; select; if (select &gt;= 0 &amp;&amp; select &lt;= v.size()) &#123; if (select == 0) &#123; break; &#125; else &#123; cout &lt;&lt; \"请输入审核结果\" &lt;&lt; endl; cout &lt;&lt; \"1、通过\" &lt;&lt; endl; cout &lt;&lt; \"2、不通过\" &lt;&lt; endl; cin &gt;&gt; ret; if (ret == 1) &#123; //通过情况 of.m_orderData[v[select - 1]][\"status\"] = \"2\"; &#125; else &#123; //不通过情况 of.m_orderData[v[select - 1]][\"status\"] = \"-1\"; &#125; of.updateOrder(); // 更新预约记录 cout &lt;&lt; \"审核完毕\" &lt;&lt; endl; break; &#125; &#125; cout &lt;&lt; \"输入有误，请重新输入！\" &lt;&lt; endl; &#125; system(\"pause\"); system(\"cls\");&#125; 5.机房预约系统.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304#include &lt;iostream&gt;using namespace std;#include \"Identity.h\"#include &lt;fstream&gt;#include &lt;string&gt;#include \"globalFile.h\"#include \"student.h\"#include \"teacher.h\"#include \"manager.h\"//进入学生子菜单界面void studentMenu(Identity* &amp;student)&#123; while (true) &#123; //调用学生子菜单 student-&gt;operMenu(); Student * stu = (Student *)student; int select = 0; cin &gt;&gt; select; //接受用户选择 if (select == 1) //申请预约 &#123; stu-&gt;applyOrder(); &#125; else if (select == 2) //查看自身预约 &#123; stu-&gt;showMyOrder(); &#125; else if (select == 3) //查看所有人预约 &#123; stu-&gt;showAllOrder(); &#125; else if (select == 4) //取消预约 &#123; stu-&gt;cancelOrder(); &#125; else &#123; //注销登录 delete student; cout &lt;&lt; \"注销成功\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; &#125;&#125;//进入教师子菜单界面void teacherMenu(Identity * &amp;teacher)&#123; while (true) &#123; //调用子菜单界面 teacher-&gt;operMenu(); Teacher * tea = (Teacher*)teacher; int select = 0; //接受用户选择 cin &gt;&gt; select; if (select == 1) //查看所有预约 &#123; tea-&gt;showAllOrder(); &#125; else if (select == 2) //审核预约 &#123; tea-&gt;validOrder(); &#125; else &#123; delete teacher; cout &lt;&lt; \"注销成功\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; &#125;&#125;//进入管理员子菜单界面void managerMenu(Identity * &amp;manager)&#123; while (true) &#123; //调用管理员子菜单 manager-&gt;operMenu(); //将父类指针 转为子类指针，调用子类里其他接口 Manager * man = (Manager*)manager; int select = 0; //接受用户选项 cin &gt;&gt; select; if (select == 1) //添加账号 &#123; //cout &lt;&lt; \"添加账号\" &lt;&lt; endl; man-&gt;addPerson(); &#125; else if (select == 2) //查看账号 &#123; //cout &lt;&lt; \"查看账号\" &lt;&lt; endl; man-&gt;showPerson(); &#125; else if (select == 3) //查看机房 &#123; //cout &lt;&lt; \"查看机房\" &lt;&lt; endl; man-&gt;showComputer(); &#125; else if (select == 4) //清空预约 &#123; //cout &lt;&lt; \"清空预约\" &lt;&lt; endl; man-&gt;cleanFile(); &#125; else &#123; //注销 delete manager; //销毁掉堆区对象 cout &lt;&lt; \"注销成功\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return; &#125; &#125;&#125;//登录功能 参数1：操作文件名 参数2：操作身份类型void LoginIn(string fileName, int type)&#123; //父类指针 ，用于指向子类对象 Identity * person = NULL; //读文件 ifstream ifs; ifs.open(fileName, ios::in);//打开文件名为filename的文件用于其他变量的输入（也就是从文件中读取数据到其他变量） //判断文件是否存在 if (!ifs.is_open())//is_open就是用来判断文件是否成功打开，打开了返回1 &#123; cout &lt;&lt; \"文件不存在\" &lt;&lt; endl; ifs.close(); return; &#125; //准备接受用户的信息 int id = 0; string name; string pwd; //判断身份 if (type == 1) //学生身份 &#123; cout &lt;&lt; \"请输入你的学号：\" &lt;&lt; endl; cin &gt;&gt; id; &#125; else if (type == 2) &#123; cout &lt;&lt; \"请输入您的职工号： \" &lt;&lt; endl; cin &gt;&gt; id; &#125; cout &lt;&lt; \"请输入用户名：\" &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; \"请输入密码：\" &lt;&lt; endl; cin &gt;&gt; pwd; if (type == 1) &#123; //学生身份验证 int fId; //从文件中读取的id号 string fName; //从文件中获取的姓名 string fPwd; //从文件中获取密码 while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd )//（ifs.open(fileName, ios::in);），文本文件“filename”作为输入源 &#123; //与用户输入的信息做对比 if (fId == id &amp;&amp; fName == name &amp;&amp; fPwd == pwd) &#123; cout &lt;&lt; \"学生验证登录成功！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); person = new Student(id, name, pwd);// //进入学生身份的子菜单 studentMenu(person); return; &#125; &#125; &#125; else if (type == 2) &#123; //教师身份验证 int fId; //从文件中获取的id号 string fName; //从文件中获取的姓名 string fPwd; //从文件中获取的密码 while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd) &#123; if (fId == id &amp;&amp; fName == name &amp;&amp; fPwd == pwd) &#123; cout &lt;&lt; \"教师验证登录成功！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); person = new Teacher(id, name, pwd); //进入教师子菜单 teacherMenu(person); return; &#125; &#125; &#125; else if (type == 3) &#123; //管理员身份验证 string fName; //从文件中获取姓名 string fPwd; //从文件中获取密码 while (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd) &#123; if (name == fName &amp;&amp; pwd == fPwd) &#123; cout &lt;&lt; \"管理员验证登录成功!\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); person = new Manager(name, pwd); //进入管理员子菜单界面 managerMenu(person); return; &#125; &#125; &#125; cout &lt;&lt; \"验证登录失败！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); return;&#125;int main()&#123; int select = 0; //用于接受用户的选择 while (true) &#123; cout &lt;&lt; \"====================== 欢迎来到电子与信息工程学院机房预约系统 =====================\" &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; \"请输入您的身份\" &lt;&lt; endl; cout &lt;&lt; \"\\t\\t -------------------------------\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 1.学生代表 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 2.老 师 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 3.管 理 员 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t| 0.退 出 |\\n\"; cout &lt;&lt; \"\\t\\t| |\\n\"; cout &lt;&lt; \"\\t\\t -------------------------------\\n\"; cout &lt;&lt; \"输入您的选择: \"; cin &gt;&gt; select; //接受用户选择 switch (select) //根据用户选择 实现不同接口 &#123; case 1: //学生身份 LoginIn(STUDENT_FILE, 1); break; case 2: //老师身份 LoginIn(TEACHER_FILE, 2); break; case 3: //管理员身份 LoginIn(ADMIN_FILE, 3); break; case 0 : //退出系统 cout &lt;&lt; \"欢迎下一次使用！\" &lt;&lt; endl; system(\"pause\"); return 0; break; default: cout &lt;&lt; \"输入有误，请重新选择！\" &lt;&lt; endl; system(\"pause\"); system(\"cls\"); break; &#125; &#125; system(\"pause\"); return 0;&#125; 三、运行截图管理员登入 查看学生账号 添加学生账号 重新查看账号 登录学生账号 申请预约 登录教师账号 教师审核","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://tetedetian.github.io/tags/c/"}]},{"title":"如何将本地项目上传到github","slug":"如何将本地项目上传到github","date":"2020-10-23T06:37:16.127Z","updated":"2020-10-23T06:44:43.269Z","comments":true,"path":"2020/10/23/如何将本地项目上传到github/","link":"","permalink":"https://tetedetian.github.io/2020/10/23/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/","excerpt":"从建立github仓库开始，介绍如何把本地项目上传到github仓库","text":"从建立github仓库开始，介绍如何把本地项目上传到github仓库 步骤概览 建立github仓库 1.建立github仓库 2.建立github仓库与本地的连接（1）在需要上传的文件夹里右击鼠标，点击Git Bash Here （2）下图是命令执行截图 其中 git init作用是初始化，使git可以控制此文件夹 git remote add origin git@github.com:tetedetian/Room-reservation-system.git作用是建立与github仓库的连接。 （git@github.com:tetedetian/Room-reservation-system.git来源于下图） 3.将本地文件推到github仓库（1）执行git add . （2）执行git commit -m &quot;这里写提交描述，会在仓库显示&quot; （3）执行git push -u origin master","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://tetedetian.github.io/tags/Github/"}]},{"title":"如何快速下载Github项目","slug":"如何快速下载GitHub项目","date":"2020-10-16T09:05:59.513Z","updated":"2020-10-23T13:46:29.777Z","comments":true,"path":"2020/10/16/如何快速下载GitHub项目/","link":"","permalink":"https://tetedetian.github.io/2020/10/16/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDGitHub%E9%A1%B9%E7%9B%AE/","excerpt":"把github的项目直接克隆到本地的速度实在太慢了。。 我们可以借助gitee来帮助我们下载项目","text":"把github的项目直接克隆到本地的速度实在太慢了。。 我们可以借助gitee来帮助我们下载项目 1.注册gitee注册网址在这里 2.","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://tetedetian.github.io/tags/Github/"}]},{"title":"c++基础知识点（更新中）","slug":"cpp基础知识点","date":"2020-09-25T04:19:35.188Z","updated":"2021-03-19T08:43:42.384Z","comments":true,"path":"2020/09/25/cpp基础知识点/","link":"","permalink":"https://tetedetian.github.io/2020/09/25/cpp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"————一些c++基础知识点————","text":"————一些c++基础知识点———— 注：此博客只是我对部分知识点的记录与总结，想了解更多请参考权威书籍。 前言1.C语言与C++有什么区别？（1）设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言 什么是面对过程？什么是面对对象？ 简单来说，就是。。。。 （2）语法上： C++具有封装、继承和多态三种特性 C++相比C，增加多许多类型安全的功能，比如强制类型转换、 C++支持范式编程，比如模板类、函数模板等 一、基础1.使用cout与cin（1）&lt;iostream&gt;是头文件，iostream 中的 io 指的 是 输入（ 进入 程序 的 信息） 和 输出（ 从 程序 中 发送 出去 的 信息）。使用 cin 和 cout 进行 输入 和 输出 的 程序 必须 包含 iostream 文件 （2）using namespace std使用命名空间std。命名空间：名称空间主要作用是避免，在同一个程序不同文件使用了相同名字定义变量或者函数。后面会有命名空间的定义方法。 （3）cin&gt;&gt;num是将键盘的输入传到变量num。 （4）cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl是c++打印的语法，或者说是cout与endl的用法。此处与c语言的打印printf使用形式差别很大。cin cout和&lt;&lt;其实是头文件iostream对cout以及符号&lt;&lt;进行了重载，赋予了它新含义，后续会了解到。 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int num; cin&gt;&gt;num; cout&lt;&lt;\"hello world,there are \"&lt;&lt;num&lt;&lt;\" people\"&lt;&lt;endl; return 0;&#125; 输入输出： 2.using namespaceusing是使用名称空间的命令，如using namespace std是使用名称空间std。 名称空间有什么用： 顾名思义，名称空间就是一个存放名称的空间。namespace可以比喻成房间，using namespace就像是打开房门的指令，只有打开的房门，才可以从里面拿东西。 名称空间就是如此，建立名称空间就可以使得不同文件里的函数、变量等可以使用相同的名字。 如何创建名称空间 其实很简单，就是使用namespace，示例如下： 1234567891011//把变量、结构体、函数等的声明放在namespace的定义里//A就是名称空间namespace A&#123; int a=40; struct b &#123; char c[20]; &#125;; void getperson(int x,int y);&#125; 提倡在头文件中使用名称空间 需要注意的是： （1）using namespace std是有作用域的，将using namespace std放置在哪个函数里，便能在哪个函数里使用名称空间std，若是放在所有函数定义之前的位置，则它的作用域就是全局。 （2）若是不使用using又想使用命名空间里的元素，可以使用::,如std::cout （3）如果是一个没有名字的名称空间，那名称空间里面的变量、函数只在名称空间所在的文件里有效 3.数据类型整型：bool、 char、 signed char、 unsigned char、 short、 unsigned short、 int、 unsigned int、 long 、unsigned long 浮点类型：float、double、long double （按照内存位数排序。如 short 至少 为 16 位， 而 int 至少 与 short 一样 长，long至少为32位， 且至少和int一样长。确切 的长度取决于实现） 4.const限定符（1） 1const int A=25;//相当于宏定义，后面就可以用A代替25了。不同于define的是这个可以放在函数内部从而有特定作用域 （2） 1const char *A=\"you\";//const的作用是限定A在后面不能被重新赋值 （3） 12int a=39;const int *p=&amp;a;//这样定义的指针p不可以通过*p来改变a的值，但是可以改变p的值（即指向） （4） 12int a=39;int * const p=&amp;a;//这样定义的指针p不可以改变p的值，就是不可以改变p的指向，但是可以通过*p改变a的值 （5） 12345const int a=2;const int* p1=&amp;a;//合法的，因为变量和指针都使用了constconst int a=2;int* p1=&amp;a;//不合法的，因变量是const类型，但是指针p1不是，若是合法，那岂不是可以通过*p1改变a的值了？有矛盾 （6）常函数、常对象 这部分放在了第三部分的第8点，点我跳转 5.强制类型转换在c语言里，强制类型转换的格式是:（typename）value 123&#x2F;&#x2F;例如int a&#x3D;2;(float) a;&#x2F;&#x2F;将a强制转换为float类型 而在c++中，格式变换了一下：typename（value） 123//例如int a=2;float(a);//新格式的想法是，要让强制类型转换就像是函数调用。 C++ 还 引入了 4个 强制类型转换操作符，(稍后添加) 6.读取字符串当数组存放字符串时，需要注意： 1.1 利用cin读取键盘上的字符串到字符数组时，遇到空格、 制表符 和 换行符时，便会结束读取 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; char name[20]; cin&gt;&gt;name; cout&lt;&lt;name&lt;&lt;endl; return 0;&#125; 输入输出; 1.2 getline(）、get（） 这两个函数是istream 中的 类（ 如 cin） 提供 了 一些 面向 行的 类 成员 函数：可读取一行输入，直到到达换行符。 然而，随后getline()将丢弃换行符， 而 get() 将 换行符保留在输入序列中。 (1)getline(） 用法1：cin. getline(参数1，参数2)。参数1 是 用来 存储 输入 行的 数组 的 名称， 参数2是要 读取 的 字符 数。get()用法一样 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; char name[20]; cin.getline(name,20); cout&lt;&lt;name&lt;&lt;endl; return 0;&#125; 用法2：getline(cin,string_name); 12string str1;&#x2F;&#x2F;string用法在1.3getline(cin,str1);&#x2F;&#x2F;将cin流入str,直到遇上换行符。同时会把换行符吞掉。这里的str1只可以是string类型的。数组名不行 7.string类string类可以直接定义一个变量存储字符串 1string str1=\"my home!\"; 可以直接拼接 123string str1=\"abc\";string str2=\"def\";string str3=str1+str2; 8.结构体定义结构体示范： 123456struct name//name就是结构体类型的名字，类似int、char&#123; char a[20]; int num; double num1;&#125; 创建新的结构体： 1name A;//这里的name就是上面那个结构体的类型名 访问成员时，使用符号.，例如： 1A.num 可以利用数组创建多个结构体对象 1name B[100];//则B[0]~B[99]都是结构体对象，引用成员示范：B[0].num 9.使用new操作符（1）常规new 给单个数据申请空间： 123456//定义一个指针p，指向一个新申请的内存空间，内存空间是int型的，然后就可以给*P赋值了int *P=new int;*p=58；//用完之后应该用delete进行释放，不然容易造成内存泄漏（就是你申请在这里又不用，浪费）如：delete p; 给数组申请空间： 1234int * psome = new int [10]；//使用new创建动态数组//对应地，用delete []进行释放delete [] psome （2）布局new 先看个例子 例子中，p1、p3是使用了常规new，p2、p4是使用了布局new 两者的三点差别： 1.常规new是在堆上面申请内存，而这个布局new是将内存申请在括号里面的数组的地址。 2.重复使用常规new是不确定位置地在堆上面申请内存，但是布局new是在指定的位置上继续在后面的地址申请。 3.常规new用delete释放内存，但是这里的布局new不可以，因为数组buffer1与buffer2指定的内存是静态内存。 10.引用引用就是给一个变量起别名，如 1int &amp; A=B;//给B起一个别名：A，以后对A的操作就相当于对B的操作了 引用还有很多应用，比如作为函数参数，如 123456789void swapr(int &amp; a, int &amp; b)&#123; int temp; temp=a; a=b; b=temp;&#125;/*在这个例子里，使用了引用，作用是把a，b作为传进的参数的别名了。上述函数操作完之后，a，b对应的变量会改变，如果没有使用引用的话，函数执行并不会改变变量原本的值*/ 引用还可以指向结构体 123456789const sysop &amp; use(sysop &amp; sysopref)&#123; cout&lt;&lt;sysopref.name&lt;&lt;\"say:\\n\"; cout&lt;&lt;sysopref.quote&lt;&lt;endl; sysopref.used++; return sysopref;&#125;/*上面是一个参数为结构体引用的函数，而且它的返回值是一个结构体引用。什么意思呢，如果返回的是普通结构体类型，则函数返回的时候，是将结构体用一个临时空间存起来。中间有一个拷贝的过程，效率低。而引用返回的就是主函数中的结构体（sysopref是它的别名）*/ 11.static作用： （1）全局静态变量 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量. 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。 （2）局部静态变量 在局部变量（比如函数里面的变量）之前加上关键字static，局部变量就成为一个局部静态变量。 作用域：作用域仍为局部作用域（只在函数内部有效）。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； （1）（2）可以总结成下表格 类别 位置及使用方法 作用域 全局变量 在函数外面，不使用static 所在文件以及其他文件 全局静态变量 在函数外面，使用static 所在文件 局部静态变量 在函数里面，使用static 所在函数 （1）（2）点使用举例： 1234567891011int a=1;//a的作用域是所在文件以及其他文件static int b=2;//b的作用域是所在文件int main()&#123; ....&#125;void fun1()&#123; static int c=3;//c作用域是fun1 int d=4;//d域也是fun1&#125; （3）静态函数 在函数返回类型前加static，函数就定义为静态函数。 作用域：静态函数只是在声明他的文件当中可见，不能被其他文件所用，故不会同其他cpp中的同名函数引起冲突。（函数的定义和声明在没加static的默认情况下，其他文件是能链接到的） 注意：为了规范，不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数 （4） 类的静态成员 在类定义时，若某个成员属性前面用了static修饰，那之后这个类创建的所有对象的此成员属性都使用同一个内存空间，即值都是相等的。若在对象1对该成员属性进行了更改，其他对象的该成员属性也会变化。（简单来说，就是数据共享了） （5）类的静态函数 在类定义时，若某个成员函数前面用了static修饰，此成员函数就是类的静态函数 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 12.枚举枚举使用关键字enum 例子： 1enum spectrum &#123;red, orange, yellow, green, blue, violet, indigo, ultraviolet&#125;; 这条语句完成两项工作： ● 让 spectrum 成为新类型的名称； spectrum 被称为枚举（ enumeration），就像 struct 变量被称为结构一样。 ● 将 red、 orange、 yellow 等作为符号常量，它们对应整数值0〜7。这些常量叫作枚举量（ enumerator）。 在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。 10.编程小知识这部分是介绍c++编程时的一些小知识 （1）system(“pause”); 暂停程序的执行，等待任意健继续执行。 （2）system(“cls”); 将上一次运行输出的内容给清除掉 *（3）#pragma once * 防止头文件重复包含 二、函数1.内联函数作用：内联函数的作用与宏定义define很像，调用了内联函数的地方，系统在编译的时候会直接把调用的语句替换成内联函数的定义内容。 内联函数是C++为提高程序运行速度所做的一项改进。作用简单来说就是用空间换时间。 空间换时间解释：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 语法： 定义函数与声明函数需要使用关键字inline 内联函数与常规函数的定义规则一样的，只是定义与调用的时候需要使用关键字inline 123456789101112131415#include &lt;iostream&gt;using namespace std;//定义一个加法函数，并且设置为内联函数inline int add_3_num(int a, int b, int c)&#123; return a+b+c;&#125;//调用int main()&#123; cout&lt;&lt;add_3_num(1,2,3)&lt;&lt;endl;//这里的调用，系统编译时会直接替换成上面的定义 return 0;&#125; 注意点： 内联只是给编译器的建议，比如函数体过大时，编译器不一定就会使用内联，例如存在循环语句、存在过多判断语句。 2.函数默认参数c++支持给函数添加默认参数，例如 1234int add_3_num(int a=10, int b=20, int c=30)//a,b,c的默认参数是10、20、30，函数调用时如果没传入参数，就取默认值&#123; return a+b+c;&#125; 可以只给后面部分参数设置参数值，例如 12345int add_3_num(int a, int b, int c=30)&#123; return a+b+c;&#125;//调用的时候需要传入至少两个参数，比如add_3_num(1,2) 3.函数模板语法： 系统会根据啊，a，b的数据类型把T更换成对应的数据类型。所以这里的a，b的数据类型需要相同 1234567891011121314/*函数模板声明*/template&lt;class T&gt;//class也可以换成typename，这里的T不一定需要是T，与下面对应就可以。（但是一般使用T，约定俗成）void fun(T &amp;a, T &amp;b);//有需要时，函数返回类型也可以使用T/*函数模板定义*//*这里就定义一个数据交换的函数*/template&lt;class T&gt;void fun(T &amp;a,T &amp;b)&#123; T tmp; tmp=a; a=b; b=tmp;&#125; 三、类类是c++中的重点内容，也是c++相对于c语言，新增的内容，需要重点掌握 1.什么是类类，往往是具有一些共同属性的事物集合。比如，圆可以抽象成一个类，这个类包含和半径，周长，面积等成员，每一个具体的圆就是一个具体的对象。人也可以抽象成一个类（所以叫人类？哈哈），而每一个具体的人就是一个具体的对象。 2.如何创建简单类格式： 123456789class 类名&#123; /*private部分外界无法直接更改与调用，只有使用了public关键字的部分，外界才可以直接调用。 但是可以在public部分添加可以更改private数据的函数，然后外界通过调用public部分的成员函数， 对private数据进行更改*/ private：//私有部分,这里一般放不希望被直接更改或调用的数据，一般成员属性设置为私有 public：//共有部分，不使用public的话默认private属性,这里放可以被调用的函数，一般成员函数设置为共有 &#125;; 示例： (1)创建一个简单的圆类 12345678910class Circle&#123; private: int r; public: double calculate_l() &#123; return 2*pi*r; &#125;&#125; 3.使用简单类1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Circle//Circle就是类名&#123; private: int r; public: int set_r(int a) &#123; r=a; return 0; &#125; double calculate_l() &#123; return 2*3.14*r; &#125;&#125;;int main()&#123; Circle c1;//使用类创建一个具体对象c1 int c_r; cin&gt;&gt;c_r; c1.set_r(c_r);//把c_r的值赋值给c1的半径r cout&lt;&lt;\"半径是：\"&lt;&lt;c_r&lt;&lt;\",\"&lt;&lt;\"周长是：\"&lt;&lt;c1.calculate_l()&lt;&lt;endl;//使用成员时，需要使用\".\"进行连接 return 0;&#125; 输入输出： 4.构造函数就是类里面的一个函数，用来初始化类的私有数据，名字与类的名字一样。一般类有多少个变量，构造函数就有多少个参数。 构造函数有：无参构造函数、有参构造函数、拷贝构造函数。（其实这里就是用到了函数重载） （1）语法： 12345678910111213141516171819202122232425262728293031323334353637383940/*定义类*/class Circle&#123; private: int r; public://构造函数必须放在public里，不然外界无法调用 //无参构造函数,这也是类的默认构造函数 Circle() &#123; //这里面就是无参构造函数初始化内容，根据实际需求编写 &#125; //有参构造函数 Circle(int a) &#123; //这里面就是有参构造函数初始化内容，根据实际需求编写 &#125; //拷贝构造函数，作用就是根据引用的对象数据来初始化 Circle(const Circle &amp; a)//这里的const是必须的，保证引用的对象不会被更改 &#123; //这里面就是拷贝构造函数初始化内容，根据实际需求编写 &#125;&#125;;/*调用*//*下面的调用都只是举例，实际调用时的参数需要根据具体情况填写对应的类型、数量*/int main()&#123; /*括号引用法*/ //无参构造函数调用,不需要括号 Circle c1; //有参构造函数调用 Circle c1(3)； //拷贝构造函数调用 Circle c2(c1);//假如c1已经存在且初始化了 /*显式引用法*/ //有参构造函数调用 Circle c1=Circle(1); //拷贝构造函数调用 Circle c2=Circle(c1);//假如c1已经存在且初始化了&#125; （2）初始化列表： 构造函数有可以利用初始化列表语法进行初始化，如 1234//格式：构造函数：属性（参数），属性（参数），属性（参数）.....//a,b,c的值就会赋值给c_a、c_b、c_cCircle (int a,int b,int c):c_a(a),c_b(b),c_c(c)//这里的c_a、c_b、c_c假设是Circle的成员属性&#123;&#125; （3）explicit关键字 在构造函数定义中使用 explicit 可防止隐式转换 1234567891011121314//不使用explicitCircle(int a)&#123; r=a;&#125;//使用explicitexplicit Circle(int a)&#123; r=a;&#125;//什么是隐式类型转换？比如Circle c1=1;//这就是隐式类型转换，这种初始化的含义并不是很明确，如果使用了explicit，那直接使用下面这种显式初始化Circle c1(1); 注意点： 1.当我们提供了有参构造函数，系统就不会提供默认构造函数，但是会提供默认拷贝函数。 12345678910111213//也就是如果我们只定义了 Circle(int a):r(a) &#123; .... &#125;//没有定义Circle()&#123; ...&#125;//那么创建对象的时候就一定要传入参数Circle c1(1);//可行Circle c1;//不可行，因为系统不会自动提供默认构造函数了 2.当我们提供了拷贝构造函数，系统就不会提供任何默认构造函数。 5.析构函数对象过期时， 程序将自动调用一个特殊的成员函数—— 析构函数。析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。 语法： 12345//与类名相同，在类名前面加一个“~”，没有返回值，不写void，不可以有参数~Circle()&#123; //这里面不需要写什么内容，不过有时候为了能看到析构函数的调用时间，可以添加一些输出语句&#125; 6.static在类中使用static可以定义静态成员属性以及静态成员函数，可跳转“基础—static”部分查看 7.this指针this指针是一种隐含指针，它隐含于每个类的非静态成员函数（静态成员函数使用的是同一块内存空间，不需要this）中，this指针指向调用成员函数的对象。 比如，c1.a(c2)将this设置指向c1对象的指针，需要时就可以调用。 示例： 12345678910111213141516171819202122/*示例1*///定义一个比较两个圆的成员函数void compare_r(Circle &amp; c)&#123; if(this-&gt;r==c.r)//这里的this就是指向这个成员函数所在的对象。因此当需要将自身与其他对象比较的时候就很有用 &#123; cout&lt;&lt;\"半径相同\"&lt;&lt;endl; &#125;&#125;/*示例2*/Circle &amp; compare_r(Circle &amp; c)//返回值是一个对象（一定要用Circle &amp;,不然返回的只是这个对象拷贝出来的值）&#123; if(this-&gt;r==c.r)//这里的this就是指向这个成员函数所在的对象。因此当需要将自身与其他对象比较的时候就很有用 &#123; return *this; &#125; else return c;&#125;//调用c1.compare_r(c2).compare_r(c3);//这个就实现了先比较c1与c2的半径大小，然后半径大的再和c3比较。//这里假如c1半径比较大，那就相当于c1.compare_r(c3) 注意： （1）空指针问题 12345678910111213141516171819202122//如果创建对象的时候是下面这样Circle * p=NULL;p-&gt;set_r(1);//set_r是设置半径的成员函数，这里看起来没什么问题，但是却执行不了，原因如下int set_r(int a)&#123; /*这里其实编译器是这样做的: this-&gt;r=a;但是由于创建对象的语句：Circle * p=NULL; 其实已经把this=NULL了，因此r=a；这语句无法执行*/ r=a; return 0;&#125;//为了避免执行不了程序宕机的情况下，经常加一个判断语句int set_r(int a)&#123; if(this==NULL) &#123; return;//直接返回，虽然这个函数依旧没有执行，但是避免了程序卡死的情况 &#125; r=a; return 0;&#125; 8.常函数、常对象 常函数与常对象需要使用const关键字 常函数：不允许修改指针指向的值 123456789int set_r(int a) const//在成员函数头最后添加了const，就可以定义为常函数&#123; if(this==NULL) &#123; return; &#125; r=a;//r=a将会报错，因为r=a实际上是this-&gt;r=a,这修改了指针指向的值，是常函数不允许的 return 0;&#125; 常对象：不允许修改成员属性，也不可以调用普通成员函数（可以调用常函数，但是常函数又改不了属性，所以其实差不多） 123//假如创建对象时是使用constconst Circle c1;cout&lt;&lt;c1.set_r(1)&lt;&lt;endl;//无法执行，因为set_r()无法调用 9.友元（1）友元函数 就是可以在类定义里添加一个函数声明，它不是成员函数，但是它有与成员函数一样的操作权限（就是可以更改私有数据等），这种函数叫做友元函数。 声明如下：（多了个friend） 123456/*1.把全局函数设置成友元函数*/friend void take_r();//这个声明需要放到类中去。//也就是普通的函数，你在它的声明前面添加friend并且放到类中，就可以称为类的友元函数/*2.把其他类的成员函数设置成友元函数*/friend void Square::set_l();//假如这里的Square是一个正方形类，set_l（）是他的成员函数 但是记住，他不是成员函数，所以成员函数特有的使用方式它不可以使用。比如“.” 一个重要作用：用来重载”&lt;&lt;” 我们都知道cout&lt;&lt;可以用来显示很多类型，十分方便。但其实，cout&lt;&lt;就是通过操作符重载来实现的，面对不同的类型，&lt;&lt;有不同的重载。如果想实现cout&lt;&lt;A（A是一个存储时间的类），那怎么办？这时候就可以通过重载&lt;&lt;实现，但是如果通过普通的方法，在Time类里重载&lt;&lt;，那就要写出A&lt;&lt;cout，这很奇怪。这个时候友元函数就有用了，因为友元函数两个参数的位置不一定，因为A与cout都只是参数而已 （2）友元类 声明与友元函数一样，使用关键字friend 12//假如想Circle类成为其他类的友元，就在其他类中添加下列语句friend class Circle; 四、重载 1.函数重载（1）作用： 函数重载就有点类似汉语中的多音字，同一个字在不同语句中有不同的意思。利用函数重载可以使得同一个函数名可以根据参数的不同（比如参数类型、数目，顺序的不同）采用不同的函数内容。 （2）语法： 12345678910111213141516//比如下列例子，调用print函数时，系统会根据print传进的参数决定使用哪一个。void print(int a)&#123; //函数内容&#125;void print(int a,int b)&#123; //函数内容&#125;void print(double a)&#123; //函数内容&#125; （3）注意 当同时使用了函数重载以及默认参数时，应该注意有没有二义性，看下列例子 1234567void fun(int a,int b=10)&#123; &#125;void fun(int a)&#123; &#125;//当调用fun(1),就会产生二义性，上下两个都满足 2.操作符重载1.加号运算符重载c++的语法提供的操作符（加减乘除求余这些）的作用都是固定的，比如+只能对变量类型进行相加，而不能相加一些我们自己创建的一些数据类型，比如时间，日期这些类。但是c++提供了操作符重载，用来弥补这些不足。简单来说，就是我们可以DIY操作符的功能。 语法： 要点：定义一个函数，使用关键字operator，函数设置为类的友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*假如我要重载“+”，使得两个圆对象相加时，是将他们的半径相加*///类定义class Circle&#123; private: int r; public: //把操作符重载函数设置为类的友元函数，不然它作为全局函数访问不到类 friend Circle operator+(Circle &amp; c1,Circle &amp; c2); //默认构造函数 Circle() &#123;&#125; //有参构造函数 Circle(int a):r(a) &#123;&#125; //半径修改函数 int set_r(int a) &#123; r=a; return 0; &#125; //半径打印函数 void show_r() &#123; cout&lt;&lt;r&lt;&lt;endl; &#125;&#125;;//定义一个全局函数，实现加号重载Circle operator+(Circle &amp; c1,Circle &amp; c2)&#123; Circle tmp; tmp.set_r(c1.r+c2.r); return tmp;&#125;//测试加号重载void test3()&#123; Circle c1(1); Circle c2(2); Circle c3=c1+c2; c3.show_r();&#125;int main()&#123; test3(); return 0;&#125; 输出： 2.左移运算符重载基本上我们刚接触c++的时候就会看到cout&lt;&lt;....&lt;&lt;endl;,这语句是用来输出的。其中的原理就是对左移运算符&lt;&lt;进行了重载。但是，系统提供的重载有限，因此有时候我们想使用cout&lt;&lt;....&lt;&lt;endl;来输出我们自定义的一些数据类型，就要自己对&lt;&lt;进行重载 语法： 1234567//这里的重载其实和上面的加号重载语法基本相同，那我在这里就不写那么详细了ostream&amp; operator&lt;&lt;(osteam&amp; cout,Circle&amp; c)&#123; cout&lt;&lt;\"c.r\"&lt;&lt;endl; return cout;&#125;//这里的返回类型为什么需要返回ostream:因为最后需要return cout，这样才可以在一个语句中使用&lt;&lt;连续输出 3.不要重载&amp;&amp; 和||原因就是实现不了，可以自己试试 五、继承不同类之间可以继承。继承的作用就是可以复用其他类，减少代码的量。 1.继承方式有公有继承，保护继承，私有继承。几种继承的区别可以看下列 例子： 12345678910111213141516171819202122232425262728293031323334//父类class A&#123; public : int a; protected: int b; private: int c; &#125;;//公有继承，保护继承，私有继承都无法继承父类的私有部分//:public A就是代表公有继承A//公有继承。公有属性与保护属性不变class B:public A&#123; public : int a; protected: int b;&#125;;//保护继承。父类的所有成员都变成保护属性class B:protected A;&#123; protected: int a; int b;&#125;;//私有继承。父类的所有成员都变成私有属性class B:private A;&#123; private: int a; int b;&#125;; 2.继承的构造与析构（1）子类不会继承父类（基类）的构造函数以及析构函数。因此需要给子类再添加构造函数以及析构函数。 （2）但是，在子类创建对象的时候，会先调用父类的构造函数，再调用子类的构造函数。 （3）在析构时，会先调用子类的析构函数再调用父类的析构函数。与构造函数顺序相反。 3.继承中同名成员处理假如父类中有一成员名称为A，子类中又定义了一成员A，那么直接调用的话，是调用子类。 如果想使用父类的同名函数，可以加上作用域指定，格式：子类对象名.父类的类名::成员名 示例： 12345678910111213141516171819202122232425262728293031323334353637383940class Circle&#123; private: int r; public: //半径打印函数 void show_r() &#123; cout&lt;&lt;\"父类的r\"&lt;&lt;endl; &#125;&#125;;class Circle1:public Circle&#123; public: Circle1() &#123;&#125; void show_r() &#123; cout&lt;&lt;\"子类的r \"&lt;&lt;endl; &#125;&#125;;int main()&#123; Circle1 c; c.set_r(2); c.show_r(); return 0;&#125;//此时，输出就是“子类的r”，调用的是子类的函数//如果想使用父类的同名函数，可以加上作用域指定int main()&#123; Circle1 c; c.set_r(2); c.Circle::show_r();//这里不一样了 return 0;&#125; 4.多继承多继承也就是继承多个类，语法也很简单 1class C:public A,public B//继承A和B 多继承的用法与单继承差不多，需要注意的是多继承的二义性问题：父类A和父类B有同名成员。 解决方法：使用作用域，与上一点的子类父类同名用法一样。使用子类对象名.父类的类名::成员名 六、多态1.基本概念（1）多态是什么： （2）多态的分类： 1) 静态多态：可以称为编译期多态，它是在编译期间通过函数重载和操作符重载的方式决定被调用函数。2) 动态多态：可以称为运行期多态，它可以通过继承和虚函数来实现。实现时，编译器将在进程运行的过程中动态的捆绑想要调用的函数 。 2.静态多态静态多态的函数重载以及操作符重载前面已经写了，在多态这一部分就不再啰嗦了。可以点击重载查看相关内容 3.动态多态动态多态依靠继承以及虚函数来实现。继承前面已经介绍，那么接下来介绍虚函数。 3.1虚函数（1）虚函数的作用：使函数不是在编译的时候就已经确定运行时机，而是在运行的时候动态绑定 虚函数是通过在继承中的父类成员函数前添加virtual关键字，可以实现子类重定义虚函数之后，直接调用虚函数是调用子类。说起来很难理解，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//我们使用一个计算器类来举例,先在父类中添加虚函数。之后每次添加功能再创建一个子类#include &lt;iostream&gt;using namespace std;//父类class calculator&#123;public: virtual int result ()//把result定义为虚函数。其实这个虚函数并不实现什么，只是给子类提供派生接口 &#123; return 0; &#125; int value1; int value2; void setv1(int a)//给value1赋值的成员函数 &#123; value1=a; &#125; void setv2(int a)//给value2赋值的接口函数 &#123; value2=a; &#125;&#125;;//子类，用来实现加法class plus_calculator:public calculator&#123;public: virtual int result()//在子类重写虚函数（函数头需要与父类相同）virtual可写可不写（建议写方便阅读），并且编写函数内容 &#123; return value1+value2; &#125;&#125;;//减法class minus_calculator:public calculator&#123;public: virtual int result() &#123; return value1-value2; &#125;&#125;;int main()&#123; calculator * p; p=new plus_calculator;//用父类指针指向加法子类 p-&gt;setv1(10); p-&gt;setv2(20); cout&lt;&lt;p-&gt;result()&lt;&lt;endl; delete p; p=new minus_calculator;//用父类指针指向减法子类 p-&gt;setv1(10); p-&gt;setv2(20); cout&lt;&lt;p-&gt;result()&lt;&lt;endl;&#125; （2）纯虚函数： 父类中的虚函数除了像上面例子那样定义，还可以定义为纯虚函数，代码如下： 1234567//将virtual int result () &#123; return 0; &#125;//改成virtual int result ()=0; 但是使用了纯虚函数，需要注意以下几点： (1)如果父类中有纯虚函数，子类继承父类，就必须实现纯虚函数（就是必须在子类写个有内容的虚函数） (2)如果父类中有了纯虚函数，就是一个抽象类，这个父类就无法示例化对象了。（就是没办法创建父类的对象了） （3）虚析构 在对父类的析构没使用virtual关键字时，是普通析构，普通析构是不会调用子类的析构函数的。比如上面的例子，是不会调用加法减法类的析构函数的。 想要系统也调用子类的析构函数的话，可以在父类的析构函数前面添加virtual关键字。 七、STLSTL全称是：standard Template Library(标准模板库) STL六大组件简介： 1.容器：容器是一个与数组类似的单元，可以存储若干个值。 STL 容器是同质的，即存储的值的类型相同 2.算法：算法是完成特定任务（如对数组进行排序或在链表中查找特定值） 3.迭代器：迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针 4.仿函数：5.适配器。6.空间配置器 1.容器1.1 string容器1.1.1 简介头文件： string string和char * 区别： char * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 1.1.2 构造函数构造函数原型： string(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化 string(const string&amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化 示例： 123456789101112131415161718//构造#include &lt;string&gt;void test01()&#123; string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; \"str1 = \" &lt;&lt; s1 &lt;&lt; endl; const char* str = \"hello world\"; string s2(str); //把c_string转换成了string cout &lt;&lt; \"str2 = \" &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl; string s4(10, 'a'); cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl;&#125; 1.1.3 赋值操作赋值的函数原型： string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串 string&amp; operator=(char c); //字符赋值给当前的字符串 string&amp; assign(const char *s); //把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串 string&amp; assign(int n, char c); //用n个字符c赋给当前字符串 示例： 1234567891011121314151617181920212223242526272829303132//赋值void test01()&#123; string str1; str1 = \"hello world\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; \"str2 = \" &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = 'a'; cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(\"hello c++\"); cout &lt;&lt; \"str4 = \" &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(\"hello c++\",5); cout &lt;&lt; \"str5 = \" &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; \"str6 = \" &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, 'x'); cout &lt;&lt; \"str7 = \" &lt;&lt; str7 &lt;&lt; endl;&#125; 1.1.4 拼接拼接函数原型： string&amp; operator+=(const char* str); //重载+=操作符 string&amp; operator+=(const char c); //重载+=操作符 string&amp; operator+=(const string&amp; str); //重载+=操作符 string&amp; append(const char *s); //把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); //同operator+=(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 示例： 1234567891011121314151617181920212223242526//字符串拼接void test01()&#123; string str1 = \"我\"; str1 += \"爱玩游戏\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; str1 += ':'; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2 = \"LOL DNF\"; str1 += str2; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str3 = \"I\"; str3.append(\" love \"); str3.append(\"game abcde\", 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl;&#125; 1.1.5 查找和替换函数原型： find:从左往右查找 int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 rfind:从右往左查找 int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 replace:替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s 示例： 12345678910111213141516171819202122232425262728293031//查找void test01()&#123; string str1 = \"abcdefgde\"; int pos = str1.find(\"de\"); if (pos == -1) &#123; cout &lt;&lt; \"未找到\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; &#125; pos = str1.rfind(\"de\"); cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl;&#125;//替换void test02()&#123; //替换 string str1 = \"abcdefgde\"; str1.replace(1, 3, \"1111\"); cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl;&#125; 1.1.6 比较函数原型： int compare(const string &amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 示例： 12345678910111213//字符串比较void test01()&#123; string s1 = \"hello\"; string s2 = \"aello\"; int ret = s1.compare(s2); if (ret == 0) &#123; cout &lt;&lt; \"s1 等于 s2\" &lt;&lt; endl; &#125;&#125; 1.1.7 存取函数原型：（两种方式） char&amp; operator[](int n); //通过[]方式取字符 char&amp; at(int n); //通过at方法获取字符 示例： 12345678910111213141516171819202122232425void test01()&#123; string str = \"hello world\"; //通过[]方式取字符 for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //通过at方法获取字符 for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //字符修改 str[0] = 'x'; str.at(1) = 'x'; cout &lt;&lt; str &lt;&lt; endl; &#125; 1.1.8 插入与删除函数原型： string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 示例： 12345678910//字符串插入和删除void test01()&#123; string str = \"hello\"; str.insert(1, \"111\"); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl;&#125; 1.1.9 获取子串函数原型： string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 示例： 1234567891011121314//子串void test01()&#123; string str = \"abcdefg\"; string subStr = str.substr(1, 3); cout &lt;&lt; \"subStr = \" &lt;&lt; subStr &lt;&lt; endl; string email = \"hello@sina.com\"; int pos = email.find(\"@\"); string username = email.substr(0, pos); cout &lt;&lt; \"username: \" &lt;&lt; username &lt;&lt; endl;&#125; 1.2 vector容器1.2.1 简介头文件：vector 功能：vector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 图示： 1.2.2 构造函数函数原型： vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); //拷贝构造函数。 示例： 1234567891011121314151617181920212223242526272829#include &lt;vector&gt;//定义一个打印函数void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4);&#125; 1.2.3 赋值操作函数原型： vector&amp; operator=(const vector &amp;vec);//重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 示例： 12345678910111213141516171819202122//赋值操作void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4);&#125; 1.2.4 容量与长度函数原型： empty(); //判断容器是否为空 capacity(); //返回容器的容量 size(); //返回容器长度，即元素的个数 resize(int num); //重新指定容器长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除 示例： 12345678910111213141516171819202122232425262728void test01()&#123; vector&lt;int&gt; v1; //填充元素 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); if (v1.empty()) &#123; cout &lt;&lt; \"v1为空\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"v1不为空\" &lt;&lt; endl; cout &lt;&lt; \"v1的容量 = \" &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; \"v1的大小 = \" &lt;&lt; v1.size() &lt;&lt; endl; &#125; //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1);&#125; 注意：分清楚容量和长度（大小） 1.2.5 插入和删除函数原型： push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1);&#125; 1.2.6 存取数据函数原型： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例： 12345678910111213141516171819202122232425#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"v1的第一个元素为： \" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; \"v1的最后一个元素为： \" &lt;&lt; v1.back() &lt;&lt; endl;&#125; 1.2.7 容器元素互换函数原型： swap(vec); // 将vec与本身的元素互换，还会根据vec的容量以及长度变化自身容量和长度 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) &#123; v2.push_back(i); &#125; printVector(v2); //互换容器 cout &lt;&lt; \"互换后\" &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2);&#125;void test02()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; v.resize(3);//调整大小 cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; //收缩内存，根据v的大小重新创建了一个容量和大小都与v相同的新v vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;&#125; 1.2.8 预留空间如果数据量较大，可以一开始利用reserve预留空间 函数原型： reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 1.3 deque容器1.3.1 简介头文件：deque 功能：双端数组，可以对头端进行插入删除操作 deque与vector区别： deque没有容量概念 vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque与vector用法很多相同的地方，这里就不一一举例了 1.3.2 常用函数构造函数： deque&lt;T&gt; deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); //拷贝构造函数 赋值： deque&amp; operator=(const deque &amp;deq); //重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 大小： deque.empty(); //判断容器是否为空 deque.size(); //返回容器中元素的个数 deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 插入和删除： 两端插入操作： push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作： insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 数据存取： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 排序： 头文件：使用sort需要包含头文件algorithm sort(iterator beg, iterator end) //对beg和end区间内元素进行排序 1.4 stack容器1.4.1简介概念： stack就是栈，是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口。栈中进入数据称为 — 入栈 push，栈中弹出数据称为 — 出栈或弹栈 pop 1.4.2 常用函数构造函数： stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack &amp;stk); //拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk); //重载等号操作符 数据存取： push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 1.5 queue容器1.5.1 简介概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口。允许从一端新增元素，从另一端移除元素。队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为 队列中进数据称为 — 入队 ，push队列中出数据称为 — 出队 pop 1.5.2 常用函数构造函数： queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que); //拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que); //重载等号操作符 数据存取： push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 1.6 list容器1.6.1 简介头文件：list 功能：将数据进行链式存储 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 1.6.2 常用函数构造函数： list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list &amp;lst); //拷贝构造函数。 赋值与交换： assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); //重载等号操作符，实现赋值 swap(lst); //将lst与本身的元素互换。 大小操作： size(); //返回容器中元素的个数 empty(); //判断容器是否为空 resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 插入和删除： push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 数据读取: front(); //返回第一个元素。 back(); //返回最后一个元素。 反转和排序： reverse(); //反转链表 sort(); //链表排序，默认从小到大 1.7 set/multiset容器1.7.1 简介头文件：set set与multiset基本一样，唯一区别是： set不允许容器中有重复的元素 multiset允许容器中有重复的元素 功能：所有元素都会在插入时自动被排序 本质：set/multiset属于关联式容器，底层结构是用二叉树实现。 1.7.2 常用函数set与multiset函数一样 构造： set&lt;T&gt; st; //默认构造函数： set(const set &amp;st); //拷贝构造函数 赋值： set&amp; operator=(const set &amp;st); //重载等号操作符 大小： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 交换： swap(st); //交换两个集合容器 插入和删除: insert(elem); //在容器中插入元素 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 查找和统计： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 排序： 1.8 map/ multimap容器1.8.1 简介头文件：map map中所有元素都是pair(成对出现的数据，利用对组可以返回两个数据) pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 1.7.2 常用函数构造： map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); //重载等号操作符 大小和交换： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 插入和删除： insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。 查找和统计： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 2.函数对象2.1 函数对象简介概念： 重载函数调用操作符（就是（））的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例: (1)函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 1234567891011121314class MyAdd&#123;public : int operator()(int v1,int v2)//重载“（）” &#123; return v1 + v2; &#125;&#125;;void test01()&#123; MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125; （2）函数对象可以有自己的状态 1234567891011121314151617181920212223class MyPrint&#123;public: MyPrint() &#123; count = 0; &#125; void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 &#125; int count; //内部自己的状态，在这里，就是一个记录被调用次数的值&#125;;void test02()&#123; MyPrint myPrint; myPrint(\"hello world\"); myPrint(\"hello world\"); myPrint(\"hello world\"); cout &lt;&lt; \"myPrint调用次数为： \" &lt;&lt; myPrint.count &lt;&lt; endl;//输出3&#125; （3）函数对象可以作为参数传递 12345678910void doPrint(MyPrint &amp;mp , string test)//两个参数，一个Myprint类型，一个string类型&#123; mp(test);&#125;void test03()&#123; MyPrint myPrint; doPrint(myPrint, \"Hello C++\");//实现将\"Hello C++\"当做参数传给myprint，最后结果就是打印\"Hello C++\"&#125; 2.2谓词2.2.1概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 2.2.2一元谓词示例：123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123; bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; \"没找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 2.2.3二元谓词示例：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"----------------------------\" &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125; 2.3 内建函数对象2.3.1 简介概念： STL内建了一些函数对象 分类: 算术仿函数 关系仿函数 逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include&lt;functional&gt; 2.3.2 算数仿函数功能描述： 实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型： template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数 示例： 1234567891011121314#include &lt;functional&gt;//negatevoid test01()&#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125; 2.3.3 关系仿函数功能描述： 实现关系对比 仿函数原型： template&lt;class T&gt; bool equal_to&lt;T&gt; //等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于 template&lt;class T&gt; bool greater&lt;T&gt; //大于 template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于 template&lt;class T&gt; bool less&lt;T&gt; //小于 template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public: bool operator()(int v1,int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125; 2.3.4 逻辑仿函数功能描述： 实现逻辑运算 函数原型： template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非 示例： 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123; vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125; 3.常用算法3.1 简介 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类,用以声明函数对象。 3.1 常用遍历算法3.1.1 for_each功能描述： 实现遍历容器 函数原型： for_each(iterator beg, iterator end, _func); // 遍历算法 遍历容器元素 // beg 开始迭代器 // end 结束迭代器 // _func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \";&#125;//函数对象class print02 &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;//for_each算法基本用法void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;&#125; 3.1.2 transform功能描述： 搬运容器到另一个容器中 函数原型： transform(iterator beg1, iterator end1, iterator beg2, _func); //beg1 源容器开始迭代器 //end1 源容器结束迭代器 //beg2 目标容器开始迭代器 //_func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public: int operator()(int val) &#123; return val; &#125;&#125;;class MyPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125; 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运 3.2 常用查找算法算法简介： find //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 3.2.1 find功能描述： 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型： find(iterator beg, iterator end, value); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125;class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //重载== bool operator==(const Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125;public: string m_Name; int m_Age;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125; 总结： 利用find可以在容器中找指定的元素，返回值是迭代器 3.2.2 find_if功能描述： 按条件查找元素 函数原型： find_if(iterator beg, iterator end, _Pred); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // _Pred 函数或者谓词（返回bool类型的仿函数） 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public: bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到大于5的数字:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;class Greater20&#123;public: bool operator()(Person &amp;p) &#123; return p.m_Age &gt; 20; &#125;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125; 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略 3.2.3 adjacent_find功能描述： 查找相邻重复元素 函数原型： adjacent_find(iterator beg, iterator end); // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器 // beg 开始迭代器 // end 结束迭代器 示例： 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) &#123; cout &lt;&lt; \"找不到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到相邻重复元素为:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 3.2.4 binary_search功能描述： 查找指定元素是否存在 函数原型： bool binary_search(iterator beg, iterator end, value); // 查找指定的元素，查到 返回true 否则false // 注意: 在无序序列中不可用 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： 12345678910111213141516171819202122#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) &#123; cout &lt;&lt; \"找到了\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"未找到\" &lt;&lt; endl; &#125;&#125; 3.2.5 count功能描述： 统计元素个数 函数原型： count(iterator beg, iterator end, value); // 统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // value 统计的元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; \"4的个数为： \" &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; bool operator==(const Person &amp; p) &#123; if (this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; string m_Name; int m_Age;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(\"诸葛亮\",35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;&#125; 总结： 统计自定义数据类型时候，需要配合重载 operator== 3.2.6 count_if功能描述： 按条件统计元素个数 函数原型： count_if(iterator beg, iterator end, _Pred); // 按条件统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // _Pred 谓词 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public: bool operator()(int val) &#123; return val &gt;= 4; &#125;&#125;;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; \"大于4的个数为： \" &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class AgeLess35&#123;public: bool operator()(const Person &amp;p) &#123; return p.m_Age &lt; 35; &#125;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; \"小于35岁的个数：\" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：按值统计用count，按条件统计用count_if","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://tetedetian.github.io/tags/c/"}]},{"title":"计算机网络（更新中）","slug":"计算机网络基础知识点","date":"2020-09-06T03:24:07.195Z","updated":"2021-03-03T02:44:05.454Z","comments":true,"path":"2020/09/06/计算机网络基础知识点/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"————这里，有一些计算机网络的基础知识，希望对你有帮助^_^———— ————（针对c++后台开发）————","text":"————这里，有一些计算机网络的基础知识，希望对你有帮助^_^———— ————（针对c++后台开发）———— 前言第一章——计算机网络概述1.计算机网络性能 1. 速率：速率即数据率或比特率是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等 2. 带宽：数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 3. 吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量。受网络的带宽或网络的额定速率的限制。 4. 时延：发送数据时，数据块从结点进入到传输媒体所需要的时间。 5. 时延带宽积：时延带宽积 = 传播时延 *带宽 6. 利用率：信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。 2.计算机网络体系结构 3.OSI的7层大约作用3.1 分层的好处： 各层之间是独立的、灵活性好、结构上可分割开、易于实现和维护、能促进标准化工作。 3.2 OSI七层模型及其包含的协议如下: 物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45 数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP 网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP 传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP 会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS 表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII 应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS 3.3TCP/IP 4层模型包括： 网络接口层：MAC VLAN 网络层:IP ARP ICMP 传输层:TCP UDP 应用层:HTTP DNS SMTP 第二章——物理层1.基本概念物理层的主要任务描述为确定与传输媒体的接口的一些特性，即： 机械特性 指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。 电气特性 指明在接口电缆的各条线上出现的电压的范围。 功能特性 指明某条线上出现的某一电平的电压表示何种意义。 过程特性 指明对于不同功能的各种可能事件的出现顺序 第三章——数据链路层1.数据链路层基本概念与三个基本问题1.1基本概念 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。数据链路层传送的是帧 1.2三个基本问题 (1) 封装成帧：封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 (2) 透明传输：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B) (3) 差错控制 ：在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受。“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 2.两种情况下的数据链路层2.1使用点对点信道的数据链路层（用PPP） PPP 协议应满足的需求 1.简单——这是首要的要求。2.封装成帧 。3.透明性 。4.多种网络层协议。 5.多种类型链路。 6.差错检测。 7.检测连接状态。 8.最大传送单元 。9.网络层地址协商 。10.数据压缩协商 。 ppp协议组成部分 (1)一个将 IP 数据报封装到串行链路的方法。(接近物理层) (2)链路控制协议 LCP (Link Control Protocol)。 (3)网络控制协议 NCP (Network Control Protocol)。（接近网络层） ppp协议的帧格式 首部与尾部的F字段是帧定界符 2.2使用广播信道的数据链路层（用CSMA/CD） CSMA/CD协议 要点： 1.多点接入：表示许多计算机以多点接入的方式连接在一根总线上。 2.载波监听：是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 3.碰撞检测：就是计算机边发送数据边检测信道上的信号电压大小。 重要特性： 1.使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 2.每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 3.这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 3.虚拟局域网 （VLAN） （1）一个交换机可以通过划分VLAN，形成虚拟局域网。同一VLAN中的计算机处于同一虚拟局域网里。VLAN1中的广播不会传到VLAN2。相当于把交换机划分成两个交换机。 （2）不同的VLAN之间的帧会有特殊标记，所以不会互相广播 第四章——网络层1.网络层提供的两种服务 （1）虚电路服务：A计算机发给B计算机的所有数据，都沿着同一条虚电路传送。 （2）数据报服务：计算机发给B计算机的数据，可能沿着不同路径传送。（现在在用的服务） 2.虚拟互联网 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 3.ip3.1 ip协议及配套使用协议网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP (Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control Message Protocol) 网际组管理协议 IGMP (Internet Group Management Protocol) 3.2 ip地址分类 ip地址分为A、B、C三类地址。A类的前1位固定为0，B类的前2位固定为10，C类的前3位固定为110。用于识别是哪类地址。图示如下 因为前面1~3位已经固定，因此A、B、C三类地址的前8位范围是： A类：0000000001111111，转为十进制就是0126（127划分到了本地环回地址） B类：1000000010111111，转为十进制就是128191 C类：1100000011011111，转为十进制就是192223 分类的目的：满足不同用户的需求，有些可能网络号需求多，有些电脑连接多。 3.3子网掩码 网络号字段全置1，主机号字段全置0 （1）默认：A类：255.0.0.0 ，B类：255.255.0.0 ，C类：255.255.255.0 （2）子网划分： 当C类地址还需要进行子网划分时，子网掩码就不一定是255.255.255.0了。 比如有200台计算机使用C类网络，但是需要每100台使用一个子网，比如192.168.0.00000000192.168.0.011111111为一子网，192.168.0.10000000192.168.0.111111111为另一子网。即C类网络主机号的第一位划分到网络号了，此时子网掩码是255.255.255.10000000，即255.255.255.128。据此，不同划分情况时，子网掩码后面8位数值可能是128、192、224、240、248、252 注意：划分的子网主机号部分字段不可以全为1或者全为0。全为1或者全为0有特殊用处。 （3）网段合并： 简单来说，就是通过改变子网的数值，重新划分网络号和主机号（网络位置1，主机位置0） 例子1：将 192.168.0.0，netmask:255.255.255.0 和 192.168.1.0,netmask:255.255.255.0 合并。 192.168.0.0—&gt;11000000.10101000.00000000.00000000 255.255.255.0 —&gt;11111111.11111111.11111111.00000000 192.168.1.0—&gt;11000000.10101000.00000001.00000000 255.255.255.0 —&gt;11111111.11111111.11111111.00000000 要合并网段，就要使得两个ip地址的网络号相同，因此子网掩码就要改变（因为子网掩码就是用来标识网络号和主机号的） 可以看到连个的ip地址不同在于： 因此网络号要避开这两位，因此子网掩码应该变为11111111.11111111.11111110.00000000—&gt;255.255.254.0 4.ip和MAC ip地址决定了数据包的起点和终点，MAC地址决定了数据帧的下一跳是哪里。 5.路由选择协议（1）内部网关协议（在区域内） RIP协议：动态路由协议，根据路由器数量选择路径。每30秒更新一次路由表 OSPF协议：动态路由协议，根据带宽选择路径。 （2）外部网关协议 BGP协议：BGP 是不同自治系统的路由器之间交换路由信息的协议。 （3）三个协议之间的关系： 三个协议统称ip协议，RIP和OSPF协议是自治系统（AS）内部路由的选择协议，不同自治系统（AS）之间的通信是用BGP协议。 如下图所示 第五章——传输层1.用户数据报协议 UDP (User Datagram Protocol)1.1特点： （1）一个数据包就能完成数据通信，是不可靠传输。 （2）发送数据之前不需要建立连接(会话)。 （3）尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 （4）面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。 （5）支持一对一、一对多、多对一和多对多的交互通信。 （6）首部开销小，只有 8 个字节。 比如QQ聊天，多播就是用到UDP，这些过程的数据都比较小，一个数据包就可以传输。通过观察也可以判定，比如我们聊天的时候就是一个个信息打包发过去，遇上网络问题就会显示发送失败，这也算是不可靠传输的一种机制，可以通过提醒发送方重新发送。 1.2报文格式 （1）数据在经过运输层，IP层的大约处理流程： （2）UDP 的首部格式 端口：为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。因此有了端口。简而言之，端口就好像不同系统用来定位自己进程的同一标识。 伪首部：在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。 2.传输控制协议 TCP (Transmission Control Protocol)2.1 特点： （1）对数据进行分段、编号，建立会话，是可靠传输。 （2）每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 （3）提供全双工通信(同时收发)。 （4）面向字节流（传输的时候并不管数据的完整性，而是直接把数据分成小的字节段打包发过去）。 比如QQ传文件，访问网址，下载文件。因为这些传输的数据都很大，难以通过一个数据包传输过去（比如带宽限制），因此就要通过对数据进行分段，编号，建立会话进行传输。 2.2 TCP 报文段的首部格式 上面特点有说，TCP是将数据分段传输，要使得分段的数据能够在网络上传到指定位置，以及接受数据的计算机能够将数据拼接起来，就要给数据添加一些标识信息。下图是TCP 报文段的首部格式 。 说明： （1） 首部一般是20个字节，有些特殊数据会更长。 （2）可以看到，源端口和目的端口占16位，也就是2个字节。序号占32位，就是4个字节，其他以此类推。 （3）序号 ：就是被分割成段的数据每一段的序号，数据段的第一个字节是整个文件的第几个字节，它的序号就是多少。 （4）确认号：一般就是数据段的最后一个字节是整个文件的第几个字节+1，作用是告诉发送者下一次发第几个字节。然后发送者就会根据这个确认号去找序号是这个确认号的数据段。 （5）数据偏移： 用来告诉接收端首部有多长，数据部分从第几个字节开始。 （6）保留字段：占 6 位，保留为今后使用，但目前应置为 0。 （7）紧急 URG ：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 （8）确认 ACK ： 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 （9）推送 PSH (PuSH) ： 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 （10）复位 RST (ReSeT) ：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 （11）同步 SYN ：同步 SYN = 1 表示这是一个连接请求或连接接受报文。 （12）终止 FIN (FINis) ：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 （13）检验和 ：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 （14）紧急指针字段 ：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 （15）选项字段 ：长度不定。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 还有一些其他选项。 2.3 如何实现可靠传输 原理简述：接受方需要对接受的数据包回发确认信息，确保可靠交付 下图是最初原理示意图： 通过上面的方法传输的缺点：每次都要等待B的确认信息才能发下一个数据报，信道利用率低、浪费时间。因此常用的是下图的流水线传输方法以及利用滑动窗口。 滑动窗口原理：发送窗口内的数据分段可以连续发送，每接受到B的一个确认信息，就往前移动。比如A收到B确认5收到的报文段，则窗口移动到5后面。万一B只收到1245呢？ B会在回发的数据报文段的“选项”添加选择确认 SACK，可以告知发送端不连续字节块的边界信息。（选项最长40字节，因此可以存放8个边界信息，也就4个字节块边界信息） 2.4 拥塞控制 （1）什么是拥塞： 简单来说就是网络堵车了，假如就50M带宽，但是在网络上的每秒数据量都100M了，就会产生丢包，甚至路由器死机之类的。可以看下图，是控制前后的对比。可以看到在无拥塞控制得情况下，在给50M负载的时候，吞吐量并没有50M。就好像我们的手机，运行内存写6G，实际上用了5G以上就感觉卡了。 （2）大约怎么进行拥塞控制：根据前面学的TCP数据传输原理，容易知道，可以通过控制发送方的发送窗口大小从而控制单位时间内发送出去的数据量，进行拥塞控制。简单来说，就是通过控制所有计算机的数据发送速率，减小网络负担。 （3）具体方法： 1）慢开始算法：给每个发送方设定一个叫做拥塞窗口（cwnd）的变量，用于控制发送窗口大小。cwnd有一个门限：ssthresh（用来限制cwnd最大值）。一开始cwnd设置为1，ssthresh设置为16（1和16指报文段数目，）。使用慢开始算法后，每经过一个传输轮次（例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 ），拥塞窗口 cwnd 就加倍。 当 cwnd = ssthresh 后，开始使用拥塞避免算法。 2）拥塞避免算法： 当 cwnd = ssthresh 后，让拥塞窗口 cwnd 缓慢地增大，每经过一个传输轮次就把 cwnd 加 1，而不是加倍，使cwnd 按线性规律缓慢增长。 3）当网络拥塞后：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把cwnd 重新设置为 1，执行慢开始算法。 示意图 4）快重传： 接收方每收到一个失序的报文段后就立即重复发出3次丢失报文段确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。这样做可以让发送方及早知道有报文段没有到达接收方。比如A传12345，但是B只收到1245，收到4的时候B就开始回发三次3的重传确认。 5）快恢复： 当发送端收到连续三个重复的确认时，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。由于能够连着接受3个确认，发送方会认为网络很可能没有发生拥塞，因此不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 如下图 2.5 TCP 的连接建立:三次握手 过程 1）A向B发送请求报文，报文的SYN=1，代表这是一个连接请求或连接接受报文。seq是序号这个报文的序号。 2）B收到后回发一个SYN=1，ACK=1，seq=y，ack=x+1的报文。其中ACK=1代表ack有效。seq是B发出的报文的序号，ack=x+1是B发出的确认号，也就是告诉A下次发序号是x+1的报文。 3）A收到B的确认报文后，向B发一个ACK=1，seq=x+1，ack=y+1的报文。seq=x+1是因为B给A发了ack=x+1的报文，A发出去的报文序号seq就要是x+1。 （x,y都是随机的，数值不是重点，重点是每次两台计算机的互相响应） 为什么要有第三次握手？ 两次握手不是已经可以证明能够通信了吗，第三次握手岂不是多此一举？ 原因： 第三次握手是用来再次确认。加入没有第三次：假设A发了请求，但是请求的报文走了远路，报文还没到B。A觉得太久了，给B发了第二次请求，第二次请求走了近路，比第一次还快到达，然后AB进行了通信。但是一会后，第一次请求也到B了，B接受到请求，又给A发了确认，接着等待A的通信。但是因为A已经在接受过B的确认了，就会不理A的确认。这会B岂不是在干等了？会浪费资源 下图展示了三次握手的过程以及计算机状态 当两台计算机都是ESTAB—LISHED状态了，就进行数据传送 2.6 TCP 的连接释放 :四次挥手 过程见下图：一共发送了四个报文 1)FIN = 1, seq = u：FIN代表要释放链接，告诉B要停止发送数据了。 2）ACK = 1, seq = v, ack= u + 1：B回应A,允许它断开链接。 3）FIN = 1, ACK = 1, seq = w, ack= u + 1：FIN代表要释放链接，告诉B要停止发送数据了。 4）ACK = 1, seq = u + 1, ack = w + 1：同理，A回应B。 为什么A最后需要等待一段时间（2MSL）？： 因为如果A发给B的确认，B没收到，B就会重新发送释放链接的报文（也就是第三个）。所以此时要是没有TIME-WAIT状态等待，而是直接关了，A就无法接到B的请求，也就不会回应，这样B的连接就释放不了了。 第六章——应用层1.统一资源定位符 URL 怎样标志分布在整个因特网上的万维网文档？ 答案：使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 URL 的一般形式 ：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议：ftp —— 文件传送协议 FTP、http —— 超文本传送协议 HTTP、News —— USENET 新闻 主机： 是存放资源的主机在因特网中的域名 端口和路径：经常省略 2.超文本传送协议 HTTP为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息 2.1 使用HTTP的URL格式 上面URL的格式&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;中的协议部分，就可以选择HTTP协议。格式如下： 2.2HTTP 的报文结构 ：HTTP 有两类报文：请求报文——从客户向服务器发送请求报文、响应报文——从服务器到客户的回答。 （1）请求报文 报文格式： 方法：是面向对象技术中使用的专门名词。所谓“方法”就是对所请求的对象进行的操作，因此这些方法实际上也就是一些命令。因此，请求报文的类型是由它所采用的方法决定的。 URL：是所请求的资源的 URL。 版本：是 HTTP 的版本。 （2）响应报文 报文格式： 状态码：状态码都是三位数字 ，1xx 表示通知信息的，如请求收到了或正在进行处理；2xx 表示成功，如接受或知道了；3xx 表示重定向，表示要完成请求还必须采取进一步的行动；4xx 表示客户的差错，如请求中有错误的语法或不能完成；5xx 表示服务器的差错，如服务器失效无法完成请求。 短语：解释状态码的简单短语 3.用户点击链接后所发生的事件以在浏览器点击链接到百度的超链接为例 (1) 浏览器分析超链指向页面的 URL。 (2) 浏览器向 DNS 请求解析 www.baidu.com的 IP 地址。 (3) 域名系统 DNS 解析出百度服务器的 IP 地址。 (4) 浏览器与服务器建立 TCP 连接 (5) 浏览器发出取文件命令： GET /chn/yxsz/index.htm。 (6) 服务器给出响应，把文件 index.htm 发给浏览器。 (7) TCP 连接释放。 (8) 浏览器显示 index.htm 中的所有文本。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://tetedetian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"数据结构与算法题解","slug":"数据结构与算法题解","date":"2020-09-06T03:24:07.168Z","updated":"2021-03-31T07:50:55.808Z","comments":true,"path":"2020/09/06/数据结构与算法题解/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/","excerpt":"——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——","text":"——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释—— 一、字符串1.无重复字符的最长子字符串题目：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 : 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 解题思路： 思路很简单，就是从利用双指针+哈希表，先固定左指针，然后移动右指针，每次就判断右指针的字符是否存在于哈希表，不存在就把它投放到哈希表里，一直到到右指针碰到重复的字符，就记录左右指针之间不重复子串的长度。然后移动左指针，开始下一轮判断。 因为这是求最长子串的长度，自然子串的左端是字符串的其中一个字符，那我们不妨从第一个字符开始判断。 1.定义两个变量，记录子串的左端点和右端点，右端点不断往右移动，直到遇到与左右端点之间重复的字符为止。 2.用一变量num记录下两端点之间不重复的字符串长度（其实就是用右变量减左变量） 3.将左端点向右移动一个字符，右端点保持不动，然后又开始判断左右端点间有没有重复，重复就右移，和上面的一样，最后更新num。 题解： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; //哈希集合，存放字符，记录每个字符是否出现过 unordered_set&lt;char&gt; occ; //right记录右端点，设置初始值是0；num是记录最长子串长度的变量 int right=0,num=0; for(int i=0;i&lt;s.size();++i) &#123; if(i!=0) &#123; //左端点向右移动一格（也就是i加1），从哈希集合里移除s[i-1]（因为现在s[i-1]已经不在左右端点之间了） occ.erase(s[i-1]); &#125; /*!occ.count(s[right])如果是0，代表哈希集合里面有s[right]，则while&#123;&#125;里的代码不会运行，也就是不会往 里面添加字符。*/ while (right&lt;s.size()&amp;&amp; !occ.count(s[right])) &#123; //右指针往右移动了，往哈希集合里添加一个字符 occ.insert(s[right]); //右端点加1 ++right; &#125; //更新num num=max(num,right-i);//num是前面所有子串中最大值，right是此次左右端点之间的差，也就是此次子串长度 &#125; return num; &#125;&#125;; 2.最长回文子串题目：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 : 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路1： 使用动态规划,对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 ababa，如果我们已经知道 bab 是回文串，那么ababa一定是回文串，这是因为它的首尾两个字母都是 “a”。 根据这一思想总结： 1.我们可以把编程思路定为填写下面的表格的右上方（因为坐下方是非法的：右边界&lt;左边界），如果是回文串就填true（1），不是回文串就填false（0）。 2.因为ababa是不是回文的，可以根据bab 是不是回文串来决定，根据表格规律，可发现，某个空格应该填是1或0，是根据左下角来确定的。所以填表顺序应该是斜着来，从左上方斜往右下方。根据图表，可见斜线上的左右边界之间的差值是相等的。因此在写程序时，我们就可以先考虑填左右边界差值为0的，再到1的、2的。。。。 3.对角线都是只有一个字符，肯定是回文的，因此可以先全部填0。 根据上面的思路总结，可以得到下面的题解 题解： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string longestPalindrome(string s) &#123; int n=s.size();//n为输入字符串的长度 vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n));//定义一个二维数组dp，就是相当于上面的表格，用来存储判断结果的 string ans;//记录最终的返回结果 for(int l=0;l&lt;n;++l)//定义l来代表左右边界之间的差值（这一点在上面有解释为什么） &#123; for(int i=0;i+l&lt;n;++i)//i是左边界 &#123; //j是右边界 int j=i+l; //l==0也就是只有一个字符，肯定是回文的 if(l==0) &#123; dp[i][j]=1; &#125; //l==1，也就是只有两个字符，是不是回文的，判断两个字符是否相等即可 else if(l==1) &#123; dp[i][j]=(s[i]==s[j]); &#125; //其他的点，判断是不是回文的，就要回归上面说的，需要根据数据的左下角以及左右边界来判断。左下角为真，且左右边界相等，那么就是回文的（真），这个逻辑关系可以用与或关系来表示。 else &#123; dp[i][j]=(s[i]==s[j]&amp;&amp;dp[i+1][j-1]); &#125; //如果是回文的，长度（差值+1）又大于之前存储的ans的长度，就更新ans if(dp[i][j]&amp;&amp;(l+1)&gt;ans.size()) &#123; ans=s.substr(i,l+1); &#125; &#125; &#125; return ans; &#125;&#125;; 3.左旋转字符串题目： 把字符串前面的若干个字符转移到字符串的尾部 示例 1： 12输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出: &quot;cdefgab&quot; 示例 2： 12输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6输出: &quot;umghlrlose&quot; 思路： 直接利用string容器的一些操作函数。 题解： 123456789class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; string News(s);//创建新的string变量News，并调用有参构造，将s赋值给News News.erase(0,n);//删除News位置为0到n的字符 News.append(s,0,n);//将s的0到n字符串拼接到News后面 return News; &#125;&#125;; 4.翻转单词顺序题目： 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 示例： 示例 1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 思路: 1.先把字符串首尾的空格去除。因为c++没有去除首尾字符串的内置函数，可以采用定义左边界left和右边界right的方法。把空格排除在边界外。 2.利用双指针，从左到右寻找单词的左右节点。 3.每一次双指针找到边界后，将单词拼接到新字符串上，并且拼接空格 题解： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string reverseWords(string s) &#123; //left作为左端点，right作为右端点 int left = 0, right = s.size() - 1; // 去掉字符串开头的空白字符 while (left &lt;= right &amp;&amp; s[left] == ' ') ++left; // 去掉字符串末尾的空白字符 while (left &lt;= right &amp;&amp; s[right] == ' ') --right; //用来决定每次循环单词的边界的 int i=right; int j=i; string Newstr; while(i&gt;=left) &#123; //i向左移动，直到不是空格停止，也就是单词的右边界 while((i&gt;=left)&amp;&amp;(s[i]==' ')) &#123; i--; &#125; //把右边界赋值给j j=i; //i继续移动，直到碰到第一个空格的地方 while((i&gt;=left)&amp;&amp;(s[i]!=' ')) &#123; i--; &#125; //i+1到j就是单词，把s字符串从i+1位置起j-i个字符拼接到Newstr末尾 Newstr.append(s,i+1,j-i); //单词之间的空格 if(i&gt;=left) Newstr.append(\" \"); &#125; return Newstr; &#125;&#125;; 5.字符串转换整数题目： 实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 1.如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 2.假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 3.该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例： 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 123输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。 示例 4: 123输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 123输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 思路： 我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。 换个说法，就是我们可以这样操作：定义一个类，可以实现根据上次的状态以及输入字符来决定这次的状态。然后根据这次的状态来决定这次的操作。 根据问题的描述，可以得到各个状态遇到不同字符之后会转变到什么状态。 表示为图表，如下 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//定义一个自动机类class Automaton &#123; string state = \"start\";//状态 //定义一个unordered_map容器，键值为string类型，实值是vector类型。 unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123; &#123;\"start\", &#123;\"start\", \"signed\", \"in_number\", \"end\"&#125;&#125;, &#123;\"signed\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"in_number\", &#123;\"end\", \"end\", \"in_number\", \"end\"&#125;&#125;, &#123;\"end\", &#123;\"end\", \"end\", \"end\", \"end\"&#125;&#125; &#125;; //控制数值返回函数，会根据传递的字符参数返回对应的0-3控制数值（vector有四个元素） int get_col(char c) &#123; if (isspace(c)) return 0;//isspace（c）会检查c是不是空格 if (c == '+' or c == '-') return 1; if (isdigit(c)) return 2;//isdigit（c）会检查c是不是十进制数值1-9 return 3; &#125;public: int sign = 1;//决定正负的函数 long long ans = 0;//数值 void get(char c) &#123; state = table[state][get_col(c)];//根据字符c得到下一个状态 //如果状态是“in_number”的话，说明可以开始录入数字了 if (state == \"in_number\") &#123; ans = ans * 10 + c - '0';//c这时候还是字符，需要通过-‘0’来装换成整数 ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN); &#125; //判断正负 else if (state == \"signed\") sign = c == '+' ? 1 : -1; &#125;&#125;;class Solution &#123;public: int myAtoi(string str) &#123; Automaton automaton;//声明一个自动机对象 for (char c : str) &#123; cout&lt;&lt;c&lt;&lt;endl; automaton.get(c); &#125; return automaton.sign * automaton.ans; &#125;&#125;; 二、链表1.两数相加题目：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 &#x3D; 807 思路: 大体思路:其实很简单，就是和平时算数一样，从低位开始相加，然后定义变量记录每次相加的结果，再定义变量记录是由需要进位。并且定义新的节点类型记录每次的计算结果。 具体思路：定义新的头节点指针head，定义记录每次两数相加的和的变量sum，定义变量carry记录是否需要进位，定义一个节点指针指向新链表的尾部（保持指向尾部）（用于创建新的节点来存储数据）。 题解： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: /*定义一个addTwoNumber函数，参数类型是两个节点指针（节点是力扣系统自己定义好的了）*/ ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* head=new ListNode(-1);//定义一个名为head的头节点，节点值为-1，head-&gt;next=NULL ListNode* h=head;//定义一个移动指针 int sum;//用来记录每位的和 bool carry=0;//控制进位 while(l1!=NULL||l2!=NULL)//当l1或者l2为NULL的时候，已经没有数据了，自然需要停止了 &#123; sum=0;//每个循环都需要置零 if(l1!=NULL)//l1就是个指针，第一轮循环指向的就是例子中的2 &#123; sum+=l1-&gt;val;//就是sum=l1-&gt;val+sum l1=l1-&gt;next;//将l1指向下一个节点，下一个循环可以用 &#125; if(l2!=NULL) &#123; sum+=l2-&gt;val;//结合前面的if语句，这里其实sum=l1-&gt;val+l2-&gt;val l2=l2-&gt;next; &#125; if(carry) sum++;//carry是记录进位的，第一轮的话没有进位，carry就是初始值0 h-&gt;next=new ListNode(sum%10);//new ListNode(sum%10)开辟一个新节点，用来存储相加的结果 h=h-&gt;next;//把h指针=刚才开辟的节点的next指针，方便下个循环接着这次开辟节点继续开辟 carry=sum&gt;=10?true:false;//如果sum&gt;=10，carry=1，否则carry=0； &#125; /*这一步是在所有循环结束后的，如果最后carry=1，代表有进位，那么最高位应该增加一个1*/ if(carry) &#123; h-&gt;next=new ListNode(1); &#125; return head-&gt;next;//返回头节点 &#125;&#125;; 2.合并两个有序链表题目： 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路： 可以使用递归的方法，非常简单巧妙的解决问题：先定义两个指针，指向l1和l2的头部，然后判断l1和l2谁的的第一个元素更加小，然后使小的一方的next指向mergeTwoLists(小的一方-&gt;next,大的一方)。有点难说明白，看代码吧 题解： 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL)//判断l1是否为0，为0的话就直接返回l2 &#123; return l2; &#125; else if(l2==NULL) &#123; return l1; &#125; else if (l1-&gt;val&lt;l2-&gt;val)//判断大小 &#123; l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);//使用递归 return l1;//因为这里是l1-&gt;val&lt;l2-&gt;val，所以l1才是头结点 &#125; else &#123; l2-&gt;next=mergeTwoLists(l1,l2-&gt;next); return l2; &#125; &#125;&#125;; 3.反转链表题目： 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路： 使用递归的思想。题目的解决可以分为两个问题：1.找到反转后的头节点，也就是反转前的尾节点。2.将链表反转。 题解： 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; /*head == NULL的情况时链表本来就是空的情况。head-&gt;next == NULL是到了最后一个节点的情况，例如例子中的5。还有就是下面会使用递归，这个条件就代表已经递归到最后一个节点了*/ if (head == NULL || head-&gt;next == NULL) return head; ListNode* Newhead = reverseList(head-&gt;next);//定义一个名为Newhead的ListNode类型指针来作为新链表的头节点。 head-&gt;next-&gt;next = head;//反转操作。在第一轮了，head就是4的节点。那head-&gt;next-&gt;next其实就是5-&gt; head-&gt;next = NULL; return Newhead;//返回新链表的头节点。这里的p，其实在递归的最深层已经决定了，就是5的节点。&#125;&#125;; 4.两两交换链表中的节点题目： 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例： 示例 1： 12输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head &#x3D; []输出：[] 示例 3： 12输入：head &#x3D; [1]输出：[1] 提示： 12链表中节点的数目在范围 [0, 100] 内0 &lt;&#x3D; Node.val &lt;&#x3D; 100 思路： 思路其实就是，每两个节点为一次操作。比如1-&gt;2-&gt;3-&gt;4，就要想办法将2-&gt;1,1-&gt;4,4-&gt;3。那就可以分解为。 1.定义两个节点指针指向1,2，然后操作2-&gt;1,1-&gt;3。 2.定义一个指针来指向1,到下一轮就操作这个指针的next指向新一轮的节点2。 3.重新head的指向。（head是用来判断是否到结尾以及确定下一轮节点指针1,2的指向的） 题解： 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head;//判断是否为空表，没有这句的话，一旦是空表，下面的head-&gt;next就不存在了，会报错 ListNode* Newhead = head-&gt;next;//建立Newhead，指向第二个节点，后面不再改变Newhead，最后直接返回Newhead就可以 ListNode* curr = head;//curr是用来指向每次换两两节点后排后面的节点，为了使得上一轮交换后排后面的节点能够指向正确的节点。在第一第二轮中，就是为了使得1能够指向4。 while(head != NULL &amp;&amp; head-&gt;next != NULL) &#123; //新建两个节点指针firstNote和secondNode,用于改变节点指向。 ListNode* firstNode = head;//节点指针1指向每两个节点的第一个 ListNode* secondNode = head-&gt;next;//节点指针2指向每两个节点的第二个 curr-&gt;next=secondNode;//把上一轮交换后的后面节点指向新的节点2 firstNode-&gt;next = secondNode-&gt;next;//指向节点2的next（这只是为了后面重新安排新的head） secondNode-&gt;next = firstNode; curr = firstNode;//回归curr的作用，curr自然是等于firstNode，因为firstNode排后面 head = firstNode-&gt;next;//重新安排下一轮的head &#125; return Newhead;//Newhead就是指向第二个节点的指针，在第一轮就决定了 &#125;&#125;; 5.删除链表中的节点题目： 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。 示例： 示例 1: 123输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head &#x3D; [4,5,1,9], val &#x3D; 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 思路： 定义一个节点指针，然后使得指针逐一递增，并且判断，如果遇到要删除的节点的话就把需要删除的节点前一节点的指针指向下一节点。最后依旧返回head 题解： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; ListNode* p1=head; if(head-&gt;val==val) return head-&gt;next;//判断是不是第一个节点就是要删除的节点。 while(p1-&gt;next!=NULL) &#123; if(p1-&gt;next-&gt;val==val) &#123; p1-&gt;next=p1-&gt;next-&gt;next;//把需要删除的节点前一节点的指针指向下一节点 return head; &#125; p1=p1-&gt;next; &#125; return head; &#125;&#125;; 6.从尾到头打印链表题目： 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 ： 12输入：head &#x3D; [1,3,2]输出：[2,3,1] 思路： 可以利用递归，从最后一个节点逐一插入到一个数组里 题解： 12345678910class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; &#x2F;&#x2F;利用递归，从尾部往回，每次往vector&lt;int&gt;类型的a插入元素，最后就得到结果了 if(!head) return &#123;&#125;; vector&lt;int&gt; a&#x3D;reversePrint(head-&gt;next); a.push_back(head-&gt;val);&#x2F;&#x2F;push_back(val)，尾部插入元素val return a; &#125;&#125;; 7.两个链表的第一个公共节点。题目： 输入两个链表，找出它们的第一个公共节点。 示例： 返回c1 思路： 使用双指针法：定义指针p1指向链表A的头部，指针p2指向链表B的头部。然后两个逐一往后移动，同时判断两个指针是否相等。p1移动到A尾部后，就从B头部开始继续移动。同样，p2移动到B尾部后，就从A头部继续移动。这样，在下一轮两个指针就会在交点相遇。 题解： 12345678910111213class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* p1=headA;//定义指针p1 ListNode* p2=headB;//定义指针p2 while(p1!=p2)&#123; p1=(p1!=NULL?p1-&gt;next:headB);//语句的意思：如果p1！=NULL成立，p1=p1-&gt;next,否则p1=headB p2=(p2!=NULL?p2-&gt;next:headA); &#125; return p1; &#125;&#125;; 8.链表中倒数第k个节点题目： 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5. 思路： 定义一个全局变量num，然后利用递归，递归操作为触底反弹后num++，如果num&lt;=k,就返回head 9.复杂链表的复制题目： 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例： 思路： （1）迭代 1.先依次把每个节点拷贝并且插入到与下一个节点的中间。2.再给每个拷贝的节点的random赋值（因为新节点之间都是隔着一个旧节点，间隔是固定的，每次走两步，就能操作到每个新节点）。3.把新旧节点之间的next指向正确的节点。 题解： （1）迭代 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head==NULL) return NULL;//如果是空表，直接返回NULL Node* cur=head;//用来迭代操作的节点指针 /*1.把每个节点拷贝并且插入到与下一个节点的中间*/ while(cur!=NULL) &#123; Node* Newnode=new Node(cur-&gt;val);//创建一个节点指针，指向新创立的节点 //新节点插入操作 Newnode-&gt;next=cur-&gt;next; cur-&gt;next=Newnode; //重新赋值cur cur=cur-&gt;next-&gt;next; &#125; /*2.拷贝新链表的random*/ cur=head;//重新使cur回到头部 while(cur!=NULL) &#123; //拷贝random。注意：cur-&gt;random可能是NULL（是NULL的话，就不存在cur-&gt;random-&gt;next了）。因此必须添加对cur-&gt;random是否等于NULL的判断。 cur-&gt;next-&gt;random=(cur-&gt;random!=NULL)?cur-&gt;random-&gt;next:NULL; //对下一轮cur进行赋值 cur=cur-&gt;next-&gt;next; &#125; /*3.调整每个节点的next*/ Node* Newhead=head-&gt;next;//新链表的头结点 Node* pur; cur=head; while(cur-&gt;next!=NULL) &#123; pur=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; cur=pur; &#125; return Newhead; &#125;&#125;; 三、数组1.两数之和题目： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 123给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 思路： （1）暴力法 暴力法很简单。就是不断地枚举nums中的元素，看看哪两个元素加起来等于target。 （2）哈希表 利用哈希表，存储数组的元素以及对应的下标。然后检查数组的每一个元素x对应的target-x能否在哈希表里面找到。找到的话，数组元素对应的下标和哈希表元素对应的键值就是所求。（其实就是双数组思想） 暴力法题解： 哈希表解法： 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hashtable;//定义一个哈希表 for (int i = 0; i &lt; nums.size(); ++i) &#123; auto it = hashtable.find(target - nums[i]);//在哈希表里面寻找符合target-x的数，赋值给it if (it != hashtable.end())//如果it != hashtable.end()，也就是哈希表里面存在target-x的数 &#123; return &#123;it-&gt;second, i&#125;;//那么返回&#123;it-&gt;second, i&#125;，it-&gt;second是迭代器指向对应的值 &#125; hashtable[nums[i]] = i;//给哈希表赋值（注意，这题解是把nums数组的值赋给哈希的键值。（因为题目说明数组元素不会重复，这倒是无所谓）） &#125; return &#123;&#125;; &#125;&#125;; 2.数组中重复的值题目： 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 ： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 思路： 使用迭代，i=0到i&lt;nums.size(),判断nums[i]是否等于nums[nums[i]],等于的话，说明nums[i]肯定重复了。不等于的话，就把nums[i]放到nums[nums[i]]的位置。这样不断迭代下去，数值i就会不断被放到数组下标为i的位置。这样下去，当重复的数字被第二次归位，就会发现它的位置以及有“它”了，也就是nums[i]等于nums[nums[i]]。那么它就是要找的结果之一。 换个简单的描述就是，从头到尾，把数组的值nums[i]归位到数组下标为nums[i]的位置。 题解： 12345678910111213141516171819class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; for(int i=0;i&lt;nums.size();i++) &#123; while(nums[i]!=i) &#123; //判断nums[i]是否等于nums[nums[i]]，等于的话，说明nums[i]肯定重复了 if(nums[i]==nums[nums[i]]) return nums[i]; //如果上面判断不成立，就把nums[i]的值与nums[nums[i]]交换 int temp; temp=nums[nums[i]]; nums[nums[i]]=nums[i]; nums[i]=temp; &#125; &#125; return -1; &#125;&#125;; 2.三数之和题目： 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ，请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路： 为了避免重复，先将数组排序，然后开始三循环。在第一循环内（也就是a固定了）其实问题就有点类似两数之和了，target就是0-a。不过不同的是两数之和是没有重复的，所以符合条件的只有一个结果。因此，三数之和可以采用：第二第三循环使用双指针，一个指向循环的头，一个指向循环的尾，然后判断两者相加，如果大于0-a，就尾指针往回移，如果小于0-a，就头指针往后移动，这样可以避免重复枚举。另外，指针移动的时候，也需要判断移动前后指针指向的值是否相等，相等的话就直接跳过。 四、哈希表1.第一个只出现一次的字符题目： 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例： 12345s &#x3D; &quot;abaccdeff&quot;返回 &quot;b&quot;s &#x3D; &quot;&quot; 返回 &quot; &quot; 思路： 建立一个哈希表dic，以字符作为键值。然后遍历字符串s，如果如果哈希表里能找到这个字符，就把此字符对应的数值改为0，找不到就赋值1。这样遍历一遍下来，重复的就会被赋值0，不重复的就是被赋值1。然后再遍历一次，找到第一个数值是1的就可以。 题解： 12345678910111213class Solution &#123;public: char firstUniqChar(string s) &#123; unordered_map&lt;char, bool&gt; dic; //调用dic.find(c),如果在dic中找不到c，就会返回dic.end()。因此这一个for循环之后，重复字符在哈希表中对应的值都会变成0 for(char c : s) dic[c] = dic.find(c) == dic.end(); //继续迭代判断，只要遇到dic[c]是1，就说明没有重复 for(char c : s) if(dic[c]) return c; return ' '; &#125;&#125;; 2.无重复字符的最长子字符串和字符串的第一题一样。 3.宝石与石头题目： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。 简单来说，就是给定字符串J和S，输出S中可以在J找到的字符的数目 示例： 示例 1: 12输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 思路： 定义用于记录输出的整数num，再把J的字符存到哈希表中，然后再遍历S的字符，并且判断每个字符是否能够在哈希表里找到，找到就num++ 题解： 1234567891011121314151617class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; unordered_set &lt;char&gt; gemstone; int num=0; //把J的字符存到哈希表里 for(char c:J) gemstone.insert(c); //遍历S，检查每个字符在哈希表里是否存在 for(char c:S) &#123; if(gemstone.find(c)!=gemstone.end()) num++; &#125; return num; &#125;&#125;; 五、二叉树1.翻转二叉树题目： 翻转一颗二叉树 示例： 输入： 12345 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9 输出： 12345 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 思路： 利用递归 题解： 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; //递归终止条件：如果传入的根节点为空 if (root == nullptr) &#123; return nullptr; &#125; //递归 TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); //每次递归的需要进行的操作。在这题，就是将两个子节点位置互换 root-&gt;left = right; root-&gt;right = left; //返回跟节点 return root; &#125;&#125;; 2.合并二叉树题目： 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 ： 1234567891011121314输入: Tree 1 Tree 2 1 2 &#x2F; \\ &#x2F; \\ 3 2 1 3 &#x2F; \\ \\ 5 4 7 输出: 合并后的树: 3 &#x2F; \\ 4 5 &#x2F; \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。**** 思路： 利用深度优先遍历两个二叉树，同时不断构造需要输出的二叉树节点 题解： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; //判断t1或者t2有没有空节点，有的话就输出另一个节点 if (t1 == nullptr) &#123; return t2; &#125; if (t2 == nullptr) &#123; return t1; &#125; //创立新的节点，并且把t1和t2的值相加赋给新节点 auto merged = new TreeNode(t1-&gt;val + t2-&gt;val); //使用递归 merged-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); merged-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return merged; &#125;&#125;; 3.二叉树的最大深度题目： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 1234567给定二叉树 [3,9,20,null,null,15,7]， 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回它的最大深度 3 。 思路： 使用递归。建立一个函数，给出一个根节点，就可以返回根节点的最大深度 题解： 1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==nullptr) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;; 4.将有序数组装换为二叉搜索树题目： 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 思路： 因为需要高度平衡，而且数组时升序的，因此可以将数组的中间节点作为根节点。然后继续把数组中间节点左右两边的数据作为树的左子树根节点以及右子树根节点。因此，可以使用递归的方法，不断把数组的元素填充到二叉搜索树中。 题解： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums,0,nums.size()-1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums,int left,int right) &#123; //递归结束 if(left&gt;right) return nullptr; //这里因为(left+right)可能是奇数或者偶数，因此这里mid的处理，会导致树的不同。比如当(left+right)奇数时，会有两个数组元素处于中间位置，选择左边的还是右边的，会导致树不同。在下面这个写法里，因为int类型会向下取整，所以取的是左边的。如果想取右边的，可以写int mid=(left+right+1)/2 int mid=(left+right)/2; //new新的节点，并且把数组下标为mid的元素赋值给节点。 TreeNode* root=new TreeNode(nums[mid]); //利用递归，返回左右字数的节点 root-&gt;left=helper(nums,left,mid-1); root-&gt;right=helper(nums,mid+1,right); return root; &#125; &#125;; 5.二叉树的中序遍历题目： 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例： 12输入：root &#x3D; [1,null,2,3]输出：[1,3,2] 思路： 思路其实很简单，利用递归算法中序遍历 题解： 123456789101112131415161718class Solution &#123;public: //定义一个函数，输入树的根节点以及空数组。在空数组中输出树的中序遍历 void inorder(TreeNode* root,vector&lt;int&gt;&amp; nums) &#123; if(root==nullptr) return; //中序遍历的算法。在两个递归之间进行操作。 inorder(root-&gt;left,nums); nums.push_back(root-&gt;val); inorder(root-&gt;right,nums); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nums; inorder(root,nums); return nums; &#125;&#125;; 6.不同的二叉搜索树题目： 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例： 12345678910输入: 3输出: 5解释:给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 思路： 可以看成一个数学问题。 首先，我们假设，给定整数n，会有G（n）种可能。分解来看，1~n，每个整数都可以作为根节点。 找规律： 比如节点1作为根节点，那么左子树剩下0个整数，也就只有G（0）种可能，右子树剩下2~n，共n-1个整数，就是有G（n-1）种可能。那么两个相乘，就是总的可能，即G（0）*G（n-1）。 那么节点2作为根节点，那么左子树剩下1个整数，也就只有G（1）种可能，右子树剩下3~n，共n-2个整数，就是有G（n-2）种可能。那么两个相乘，就是总的可能，即G（1）*G（n-2）。 其实已经可以发现规律，即当整数i（1=&lt;i&lt;=n）作为节点时，会有G（i-1）*G（n-i）种可能。那么，当给出整数1~n，总的可能如下 可以发现G（n）的值与G(0)~G（n-1）有关。而根据实际情况，我们可以知道，G（0）=0，G(1)=1。只要我们利用上面的公式，迭代从G（2）一直计算到G（n），就可以得到G（n）的值。 题解： 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; G(n+1,0); G[0]=1; G[1]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) &#123; G[i]+=G[j-1]*G[i-j]; &#125; return G[n]; &#125;&#125;; 7.不同的二叉搜索树II题目： 给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 示例： 1234567891011121314151617输入：3输出：[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\ 2 1 2 3 思路： 大体思路：使用递归，定义一个函数，只要传入两个整数start和end，就会返回两整数之间元素能组成的所有二叉搜索树。 细致思路：可以使用迭代，把逐一把整数i作为根节点。然后starti-1作为左子树的节点，i+1end作为右子树节点。此时，就可以使用递归，把start和i-1作为参数递归，i+1和end作为参数递归 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int start,int end) &#123; if(start&gt;end) return &#123;nullptr&#125;; //定义一个节点数组，用来存储结果 vector&lt;TreeNode*&gt; allTrees; //迭代，把start和end之间的每个节点轮流作为根节点 for(int i=start;i&lt;=end;i++) &#123; //定义左子树数组，并且使用递归得到结果 vector&lt;TreeNode*&gt; leftTrees=generateTrees(start,i-1); //定义右子树数组，并且使用递归得到结果 vector&lt;TreeNode*&gt; rightTrees=generateTrees(i+1,end); //使用双层迭代，从左子树和右子树数组中逐一抽取子树进行组合，两个迭代完成后，就列举了所有此层递归左右子树数组的组合情况 for(auto&amp; left:leftTrees) for(auto&amp; right:rightTrees) &#123; TreeNode* currTree=new TreeNode(i);//将此时的根节点的值赋值给一个新节点 currTree-&gt;left=left; currTree-&gt;right=right; allTrees.push_back(currTree);//将组合完成的二叉搜索树假如到allTrees中。这里的allTrees，当递归往回退一层时，也就是被赋值到leftTrees或者rightTrees了 &#125; &#125; return allTrees; &#125; vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n==0) return&#123;&#125;; return generateTrees(1,n); &#125;&#125;; 8.对称二叉树题目： 给定一个二叉树，检查它是否是镜像对称的。 示例： 123456789101112131415例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 &#x2F; \\ 2 2 \\ \\ 3 3 思路： 定义两个节点指针p1和p2，然后使用递归，不断判断拍p1-&gt;val是否等于p2-&gt;val。 整理成写代码思路，就是定义一个递归函数，输入参数类型是两个节点指针类型，函数会对p1-&gt;val是否等于p2-&gt;val进行判断。然后再递归p1的左节点与p2的右节点，以及p1的右节点与p2的左节点。因为需要每一次判断都是true， 题解： 123456789101112131415161718class Solution &#123;public: bool check(TreeNode* p1,TreeNode* p2) &#123; //针对p1、p2都是指向空节点的情况，这时候应该返回true if(p1==nullptr&amp;&amp;p2==nullptr) return true; //针对p1、p2有其中一个指向空节点，但是有一个不是空的。这时候明显不对称了，应该返回false if (!p1 || !p2) return false; //判断p1-&gt;val==p2-&gt;val，以及递归操作 return p1-&gt;val==p2-&gt;val&amp;&amp;check(p1-&gt;left,p2-&gt;right)&amp;&amp;check(p1-&gt;right,p2-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return check(root,root); &#125;&#125;; 六、堆七、动态规划1.爬楼梯问题题目：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例： 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1 阶 + 1 阶2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1 阶 + 1 阶 + 1 阶1 阶 + 2 阶2 阶 + 1 阶 思路： 简单题解：根据规律，可以知道n级台阶可以通过n-1级爬1级到达，或者n-2级爬2级到达。也就是发f(n)=f(n-1)+f(n-2)，那么就可以使用动态规划，依次把f(1)到f(n)算出来，就可以得到答案。 题解： 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; int a&#x3D;0,b&#x3D;1,c&#x3D;0; for(int i&#x3D;0;i&lt;n;i++) &#123; c&#x3D;a+b; a&#x3D;b; b&#x3D;c; &#125; return c; &#125;&#125;; 2.最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 思路： 使用动态规划。 因为只可以往右移或者网下移动。那么容易知道， 第一行的状态转移方程是 1dp[i][j]&#x3D;grid[i][j]+dp[i][j-1] 第一列的状态转移方程是 1dp[i][j]&#x3D;grid[i][j]+dp[i-1][j] 其他的状态转移方程 1dp[i][j]&#x3D;grid[i][j]+min(dp[i-1][j],dp[i][j-1]) 题解: 1234567891011121314151617181920212223class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.size()==0||grid[0].size()==0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(grid);//定义一个数组存储结果 int rows=grid.size(),columns=grid[0].size();//获取输入的行数和列数 //算第一列的dp,i从1开始是因为 for (int i = 1; i &lt; rows; i++) &#123; dp[i][0] = dp[i - 1][0] + grid[i][0]; &#125; for (int j = 1; j &lt; columns; j++) &#123; dp[0][j] = dp[0][j - 1] + grid[0][j]; &#125; for (int i = 1; i &lt; rows; i++) &#123; for (int j = 1; j &lt; columns; j++) &#123; dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[rows - 1][columns - 1]; &#125;&#125;; 八、排序简单常见的有冒泡排序，选择排序，快速排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;using namespace std;/*冒泡排序*/void bubblesort(int arr[], int len)&#123; int temp; for(int i=0;i&lt;len-1;i++) for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1])//这里使用大于号的话，就是升序排序 &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;/*选择排序*/void selectsort(int arr[], int len)&#123; int temp; for (int i = 0; i &lt; len - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[min]) min = j; &#125; temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125;&#125;/*快速排序*/void quicksort(int arr[], int left, int right)&#123; if (left &gt; right) return; int i, j, datum, temp;//datum就是基准的数 i = left; j = right; datum = arr[left];//一般最开始取首项为基准 while (i!=j) &#123; while (arr[j] &gt;= datum &amp;&amp; i &lt; j) j--;//j从最右边开始往左移动，遇到小于基准数就停下 while (arr[i] &lt;= datum &amp;&amp; i &lt; j) i++;//i从最左边往右移动，遇到大于基准数的就停下 //交换arr[i]和arr[j],因为快速排序的思想就是把小于基准的放左边，大于的放右边。 if (i &lt; j) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; //把这一轮停下来的arr[i]与datum交换。因为这时候arr[i]是比datum小的。 arr[left] = arr[i];//交换一轮后，arr[i]的值会小于datum（自己操作下试试） arr[i] = datum; quicksort(arr, left, i - 1); quicksort(arr, i + 1, right);&#125;int main()&#123; int a[] = &#123; 3,1,6,8,2,5,4,9,7 &#125;; int len = size(a); selectsort(a, len); //bubblesort(a, len); //quicksort(a, 0, len-1); for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 九、贪心算法1.买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 思路： 既然可以无数次买入卖出，那么我每次买入卖出的时间间隔选择最小的时间间隔：1天，然后只要每次买入卖出的收益大于0，最终总的收益肯定是最大的 题解： 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n=prices.size(),result=0; for(int i=0;i&lt;n-1;i++) &#123; result+=max(0,prices[i+1]-prices[i]); &#125; return result; &#125;&#125;; 2.分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 123456输入: g &#x3D; [1,2,3], s &#x3D; [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g &#x3D; [1,2], s &#x3D; [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 思路：把饼干从大到小分别分配给胃口大到小的人，换句话说就是“尽量不浪费饼干”，只要每次分配都是“最不浪费饼干”的做法，最后也会满足最多的孩子。这也是贪心算法的思想。 题解： 12345678910111213141516class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; // 饼干数组的下标 int result = 0; for (int i = g.size() - 1; i &gt;= 0; i--) &#123; if (index &gt;= 0 &amp;&amp; s[index] &gt;= g[i]) &#123; result++; index--; &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"操作系统基本知识点","slug":"操作系统基本知识","date":"2020-09-06T03:24:07.139Z","updated":"2021-04-10T05:56:07.169Z","comments":true,"path":"2020/09/06/操作系统基本知识/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"————这里，有操作系统的一些基础知识点^_^————","text":"————这里，有操作系统的一些基础知识点^_^———— 前言操作系统是什么： 操作系统（Operating System， OS） 是指控制和管理整个计算机系统的硬件和软件资源， 并合理地组织调度计算机的工作和资源的分配； 以提供给用户和其他软件方便的接口和环境； 它是计算机系统中最基本的系统软件。 一、操作系统基本知识1.1 操作系统特征 并发性 指两个或多个事件在同一时间间隔内发生。 这些事件宏观上是同时发生的， 但微观上是交替发生的。常考易混概念——并行： 指两个或多个事件在同一时刻同时发生。 比如，单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行。多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 共享性 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 共享性和并发性联系密切。如果没有并发性，也就是没有并发需求，那么共享性就失去了意义。如果没有共享性，那么并发性也无法实现。 虚拟性 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上 对应物（后者）是用户感受到的。 异步性 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 就好比如一个程序需要使用摄像头，但是另外一个程序也需要使用摄像头，但是因为摄像头已经被第一个程序使用了，第二个程序就要等待第一个程序使用完摄像头再使用。这就是异步。 1.2 OS的发展与分类 1.3 OS的运行机制和体系结构 1.4 中断与异常中断的作用：“中断” 会使CPU由用户态变为内核态， 使操作系统重新夺回对CPU的控制权 。如果没有“中断” 机制， 那么一旦应用程序上CPU运行， CPU就会一直运行这个应用程序 。那么就实现不了并发。 内核态和用户态之间切换： 内核态-&gt;用户态： 执行一条特权指令——修改PSW的标志位为“用户态” ， 这个动作意味着操作系统将主动让出CPU使用权用户态-&gt;内核态： 由“中断” 引发， 硬件自动完成变态过程， 触发中断信号意味着操作系统将强行夺回CPU的使用权 中断的分类： 1.内中断：与当前执行的指令有关，中断信号来源于CPU内部 。例子：有时候应用程序想请求操作系统内核的服务， 此时会执行一条特殊的指令——陷入指令， 该指令会引发一个内部中断信号 2.外中断：与当前执行的指令无关，中断信号来源于CPU外部 例子：时钟中断——由时钟部件发来的中断信号 异常：内中断一般称为“异常” 。狭义的中断， 是指外中断 1.5 系统调用系统调用含义：“系统调用” 是操作系统提供给应用程序（程序员/编程人员） 使用的接口。可以理解为一种可供应用程序调用的特殊函数， 应用程序可以通过系统调用来请求获得操作系统内核的服务 。 作用：通过系统调用的方式向操作系统内核提出服务请求， 由操作系统内核代为完成。 这样可以保证系统的稳定性和安全性， 防止用户进行非法操作。 换个通俗点的说法，就是电脑会有很多应用程序，它们可能在同一段时间内对一个有限的系统资源有使用需求，就如这时候没有系统调用这个机制，那么它们就会争夺资源，导致十分混乱，任务无法正常执行。 系统调用过程：传入参数—&gt;执行陷入指令（也称为trap指令或者访管指令）(此时处于用户态)—&gt;由操作系统内核程序处理系统调用请求—&gt;返回应用程序 二、进程2.1 进程的基本概念进程的概念：程序的一次执行过程 ，进程是资源分配的基本单位 。（同一个程序多次执行会对应多个进程 ） 进程和程序的区别：程序是静态的， 就是个存放在磁盘里的可执行文件， 就是一系列的指令集合。 进程（Process）是动态的， 是程序的一次执行过程 进程的组成： 1.PCB（进程控制块）：包含着进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。（PCB是进程存在的唯一标志， 当进程被创建时， 操作系统为其创建PCB， 当进程结束时， 会回收其PCB。） 2.程序段：程序的代码 3.数据段：运行过程中产生的各种数据（如程序的定义的变量） 进程的特征： 1.动态性:进程是程序的一次执行过程，是动态地产生、变化和消亡的。(动态性是进程最基本的特征 ) 2.并发性：内存中有多个进程实体，各进程可以并发执行 3.独立性：进程是能独立运行，独立获得资源、独立接受调度的基本单位 4.异步性：各进程按各自独立的，不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步的问题 5.结构性:每个进程都会配置一个PCB。结构上，进程由程序段，数据段，PCB组成。 2.2 进程的状态及转换进程的基本状态： 1.运次态：占用CPU，并在CPU上运行 2.就绪态：以及具备运行条件，但由于没有空闲的CPU，而暂时不能运行。 3.阻塞态：因等待某一事件而暂时不能运行。（比如等待分配打印机、等待读磁盘操作的结果等。这是进程会暂时转换到阻塞态） （另外还有创建态：操作系统为新的进程分配资源，创建PCB。终止态：操作系统回收进程的资源，撤销PCB） 进程状态的转换： 2.3 进程控制作用：进程控制就是要实现进程状态转换 如何实现进程控制：用原语实现进程的控制。（原语执行期间不允许中断） 控制原语要做的三类事情： 更新PCB中的信息 将PCB插入合适的队列 分配/回收资源 比如进程切换原语需要做的事情：1.将运行环境信息存入PCB（为了下次恢复这个进程做准备）。2.PCB移入相应队列。3.选择另一个进程执行，并更新其PCB。4.根据PCB恢复新进程需要的运行环境。 2.4 进程通信1.共享存储 设置一个共享空间，两个进程需要互斥地访问共享空间。 两种方式：（1）基于数据结构。（2）基于存储区的共享 2.管道通信 设置一个特殊的共享文件（管道），其实就是一个缓冲区。 一个管道只能实现半双工通信。也就是一个管道只可以实现从一个方向写操作，在另一个方向读操作。各进程也要互斥访问管道。 管道写满时不能再写、读空时不能再读、没写满不能读、没读完不能写 3.消息传递 传递结构化的信息。 两种方式：（1)直接通信方式：信息直接挂到接收方的消息队列。（2）间接通信方式：消息先发送到中间体（信箱） 三、线程3.1 线程的基本概念线程可以理解为轻量级进程。比如qq可以同时视频聊天，同时文字聊天，就是使用了线程并发。 为什么需要线程： 为什么需要线程？我不可以多个进程并发吗。可以是可以，但是进程间的并发开销更大。前面有说过进程是资源分配的基本单位，也是CPU调度的基本单位，多进程的创建涉及到资源的分配，进程之间的切换也会需要保存、恢复运行环境等较大的开销。引入线程后，线程是CPU调度的基本单位，资源分配的基本单位依旧是进程。同一进程内的各个线程间并发， 不需要切换进程运行环境和内存地址空间，省时省力 引入线程带来的变化： 资源分配、调度的基本单位改变。 线程间也可以并发，提高了并发度 系统开销变小 多线程模型： 1.多对一模型： 优点：进程管理开销小，效率高。（因为线程切换在用户态就可以搞定） 缺点：并发度低，假如一个线程被阻塞，整个进程都被阻塞 2.一对一模型： 优点：各线程可以分配到多核处理机中并行执行。（比如这幅图，就可以分配给三个处理机） 缺点：进程管理开销大。（一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成， 需要切换到核心态， 因此线程管理的成本高， 开销大。 ） 3.多对多模型： 优点：集前两者的优点 缺点：实现相对复杂 四.调度4.1 进程调度基本概念：按某种算法选择一个进程将处理机分配给它 三个层次： 1.高级调度：从后备队列中选择合适的作业将其调入内存，并为其创建进程。 2.中级调度：从挂起队列中选择合适的进程将其数据调回内存。 3.低级调度：从就绪队列中选择一个进程为其分配处理机。 进程调度的一个重要知识点：进程的调度，切换是有代价的，并不是调度越频繁，并发度越高。 4.2 调度算法的评价指标（1）cpu利用率 利用率=忙碌的时间/总时间 （2）系统吞吐量 单位时间内完成的作业的数量 系统吞吐量=完成作业的数量/完成作业的总时间 （3）周转时间 作业被提交给系统开始，到作业完成为止的这段时间间隔。 带权周转时间：作业周转时间/作业实际运行的时间。 （4）等待时间 指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低 （5）响应时间 从用户提交请求到首次产生响应所用的时间 4.3 几种调度算法（1）FCFS（先来先服务，first come first serve） 非抢占式算法 类似我们生活中排队买东西，按照到达时间顺序来处理。属于非抢占式的算法。 优点：公平、算法实现简单 缺点：对于短作业不利。举个例子，排队买奶茶，如果你只需要买一杯奶茶，但是你前面的一位顾客需要买20杯奶茶。这时候，如果采用FCFS，那么你就要等前面那个人买完20杯奶茶才可以。所以，这种算法对短进程并不友好。 （2）SJF（短作业优先，shortest job first) 非抢占式算法 简单来说，就是如果同时有几个进程在等待处理机，那么使用处理机时间短的作业就会优先分配处理机。用回奶茶的例子就是，假如奶茶店先后来了三个人，分别买3,2,1杯奶茶，老板在选择时就会优先选择先做需要买1杯的那个人的。 注意：一般来说，短作业优先算法也是非抢占式的，但是，也会有抢占式的短作业优先算法。就是会判断正在进行的作业剩余时间和正在等待的作业需要的时间哪个更短，更短的就会优先。比如你去买3杯奶茶，你的做好一杯后，来了个买1杯的，按照这个算法，老板就会暂时停止做你的奶茶，去做那个人的一杯奶茶。 优点：可以降低总体的等待时间，对短作业友好 缺点：对长作业不友好，长作业容易出现饥饿甚至”饿死” （3）HRRN（高响应比优先，highest response ratio next） 非抢占式算法 这个算法，综合了前面两个算法的优点。采用了根据响应比来决定分配处理机的方法。 响应比=（等待时间+要求服务时间）/要求服务时间。高响应的进程优先。这样的算法的好处在于，如果两个进程要求服务时间相等，那么等待时间长的进程响应比就会大，就会被优先分配，符合FCFS的优点。如果两个进程的等待时间相等，那么要求服务时间短的进程响应比就会大，就会优先分配，符合SJF的优点。 (4）时间片轮转 就是设定好单位时间片的时间，进程在处理机上执行一个时间片之后就会被强制抢夺处理机，这时候若进程还没处理完，就需要回到就绪队列重新排队，并且将进程剩余服务时间作为要求服务时间。 优点：公平，响应快，适用于分时操作系统，不会导致饥饿。 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度。 （5）优先级调度算法 每个作业/进程有各自的优先级，按照优先级来调度。 通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程。 优点：可以用优先级区分紧急程度，重要程度，适用于实时操作系统。可以灵活地调整各进程。 缺点：如果源源不断地有高优先级的进程到来，可能会导致饥饿。 （6）多级反馈队列 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第1级队列，若时间片用完进程还未结束，则进程进入下一级队列的队尾。只有第k级队列为空时，才会为k+1级队头的进程分配时间片用于进程调度。 优点：结合了前面几种算法的优点 缺点：可能会导致饥饿的 五、进程同步、进程互斥5.1 基础概念进程同步：并发性带来了异步性，有时候需要通过进程同步来解决这种异步问题。比如在管道通信中，写操作一定要在读操作之前，这就需要进程同步机制来调节。 进程互斥：对临界资源的访问，需要互斥地进行，同一时间段内只允许一个进程访问该资源。 进程互斥需要遵循的原则： 1.空闲让进：临界区空闲时，应允许一个进程访问。 2.忙则等待：临界区正在被访问时，其他视图访问的进程需要等待。 3.有限等待：要在有限时间内进入临界区，保证不会饥饿 4.让权等待：进不了临界区的进程，要释放处理机，防止忙等。 根据这四个原则，可以判断一个进程互斥方法是否可靠，可靠的方法需要满足这四个原则 5.2 进程互斥的软件实现方法（1)单标志法 设置一个变量，假设为turn，用turn的值来决定允许进入临界区的进程。伪代码如下 存在问题：假如turn=0，说明P0进程被允许访问临界区，但是如果P0又一直不进入临界区，那么其他进程也无法访问临界区，因为谁能访问临界区需要靠P0进程的语句3来决定。也就是违反了“空闲让进”原则。 （2）双标志先检查法 设置一个数组，里面存着各个进程的标志值，1代表想进入临界区，0代表不想进入。一个进程想进入临界区之前，会想检查其他进程的标志值是否全为0，全是0的情况先，进程才会申请修改自己的标志位为1，来表示自己想进入临界区的意愿。 存在问题：因为进程是并发执行的，有可能出现大家都为0的情况下，然后两个进程都认为别人是0，然后修改了自己的标志位为1，同时访问了临界区，违背了最主要的“忙则等待”原则。 （3）双标志后检查法 和上面的类似，只是这个会先标志自己想进入临界区，再检查其他进程是否需要进入临界区。 问题也很明显，可能两个进程都把自己的标志位改了，然后检查的时候都发现有别的进程标志位为1，因此就在不断等待。违背“空闲让进”和“有限等待”原则。 上面的几种方法，都没有完全满足四个原则，因此并不是合格的进程互斥实现方法。 （4）peterson 算法 5.3 进程互斥的硬件实现方法(1)中断屏蔽方法 简述：利用“开/关中断指令” 实现 。也就是在进程运行的时候直接把中断关了，那么就不会发生中断，自然不会发生进程的切换。 优点：简单，高效。 缺点： 不适用于多处理机。因为开关中断是对于一个处理机来说的，比如处理机A关中断，那么处理机B是不会关中断的，所以这时候B处理机的进程仍然可能访问那个临界区，导致两个进程同时访问临界区。 只适用于操作系统内核进程，不适用于用户进程。因为开关中断只能运行在内核态。 （2）TestAndSet指令 优点： 实现简单， 无需像软件实现方法那样严格检查是否会有逻辑漏洞； 适用于多处理机环境缺点： 不满足“让权等待” 原则， 暂时无法进入临界区的进程会占用CPU并循环执行TSL指令， 从而导致“忙等” 。 (3)Swap指令 优缺点与TestAndSet指令一样 5.4 信号量机制在前面的两小节，进程互斥的软硬件实现方法中，我们发现有下面两个问题。 1.在双标志先检查法中， 进入区的“检查” 、 “上锁” 操作无法一气呵成， 从而导致了两个进程有可能同时进入临界区的问题。 2.所有的解决方案都无法实现“让权等待” 。 信号量机制就是用来可以同时解决上述两个问题的方法。 含义简述：用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作， 从而很方便的实现了进程互斥、 进程同步。 信号量其实就是一个变量，可以是一个整数，也可以是一个更加复杂的记录型变量。原语有两个：wait（S）和signal（S）原语（也简称P，V操作）。 根据信号量的类型，下面分为两小点。 5.4.1 整型信号量用一个整数型的变量作为信号量， 用来表示系统中某种资源的数量，比如打印机资源就可以用整型信号量，因为打印机是一台台的。 例子：某计算机系统中有一台打印机… 从上面就可以看到，信号量S就设置为1，代表打印机资源的数量。两个原语的定义如上，其实wait原语就是检查打印机资源S是否小于等于0，如果是，代表现在没有打印机可用，同时while循环就会一直执行，也就是p0进程中wait（S）这一步会卡住，P0无法使用打印机。假如S不为0，while循环就不会一直执行，就下来wait原语将S-1，代表打印机资源减少一个。 缺陷：不满足“让权等待”原则， 会发生“忙等” 。例如打印机资源为0的时候，有一个进程占用了处理机，但是它又一直在检查打印机资源，只要没分配到打印机资源，它就会一直等待，造成“忙等” 5.4.2 记录型信号量 记录型信号量最大的变化就是，会检查资源的数量，如果数量不足，就会把进程切换到阻塞态（利用block原语）。当其他进程使用完资源之后，也会检查是否还有别的进程在等待这个资源，有的话就会使用wakeup原语唤醒等待队列中的一个进程（看上面例子，如果S.value&lt;=0,就代表还有其他进程在等待，不然肯定资源数是&gt;0的）。 优点：符合“让权等待”。因为资源用完的时候进程会被切换到阻塞态，不会一直占用着处理机。 5.5 信号量机制实现进程互斥、同步（1）进程互斥 根据上面信号量机制的原理，其实只要把临界区当做一种资源，资源的信号量设置为1即可，处理方法和上面所述一样原理。 （2）进程同步 并发性带来了异步性，有时候需要通过进程同步来解决这种异步问题。看下面这个例子 假如代码4的运行一定要基于代码1和代码2的运行结果，但是由于并发性，如果没有什么同步机制的情况下，处理机就有可能先执行代码4，之后再轮到代码1和2，这个时候自然就会出错。那么如何利用信号量来实现这个操作呢。 如上图，将信号量初始值设置为0。在需要先执行的代码块后面添加V操作，后执行的代码块前面添加P操作。这样只要没有执行完代码1和2，就不会执行V操作，也就是信号量会&lt;=0，导致P操作会卡住。 （3）信号量机制实现前驱关系 前驱关系其实就是同步的问题。假如现在有这么一个问题：进程 P1 中有句代码 S1， P2 中有句代码 S2 ， P3中有句代码S3 …… P6 中有句代码 S6。 这些代码要求按如下前驱图所示的顺序来执行： 那么应该怎么处理呢。其实，只要在每前后两个进程之间设置一个信号量即可控制。这种前后两个进程的关系也称作前驱关系。 每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此需要做的工作就是 1.要为每一对前驱关系各设置一个同步信号量 2.在“前操作” 之后对相应的同步信号量执行 V 操作 3.在“后操作” 之前对相应的同步信号量执行 P 操作 5.6 生产者-消费者问题问题描述： 系统中有一组生产者进程和一组消费者进程， 生产者进程每次生产一个产品放入缓冲区， 消费者进程每次从缓冲区中取出一个产品并使用，（注： 这里的“产品” 理解为某种数据。生产者、 消费者共享一个初始为空、 大小为n的缓冲区。 那么，根据前vp后的原则，图解如下 5.7 管程根据上面信号量机制的知识可以知道，信号量机制存在的问题： 编写程序困难、 易出错 。因此就有人引入了管程。引入管程的目的是更方便地实现进程互斥和同步 。 管程的基本特征： \\1. 局部于管程的数据只能被局部于管程的过程所访问；\\2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；\\3. 每次仅允许一个进程在管程内执行某个内部过程。 其实，就类似于C++里面的类，体现的是一种封装的思想。 六、死锁6.1 死锁产生的必要条件死锁产生的必要条件： 1.互斥条件：就是某个资源只能被互斥地使用 2.不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 3.请求和保持条件：进程已经保持至少一个资源，但又提出新的资源请求，而该资源又被其他进程占有。 4.循环等待条件：存在一种进程资源的循环等待链。 6.2 预防死锁的方法预防死锁，可以通过破坏四个必要条件的其中一个来实现，下面简述下方法以及缺点。 1.破坏互斥条件 将临界资源改造为可共享使用的资源。比如弄个队列把需要用到临界资源的进程排队。 缺点：可行性不高，在某些情况下必须保持临界资源的互斥性 2.破坏不可剥夺条件 申请的资源得不到满足时，立即释放拥有的所有资源。 由操作系统协助剥夺（考虑优先级） 缺点：实现复杂，剥夺资源可能导致部分工作实效。反复申请导致系统开销大；可能导致饥饿 3.破坏请求和保持条件 运行前分配好所有需要的资源，之后一直保持。 缺点：有些资源可能某个进程只需要使用很短时间，但是却在整个过程占用，资源利用率低；可能导致饥饿 4.破坏循环等待条件 给资源编号，必须按照编号从小到大的顺序申请资源。 缺点：用户编程麻烦；如果5号是打印机，7号是摄像头，进程就必须先申请5号，但是如果进程需要先使用摄像头很长一段时间再使用打印机，就会导致资源浪费。 6.3 避免死锁的方法通过特定的算法，避免系统进入不安全状态。 首先需要了解几个概念： 安全序列：所谓安全序列， 就是指如果系统按照这种序列分配资源， 则每个进程都能顺利完成。 安全状态：只要能找出一个安全序列，系统就是安全状态。 当然， 安全序列可能有多个。 不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列， 系统就进入了不安全状态。 如果系统处于安全状态， 就一定不会发生死锁。 如果系统进入不安全状态， 就可能发生死锁（处于不安全状态未必就是发生了死锁， 但发生死锁时一定是在不安全状态） 避免系统进入不安全状态的算法：银行家算法 数据结构：长度为 m 的一维数组 Available 表示还有多少可用资源nm 矩阵 Max 表示各进程对资源的最大需求数nm 矩阵 Allocation 表示已经给各进程分配了多少资源Max – Allocation = Need 矩阵表示各进程最多还需要多少资源用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数 银行家算法步骤：①检查此次申请是否超过了之前声明的最大需求数②检查此时系统剩余的可用资源是否还能满足这次请求③试探着分配， 更改各数据结构④用安全性算法检查此次分配是否会导致系统进入不安全状态 安全性算法步骤：检查当前的剩余可用资源是否能满足某个进程的最大需求， 如果可以， 就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程， 看最终是否能让所有进程都加入安全序列。 七、内存1.一些简单概念内存是什么：内存是用于存放数据的硬件，被划分为一个一个存储单元。程序执行前需要先放到内存中才能被CPU处理。（因为CPU处理速度快，直接读取外存的话读取速度跟不上处理速度） 4GB内存：1GB=2^10MB=2^20KB=2^30B，所以4GB为2^32B，所以需要2^32个存储单元，也就是要32位二进制才可以全部表示。因此，32位的操作系统最大支持4GB内存。 2.页面置换算法（1）最佳置换算法——OPT 这个算法无法实现。 思想：假如知道进程接下来访问的页面，就可以知道哪个页面最后才被访问到，就把最后才会被访问的页面置换成新访问的页面。 无法实现原因：因为需要“预知未来”，需要知道进程接下来会访问到的页面才行。 （2）先进先出置换算法——FIFO 思想：每次淘汰的是最早进入内存的页面 实现方法：把调入内存的页面根据进入的顺序排成一个队列，每次淘汰队头就可以 缺点：算法性能差，无法体现页面冷热信息（就是被使用的频繁度） （3）最近最久未使用置换算法——LRU 思想：每次淘汰的页面是最近这段时间内最久未使用的页面。也就是从开始需要置换的地方开始往回检查，最迟出现的页面就是“最近最久未使用置换算法“ 实现方法： 方法1：使用一个栈，新页面或者被使用的页面，就移动到栈底，每次替换栈顶的缓存页面。 方法2：赋予每个页面对用的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面的时候，选择t最大的页面即可。 前面的三种算法，OPT性能最好，但是无法实现。FIFO实现最简单，但是算法性能差。LRU算法性能好，但是实现起来不容易，开销比较大。所以，需要一个比较均衡的算法——clock （3）时钟置换算法——clock 思想：为每个在内存里的页面设置一个访问位，访问位有1和0两种情况，1代表最近访问过，0代表最近没访问过。再将内存中的页面都通过链接指针链接成一个循环队列。接下来就是操作：新加入的页面访问位都置为1。被访问的页面也置为1。当需要置换的时候，就开始循环扫描，如果页面访问位是0，说明少用，被置换。是1的话说明最近使用过，不被置换，但是访问位变0。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://tetedetian.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"yilia主题使用方法","slug":"yilia主题使用方法","date":"2020-09-06T03:24:07.085Z","updated":"2020-09-08T07:43:42.126Z","comments":true,"path":"2020/09/06/yilia主题使用方法/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/yilia%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"这里，有yilia主题的配置方法及一些问题的解决方法，希望对你有帮助^_^ 我已经改为使用Volantis X主题啦","text":"这里，有yilia主题的配置方法及一些问题的解决方法，希望对你有帮助^_^ 我已经改为使用Volantis X主题啦 置顶文章、文章阅读数统计、鼠标点击小红心的设置以及一些其他的功能添加，点这里 注意：文章中下图这个地方有错，因为不蒜子域名有变 变为 1&lt;script async src&#x3D;&quot;https:&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt; 改背景，加头像旋转效果，点这里","categories":[],"tags":[{"name":"博客搭建与运营","slug":"博客搭建与运营","permalink":"https://tetedetian.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/"}]},{"title":"MySQL基础知识点(暂时完结)","slug":"MySQL基础知识点","date":"2020-09-06T03:24:07.037Z","updated":"2021-04-16T03:05:14.679Z","comments":true,"path":"2020/09/06/MySQL基础知识点/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"————这里，有MySQL的一些基础知识点^_^————","text":"————这里，有MySQL的一些基础知识点^_^———— 前言注：此博客内容基于《MySQL必知必会》一书，下载链接：https://pan.baidu.com/s/1phUYbp982A-aGwWTiGosKw 提取码:4d7l 个人喜欢在学习一样新东西之前先了解它是什么、它有什么用、为什么要学它、大约怎么学。不然学起来云里雾里，心肌梗塞的感觉。那么现在先回答一下上面的问题： 1.它是什么：MySQL其实是一个数据库管理系统，可以理解为一种数据库软件。 2.它有什么用：平时我们接触的很多东西都与数据库有关，比如你在学校的学籍信息系统通过你的学号查询你的信息，就是通过访问学校创建的数据库来查询的。而MySQL就相当于访问的工具。 3.为什么要学它：因为前面说的，我们日常生活中有许许多多的数据，我们要学会怎么去查看，获取等。 4.大约怎么学： 1.安装MySQL，微信搜索“软件安装管家”，软件目录里有多个MySQL版本的下载地址以及安装教程，最后那个Navicat Premium是一个将数据库可视化的软件。 2.建立《MySQL必知必会》用到的数据库，后面学习需要用，就像学习excel一样，需要有一个表格来处理。《MySQL必知必会》后面的附录B有介绍。也可参考博客：https://blog.csdn.net/x__Sherlock/article/details/104223646 3.学习MySQL知识以及处理命令 window控制台一些命令 启动mysql服务：net start mysql 登录mysql：mysql -u root -p 第一章——了解SQLSQL: 结构化查询语言（Structured Query Language），是一种专门用来与数据库通信的语言 数据库： 保存有组织的数据的容器 数据库组成 表：某种特定类型数据的结构化清单 表名: 数据库中的每个表都有一个名字，用来标识自己 列和数据类型：列中存储表的部分信息，比如顾客地址，号码 行:例如，顾客表可以每行存储一个顾客。表中的行数为记录的总数 主键：占据一列，用于标识行 第二章——MySQL简介MySQL 含义：是一种DBMS（数据库管理系统），即它是一种数据库软件 数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS（数据库管理系统）完成的 第三章——使用MySQL注意：1.MySQL命令用;或\\g结束，换句话说，仅按Enter不执行命令 2.输入quit或exit退出命令行实用程序。 1.基本命令1.1创建新数据库 如下，创建一个名为“test”的数据库create database test; 1.2查看数据库 show databases; 1.3使用某个数据库 格式：“use 数据库名字;”，比如下面是使用数据库“test”use test; 1.4查看数据库的表 show tables;查看数据库的表之前需要先“use”数据库，指明需要显示的数据库，如下 1.5查看表的列信息 show columns from customers;或describe customers;返回的是每一列的信息，即字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息显示结果如下 下图为customers表，自己比较一下 第四章——检索数据1.简单检索1.1检索单列 例子：select prod_name from products;解释：上述语句利用SELECT语句从 products表中检索一个名为prod_name的列。 1.2检索多个列 例子：select prod_id,prod_name,prod_price from products;解释：上述语句利用SELECT语句从products表中检索名为 prod_id,prod_name,prod_price 的三个列。 1.3检索所有列 例子：select * from products;解释：上述语句利用SELECT语句从products表中检索所有列。 1.4检索不同行 例子：select distinct vend_id from products; 解释：上述语句利用SELECT语句从products表中检索vend_id列不同的行。输出看下图 对比下图select vend_id from products;的输出结果 2.限制结果检索2.1限制行数 例子：select vend_id from products limit 5; 解释：上述语句利用SELECT语句从products表中检索vend_id前五行。输出看下图 例子：select vend_id from products limit 5,5; 解释：上述语句利用SELECT语句从products表中检索vend_id 的6~10行（因为第一行为行0，不是行1，类似c语言的数组元素定义）。输出看下图 2.2使用完全限定的表名 例子：1.select products.prod_name from products; ​ 2.select products.prod_name from test.products; (test是我存放这些表的) 解释：1和2与select prod_name from products;功能一样至于有什么特殊用处，我还不知道。。。 第五章——排序检索数据1.根据一个列排序 例子：select prod_name from products order by prod_name; 解释：上述语句将products表中prod_name列排序输出。（按照字母排序） 2.根据多个列排序 例子：select prod_id,prod_price,prod_name from products order by prod_price,prod_name; 解释：上述语句将products表中prod_id,prod_price,prod_name三列根据prod_price,prod_name排序输出。（先按照prod_price排序，prod_price相同的，按照prod_name排），输出如下图 3.指定排序方向 排序方向指升序还是降序，默认升序，需要降序的话需要用到desc关键字 例子：select prod_id,prod_price,prod_name from products order by prod_price desc,prod_name; 解释：上述语句将products表中prod_id,prod_price,prod_name三列根据prod_price降序,prod_name升序，排序输出。 4.排序并限制输出数量 例子：select prod_price from products order by prod_price desc limit 1; 解释：上述语句将products表中prod_price列根据prod_price降序排序输出，并指输出一个。比如生活中需要找到最贵的选项。 第六章——过滤数据本章将讲授如何使用 SELECT 语句的 WHERE 子句指定搜索条件 1.相等检查 例子： 1select prod_name,prod_price from products where prod_price=2.50; 解释：显示prod_name,prod_price两列，但只显示prod_price=2.50的行。输出看下图 例子： 1select prod_name,prod_price from products where prod_name='fuses'; 解释：显示prod_name,prod_price两列，但只显示prod_name=’fuses’的行(因为是字符串，需要用单引号)。 2.范围值检查 例子： 1select prod_name,prod_price from products where prod_price between 5 and 10; 解释：显示prod_name,prod_price两列，但只显示5&lt;=prod_price&lt;=10的行。 3.空值检查 例子： 1select prod_name,prod_price from products where prod_price is null; 解释：显示prod_name,prod_price两列，但只显示prod_price为空的行（注意：0不是空）。 4.其他的where子句操作符 5.一些注意点： 1.NULL值的行在匹配或不匹配具体数值是，不会返回。 2.where 与order by 一起用时，where需要放在order by 前面。例如 1select prod_name,prod_price from products where prod_price=2.50 order by prod_name desc; 输出如下 第七章——数据过滤(这名字咋和第六章这么像呢) 本章讲授如何组合WHERE子句以建立功能更强的更高级的搜索条件。我们还将学习如何使用NOT和IN操作符。 1.and操作符 例子： 1select prod_name,prod_price from products where vend_id=1003 and prod_price&lt;=10; 解释：显示prod_name,prod_price两列，但只显示同时满足vend_id=1003 和 prod_price&lt;=10的行。 2.or操作符 例子： 1select prod_name,prod_price from products where vend_id=1003 or vend_id=1002; 解释：显示prod_name,prod_price两列，但只显示满足vend_id=1003 或 vend_id=1002的行。 3.and与or优先级 and的优先级大于or，与加减乘除优先级类似，and相当于乘除，or加减 例子： 1select prod_name,prod_price from products where vend_id=1002 or vend_id=1003 and prod_price&gt;=10; 解释：输出显示prod_name,prod_price两列，但只显示满足vend_id=1003 and prod_price&gt;=10 或 vend_id=1002的行。 可以通过加括号控制计算顺序，比如 1select prod_name,prod_price from products where (vend_id=1002 or vend_id=1003) and prod_price&gt;=10; 4.in操作符 例子： 1select prod_name,prod_price from products where vend_id in (1003,1002); 解释：显示prod_name,prod_price两列，但只显示满足vend_id=1003 或 vend_id=1002的行。其实，他的功能和select prod_name,prod_price from products where vend_id=1003 or vend_id=1002;是一样的。 相对于or的优点： 1.在使用长的合法选项清单时， in操作符的语法更清楚且更直观。2.在使用in时，计算的次序更容易管理（因为使用的操作符更少）。3.in操作符一般比OR操作符清单执行更快。4.in的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 5.not操作符 例子： 1select prod_name,prod_price from products where vend_id not in (1003,1002); 解释：显示vend_id=1003 或 vend_id=1002 之外的行。 第八章——用通配符进行过滤本章介绍什么是通配符、如何使用通配符以及怎样使用LIKE操作符进行通配搜索，以便对数据进行复杂过滤。 通配符：用来匹配值的一部分的特殊字符 。 搜索模式：由字面值、通配符或两者组合构成的搜索条件。 比如直接相等匹配和使用通配符匹配是两种搜索模式。 1.like操作符（是一种谓词) 为在搜索子句中使用通配符，必须使用like操作符。like指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 （就是用来告诉MySQL搜索模式的） 2.百分号（%）通配符 在搜索串中， %表示任何字符出现任意次数。 例子： 1select prod_id,prod_name from products where prod_name like 'jet%'; 解释：显示prod_name中以jet开头的行。 例子： 1select prod_id,prod_name from products where prod_name like '%anvil%'; 解释：显示prod_name中包含jet的行。 3.下划线（_）通配符 与下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符 。 例子： 1select prod_id,prod_name from products where prod_name like '_ ton anvil'; 解释：”_“的地方只可以有一个字符。对比一下下面的例子 例子： 1select prod_id,prod_name from products where prod_name like '% ton anvil'; 第九章——用正则表达式进行搜索本章将学习如何在MySQL WHERE子句内使用正则表达式来更好地控制数据过滤。用到 regexp 操作符 1.基本字符匹配 例子： 1select prod_name from products where prod_name regexp '1000'; 解释：显示prod_name中包含1000的行。 2.进行或匹配 例子： 1select prod_name from products where prod_name regexp '1000|2000'; 解释：显示prod_name中包含1000或2000的行。 3.匹配几个字符之一 例子： 1select prod_name from products where prod_name regexp '[123] ton'; 解释：显示prod_name中包含”1 ton”、”2 ton” 或者”3 ton“的行。 4.匹配范围 上面的select prod_name from products where prod_name regexp &#39;[123] ton&#39;;还可以换成 1select prod_name from products where prod_name regexp '[1-3] ton'; 还有字母也可以，比如[a-z] 5.匹配特殊字符 比如. ， | ， [] ，这些有特殊含义的字符，需要用\\\\来进行转义 例子： 1select prod_name from products where prod_name regexp '\\\\.'; 例子： 1select prod_name from products where prod_name regexp '.'; 解释：因为.在regexp操作中，代表任意字符，如果不在前面，MySQL就以为你想搜索任意字符 6.匹配字符类 例子： 1select prod_name from products where prod_name regexp '[:upper:]'; 解释:显示prod_name中包含大写字母的行。 7.匹配多次出现 例子 1select prod_name from products where prod_name regexp &#39;\\\\([0-9] sticks?\\\\)&#39;; 解释：\\\\( 匹配 ( ，[0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\\\)匹配)。 例子 1select prod_name from products where prod_name regexp &#39;[[:digit:]]&#123;4&#125;&#39;; 解释：[[:digit:]]{4}匹配连在一起的任意4位数字。 8.定位符 *注意：^的双重用途 ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。 * 例子 1select prod_name from products where prod_name regexp &#39;^[0-9\\\\.]&#39;; 解释：^[0-9\\\\.]匹配0到9，或者.为开头的prod_name,^[0-9\\\\.]也可写成^[123456789\\\\.] 例子 1select prod_name from products where prod_name regexp &#39;[[:&lt;:]]t&#39;; 解释：[[:&lt;:]]t匹配t开头的词。 第十章——创建计算字段*本章介绍什么是计算字段，如何创建计算字段以及怎样从应用程序中使用别名引用它们。 * 1.拼接字段 使用concat函数 例子： 1select concat (vend_name,'(',vend_country,')') from vendors; 解释：Concat()需要一个或多个指定的串，各个串之间用逗号分隔。上面的语句连接了4个元素。 2.使用别名 使用as关键字 例子： 1select concat (vend_name,'(',vend_country,')') as vend_title from vendors; 解释：这不用解释了吧？ 3.执行算数计算 例子： 1select prod_id,quantity,item_price,quantity*item_price as expanded_price from orderitems where order_num=20005; 解释：这也不用解释了吧？加减乘除就是##-*/，也可以加括号。 第十一章——使用数据处理函数本章介绍什么是函数， MySQL支持何种函数，以及如何使用这些函数。 1.文本处理函数 例子： 1select vend_name,upper(vend_name) as vend_name_upcase from vendors; 解释：upper()函数将文本装换为大写。 下面列举了一些常用函数 上面列举的函数中，有个特别有趣的函数：soundex（）函数。 soundex是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 作用是根据发音来查找数据。 例子： 1select cust_name,cust_contact from customers where soundex(cust_contact)=soundex('Y Lie'); 因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配 。这个的作用是能够对录入数据时的错误进行补救。 2.日期和时间处理函数 上图列出了一些常用的日期和时间处理函数，使用这些函数，有一些注意点，如下：1.日期必须为格式yyyy-mm-dd ，因为它排除了多义性（如，04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或……）。 2.对于日期比较，习惯使用date()函数。 例如： 1select cust_id,order_num from orders where date(order_date)='2005-09-01'; 比 1select cust_id,order_num from orders where order_date='2005-09-01'; 要好。因为order_date的数据类型为datetime。这种类型存储日期及时间值。 比 如 ， 存 储 的 order_date 值 为2005-09-01 11:30:05，则WHERE order_date = ‘2005-09-01’失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。 同理，也应该在适当的时候使用time（）函数（筛选时间的）。 3.数值处理函数 数值处理函数，就是我们平时学习其他语言都会有的一类函数。 第十二章——汇总数据*本章介绍什么是SQL的聚集函数以及如何利用它们汇总表的数据 * 上图是一些基本的汇总数据的函数 用法例子： 1select avg(prod_price) from products; 其他函数用法类似，不过需要注意count（）函数用法。 count()函数 1.使用COUNT(*)对表中行的数目进行计数， 不管表列中包含的是空值（NULL）还是非空值。2.使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 例子(1)： 1select count(*) from customers; 例子(2)： 1select count(cust_email) from customers; 因为cust_email只有三个数据，另外两个是空的，所以显示3 distinct参数 作用：只对不同的值进行处理 例子： 1select avg(distinct prod_price) from products; 只对prod_price中的不同值进行取平均值操作。 第十三章——分组数据本章将介绍如何分组数据，以便能汇总表内容的子集。这涉及两个新SELECT语句子句，分别是GROUP BY子句和HAVING子句 1.创建分组 例子： 1select vend_id,count(*) as num_prods from products group by vend_id; 解释：group by子句把vend_id按照数值进行了分组 group by使用注意点： 1.**group by子句必须出现在where子句之后，order by子句之前。 例子： 1select vend_id,count(*) as num_prods from products where vend_id&lt;=1003 group by vend_id order by vend_id desc; 2.过滤分组 使用having子句 例子： 1select vend_id,count(*) as num_prods from products group by vend_id having count(*)&gt;3; 解释：可以比较上面的例子，having count(*)把大于3的过滤出来，只显示大于3的 3.分组和排序 group by和order by组合使用 例子： 1select order_num,sum(quantity*item_price) as ordertotal from orderitems group by order_num having sum(quantity*item_price)&gt;=50 order by ordertotal; 第十四章——使用子查询1.利用子查询进行过滤 例子： 1select cust_name,cust_contact from customers where cust_id in (select cust_id from orders where order_num in (select order_num from orderitems where prod_id='TNT2')); 解释：(1) 检索包含物品TNT2的所有订单的编号。(2) 检索具有前一步骤列出的订单编号的所有客户的ID。(3) 检索前一步骤返回的所有客户ID的客户信息。 这个例子，运用十五章学习的联结知识也可以解决，命令如下 1select cust_name,cust_contact from customers,orderitems,orders where customers.cust_id=orders.cust_id and orderitems.order_num=orders.order_num and prod_id='TNT2'; 2.子查询作为计算字段 例子： 1select cust_name,cust_state,(select count(*) from orders where orders.cust_id=customers.cust_id) as orders from customers order by cust_name; 解释：select count(*) from orders where orders.cust_id=customers.cust_id 的作用是：对于检索出的每个客户，统计其在orders表中的订单数目 。 第十五章——联结表本章将介绍什么是联结，为什么要使用联结，如何编写使用联结的SELECT语句。 1.基础概念1.1关系表 简单来说，就是两个表之间有一列数值是对应的，两个表的行之间是对应的。 1.2联结 简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。 2.创建联结2.1联结两个表 例子： 1select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id=products.vend_id order by vend_name,prod_name; vend_name是表vendors的数据， prod_name,prod_price是表products的数据。上面的语句把两个表的数据联结起来了 上面的例子也可以换个语法， 1select vend_name,prod_name,prod_price from vendors inner join products on vendors.vend_id=products.vend_id order by vend_name,prod_name; 使用的是inner join语法 2.2联结多个表 例子： 1select vend_name,prod_name,prod_price,quantity from vendors,products,orderitems where vendors.vend_id=products.vend_id and orderitems.prod_id=products.prod_id and order_num=20005; 第十六章——创建高级联结本章将讲解另外一些联结类型（包括它们的含义和使用方法），介绍如何对被联结的表使用表别名和聚集函数。 1.使用表别名 例子： 1select vend_name,prod_name,prod_price,quantity from vendors as v,products as p,orderitems as o where v.vend_id=p.vend_id and o.prod_id=p.prod_id and order_num=20005; 给vendors ,products ,orderitems 三个表起了别名，目的是缩短SQL语句，方便多次使用表 应该注意：表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。 2.使用不同类型的联结2.1自联结 问题：假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。 1select p1.prod_id,p1.prod_name from products as p1,products as p2 where p1.vend_id=p2.vend_id and p2.prod_id='DTNTR'; 使用了自联结的方法，其实也可以使用子查询的方法。但有时候处理联结远比处理子查询快得多。 2.2自然联结2.3外部联结 许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。 比如：对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户； 先来看一下两个表 表1是orders表，表2是customers表。根据问题，要讲customers表所有的cust_id全部列出来，哪怕他在orders表没数据 1select customers.cust_id,orders.order_num from customers left outer join orders on customers.cust_id=orders.cust_id; 输出显示，就算cust_id=10002在orders表里没有数据，一样会输出，只是显示NULL。这主要是left outer join的作用，left指定了将left outer join左边的表的左右行输出，即customers。如果left替换成right，则指orders表。 3.使用带聚集函数的联结 例子： 1select customers.cust_name,customers.cust_id,count(orders.order_num) as num_ord from customers left outer join orders on customers.cust_id=orders.cust_id group by customers.cust_id; 第十七章——组合查询本章讲述如何利用UNION操作符将多条SELECT语句组合成一个结果集。 使用union 例子： 1select vend_id,prod_id,prod_price from products where prod_price union select vend_id,prod_id,prod_price from products where vend_id IN (1001,1002); UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。 union一些特性： 1.每个查询必须包含相同的列、表达式或聚集函数（不过分析各个列不需要以相同的次序列出）。 2.UNION从查询结果集中自动去除了重复的行。若想保留重复行，可用UNION ALL 。 3.在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。 第十八章——全文本搜索本章将学习如何使用MySQL的全文本搜索功能进行高级的数据查询和选择 1.全文本搜索是什么？ 是可以进行精确、多功能，高性能的文本搜索方式 2.使用方法(步骤)： （1）.创建表的时候要使用fulltext命令来对指定索引的列。 例子：（这个表在导入的时候已经存在了，这里只是演示怎么创建的，create table命令后面怎么用后面章节会讲，先理解fulltext作用） 123456789create table productnotes( note_id int not null auto_increment, prod_id char(10) not null, note_date datetime not null, note_text text null, primary key(note_id), fulltext(note_text))engine=myisam; 这个例子fulltext(note_text)指定了全文本搜索时对note_text列进行搜索。 （2）.进行全文本搜索 例子： 1select note_text from productnotes where match(note_text) against('rabbit'); productnotes表中的note_text列有两行含有rabbit，因此被检索出来了。其中，Match(note_text)指示MySQL针对指定的列进行搜索， Against(‘rabbit’)指定词rabbit作为搜索文本。 3.全文本搜索优点 （1）相对于like+通配符,正则表达式这些来说，性能高 （2）全文本搜索会根据被搜索文本出现的先后，次数等进行排序 4.使用查询扩展 例子： 1select note_text from productnotes where match(note_text) against('anvils' with query expansion); with query expansion使得搜索结果不仅输出anvils所在行，还会输出带有anvils所在行其他单词的行，就是anvils所在行的其他单词，要是在其他行出现，会被认为相关，然后一起输出 5.布尔文本搜索 即使没有FULLTEXT索引也可以使用布尔文本搜索 以布尔方式，可以提供关于如下内容的细节：  要匹配的词； 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）； 排列提示（指定某些词比其他词更重要，更重要的词等级更高）； 表达式分组； 另外一些内容 例子： 1select note_text from productnotes where match(note_text) against ('heavy -ropes*' in boolean mode); 添加in boolean mode代表进行布尔文本搜索，-rope*代表排除包含rope*（任何以rope开始的词，包括ropes）的行 。 6.全文本搜索的使用说明 (1)在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。(2) MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。(3)许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此， MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。 50%规则不用于IN BOOLEAN MODE。(4)如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。(5) 忽略词中的单引号。例如， don’t索引为dont。(6)不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。(7)如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 第十九章——插 入 数 据本章介绍如何利用SQL的INSERT语句将数据插入表中。 1.插入行 使用insert into 例子：给表customers添加了两行 123insert into customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)values('tian','dong shan street','huazhou','MI','66666','CH'), ('bin','dong shan street','huazhou','MI','66066','CH'); insert into后面跟着表名，需要添加数据的列用括号括着。values指出需要添加的数据，需要按照前面的列名顺序添加。 2.插入检索出的数据 例子：将表custnew的行插入到表customers中 假设A,B,C,D,E,F,G 是表custnew的列名。这个例子是把A列插入到cust_name，B列插入到cust_address，以此类推 12insert into customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)select A,B,C,D,E,F,G from custnew; 第二十章——更新和删除数据本章介绍如何利用UPDATE和DELETE语句进一步操纵表数据。 1.更新数据 使用update语句 例子1：给表customers里的一位客户添加邮箱地址 1update customers set cust_email='elmer@fudd.com' where cust_id=10005; 例子1：更新表customers里的数据 1update customers set cust_name='The Fudds',cust_email='elmer@fudd.com' where cust_id=10005; 记得不要漏了where语句，不然就会把全部行的数据都更新了。如果想删除某个列数值，可设置它为NULL 。 ignore关键字： 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：UPDATE IGNORE customers… 2.删除数据 （1）删除整个行，使用delete语句 例子： 1delete from customers where cust_id=10005; （2）删除所有行，使用truncate table语句 例子1：更新表customers里的 1truncate table customers; 3.注意点 （1）小心使用 MySQL没有撤销（ undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。 （2）在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确 。 第二十一章——创建和操纵表本章讲授表的创建、更改和删除的基本知识。 1.创建表 使用create table (1)表的主键可以在创建表时用PRIMARY KEY关键字指定。主键是用来标识表中每个行的列。 (2)每个表列或者是NULL列，或者是NOT NULL列，需要规定好。NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。NULL代表该列可以是空的，NOT NULL代表该列一定要有值。 (3) AUTO_INCREMENT :添加了AUTO_INCREMENT的列每当增加一行时自动增量 。 (4) 指定默认值 :使用DEFAULT ，与AUTO_INCREMENT添加位置一样，比如添加default 1,那么这一列在没给出数值的时候就是默认值1。 (5) 引擎类型 :可以看到下面例子的最后有个语句：ENGINE=InnoDB ，这语句是用来配置引擎的，InnoDB是一个可靠的事务处理引擎 。除此之外还有MEMORY、MyISAM 例子：表customers的创建 2.操纵表2.1 更新表 使用ALTER TABLE语句 例子1：给表添加一个列 1alter table vendors add vend_phone char(20); 例子2：给表删除一个列 1alter table vendors drop column vend_phone; 2.2 删除表 删除表（删除整个表而不是其内容） ,使用DROP TABLE语句， 与上一章的delete不一样， 例子： 1drop table vendors2; 请谨慎使用！ 2.3 重命名表 使用RENAME TABLE语句可以重命名一个表 例子： 1rename table vendors to vendor,vendor to vendors; 第二十二章——使 用 视 图本章将介绍视图究竟是什么，它们怎样工作，何时使用它们。我们还将看到如何利用视图简化前面章节中执行的某些SQL操作。 1. 什么是视图 简单来说，就是可以通过视图，呈现多个表数据的组合，在对视图进行检索、查看的时候，其实是通过一定的方式查看视图引用的表的数据，视图并没有像表这样实际数据。我们前面有学习了联结，联结的语句一般会比较复杂，利用视图就可以简化复杂语句的使用了。 再简而言之，视图就是对筛选的数据进行封装，但是它并没有真正的复制表的数据，只是引用。 2.使用视图注意点 （1）视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。（2）ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。（3）视图不能索引，也不能有关联的触发器或默认值。（4）视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 3.使用视图创建视图：CREATE VIEW语句查看创建某视图的语句： 使用SHOW CREATE VIEW viewname（viewname是实际视图名字）删除视图：其语法为DROP VIEW viewname。更新视图时：可以先用DROP再用CREATE，也可以直接用CREATE ORREPLACE VIEW。 3.1 利用视图简化复杂的联结 例子：创建一个视图，呈现内容与select customers.cust_id,orders.order_num from customers left outer join orders on customers.cust_id=orders.cust_id;一致。 1create view customers_num as select customers.cust_id,orders.order_num from customers left outer join orders on customers.cust_id=orders.cust_id; 创建之后，可通过 1select * from customers_num; 查看与上述联结语句一样的内容 3.2用视图过滤不想要的数据 其实与利用视图简化联结一样用法 例子：过滤没有邮箱的客户 1create view customers_not_email as select cust_id,cust_name,cust_email from customers where cust_email is not null; 其他的视图创建都差不多，后面跟着select语句。 第二十三章——使用存储过程本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。 1.什么是存储过程 简单来说，存储过程的各语言里的子函数很像，把一些语句封装成块，使用的时候直接调用即可。 2.创建存储过程 使用create procedure语句 DELIMITER //告诉命令行实用程序使用//作为新的语句结束分隔符 ，如果用；会报错 例子： 12345DELIMITER //CREATE PROCEDURE ordertotal(IN onumber INT, OUT ototal DECIMAL(8,2))BEGIN SELECT SUM(item_price*quantity) FROM orderitems WHERE order_num=onumber INTO ototal;END// 创建完成后，下面是把分隔符换回;，调用存储过程，以及使用的截图 3.建立智能存储过程 例子：对某些顾客增加增值税 --后面的是注释，taxable它是一个布尔值（如果要增加税则为真，否则为假）,DECLARE语句定义了两个局部变量。 COMMENT它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。 输入输出： 4.检查存储过程 为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATEPROCEDURE语句 1SHOW CREATE PROCEDURE ordertotal; 第二十四章——使 用 游 标本章将讲授什么是游标以及如何使用游标。 1.什么是游标 如果学过c语言，就比较好理解。游标的作用与指针类似。比如在一个操作里，需要对一个表的一千行进行有规律的操作，比如+1、+2、+3……，那么使用一千条语句就不现实了。此时就可以通过游标和循环，每次对一行操作，循环一千次。 2.使用游标 创建游标: 用DECLARE ....CURSOR语句创建 。 打开和关闭游标：用OPEN语句来打开 ，用CLOSE语句来打开,如果你不明确关闭游标， MySQL将会在到达END语句时自动关闭它。 使用游标数据 :游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。 例子： 1234567891011121314151617181920212223242526272829303132333435363738DELIMITER //CREATE PROCEDURE processorders()BEGIN --声明局部变量 DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); --声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; --定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里它指出当SQLSTATE'02000'出现时，SET done=1。 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1; --创建一个表存数据 CREATE TABLE IF NOT EXISTS ordertotals --打开游标 OPEN ordernumbers; --重复使用FETCH REPEAT FETCH ordernumbers INTO o; --掉用前面增加增值税的存储过程，并且返回结果 CALL ordertotal(o,1,t); --保存数据，十九章内容 INSERT INTO ordertotals(order_num,total) VALUES(o,t); --结束循环 UNTIL done END REPEAT; --关闭游标 CLOSE ordernumbers; END// 第二十五章——使用触发器本章学习什么是触发器，为什么要使用触发器以及如何使用触发器。本章还介绍创建和使用触发器的语法。 如果你想要某条语句（或某些语句）在事件发生时自动执行，怎么办呢？ 答案：使用触发器 要点： （1）触发器只能触发的语句：DELETE、 INSERT、UPDATE。 （2）只有表才支持触发器，视图不支持（临时表也不支持）。 （3） 触发器自带一些虚拟表，比如NEW,OLD。 1.创建触发器 创建触发器要求： 唯一的触发器名； 触发器关联的表； 触发器应该响应的活动（DELETE、 INSERT或UPDATE）； 触发器何时执行（处理之前或之后）。 用CREATE TRIGGER语句创建 例子：这个例子暂时有问题 12--文本Productadded将对每个插入的行显示一次。CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'product added' INTO @tip; 测试一下： 12INSERT INTO products(prod_id,vend_id,prod_name,prod_price,prod_desc)VALUES(&#39;tian&#39;,1003,&#39;yutian&#39;,10,&#39;sss&#39;); 2.删除触发器 和前面的删除语句一样 1DROP TRIGGER newproduct; 第二十六章——管理事务处理本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理 1.什么是事务处理 事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。通俗点来说就是用来避免因为一些故障导致sql语句执行到一半就停止了，然后产生了错误的数据。 事务处理以START TRANSACTION;开始，有点类似一个函数块，然后可以利用一些语句对整个事务处理进行控制。 2.使用ROLLBACK ROLLBACK命令用来回退（撤销） MySQL语句 注意： (1)ROLLBACK只能在一个事务处理内使用（在执行一条STARTTRANSACTION命令之后）。 (2)不能回退SELECT语句。（这样做也没有什么意义。）不能回退CREATE或DROP操作。 例子 :撤销删除操作 123456SELECT * FROM orders;START TRANSACTION;DELETE FROM orders;SELECT * FROM orders;ROLLBACK;SELECT * FROM orders; 2.使用COMMIT 为进行明确的提交，使用COMMIT语句。也就是COMMIT用来保证语句执行完毕无误后再提交结果 例子： 1234START TRANSACTION;DELETE FROM orderitems WHERE order_num = 20010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。 3.使用保留点 ROLLBACK和COMMIT语句可以写入或撤销整个事务处理。但是复杂的事务处理可能需要部分提交或回退。便可以使用保留点 使用SAVEPOINT语句 创建保留点 1SAVEPOINT goback; goback就是保留点名称，如果需要返回保留点，就用 1ROLLBACK TO goback; 释放保留点就用 1RELEASE SAVEPOINT goback; 4.更改默认的提交行为 在事务处理里，每一个语句都是立刻执行并提交的，如果想指示MySQL不自动提交更改 ，可以用以下语句 1SET autocommit=0; 以及 1SET autocommit=1; 设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。 第二十七章——全球化和本地化本章介绍MySQL处理不同字符集和语言的基础知识。 1.字符集和校对顺序 (1)显示所有可用的字符集以及每个字符集的描述和默认校对: 1SHOW CHARACTER SET; (2)显示所有可用的校对，以及它们适用的字符集 : 1SHOW COLLATION; (3)给表指定字符集和校对 此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。 123456CREATE TABLE mytable( columnn1 INT, COLUMNN2 VARCHAR(10))DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; (4)对每个列指定字符集个校对 1234567CREATE TABLE mytable( columnn1 INT, COLUMNN2 VARCHAR(10), column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci)DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 第二十八章——安 全 管 理数据库服务器通常包含关键的数据，确保这些数据的安全和完整需要利用访问控制。本章将学习MySQL的访问控制和用户管理。 1.创建，重命名，删除用户 （1）创建用户 使用CREATE USER语句 1CREATE USER tian1 IDENTIFIED BY '111111'; tian1是用户名，111111是密码。不过创建新用户不一定需要设置密码。 （2）重命名 1RENAME USER tian1 TO tiantian; （3）删除 1DROP USER tiantian; 2.设置访问权限在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。 (1)查看权限 1SHOW GRANTS FOR tian1; USAGE ON *.*：USAGE表示没有权限，*.*表示任意数据库以及任意表。所以，此结果表示在任意数据库和任意表上对任何东西没有权限。 （2）添加权限 使用GRANT语句 1GRANT SELECT,INSERT ON crashcourses.* TO tian1; 此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。 （3）删除权限 1REVOKE SELECT ON crashcourse.* FROM tian1; 3.更改密码 使用SET PASSWORD语句 例子1：更改tian1的密码 1SET PASSWORD FOR tian1=Password('222222'); 例子1：更改当前登录用户的密码 1SET PASSWORD =Password('222222'); 第二十九章——数据库维护本章学习如何进行常见的数据库维护。 (1)ANALYZE TABLE，用来检查表键是否正确。 1ANALYZE TABLE orders; (2) 第三十章——改善性能本章将复习与MySQL性能有关的某些要点。 （1）MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是没问题的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用 SHOW VARIABLES;和 SHOW STATUS;。）（2）MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。（3）总是有不止一种方法编写同一条SELECT语句。 应该试验联结、并、子查询等，找出最佳的方法。（4）使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。（5）一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。（6）应该总是使用正确的数据类型。（7）决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。（8） 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。（9）在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。（10）必须索引数据库表以改善数据检索的性能。（11）你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。（12）索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）（13）LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。（14）数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://tetedetian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"markdown小技巧","slug":"markdown小技巧","date":"2020-09-06T03:24:06.988Z","updated":"2020-10-16T09:14:54.331Z","comments":true,"path":"2020/09/06/markdown小技巧/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/markdown%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"————markdown的基础语法以及一些稍微高级的用法————","text":"————markdown的基础语法以及一些稍微高级的用法———— 前言markdown是什么？ 百度百科：Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 换种说法，就是文章内容会根据你标记的符号来呈现特定的格式，markdown文件后缀是md。 需要用到什么软件： 不需要特定软件， 在这里，给大家介绍一款我在用的markdown编辑器——Typera（特殊的编辑器会根据markdown语法实时渲染，呈现格式。）效果可以看视频。 一、基础语法看这里 1.链接1 2.连接2 二、基础语法没怎么提及的用法1.控制主页显示内容 使用&lt;!--more--&gt;只显示 &lt;!--more--&gt; 之前的内容、 2.插入图片 目前我使用的是阿里云+Typora的方法，方法见知乎：https://zhuanlan.zhihu.com/p/138878534目前我是用4.98元买了6个月的资源包，后续费用怎样我再写上来 3.调节图片大小 方法1：格式：&lt;img src=&quot;图片路径或网址&quot; width=&quot;这里写宽度px&quot;&gt; 比如下面这张图片的代码是&lt;img src=&quot;http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png&quot; width=&quot;100px&quot;&gt; 方法2： 格式：&lt;img src=&quot;图片路径或网址&quot; alt=&quot;图片描述（图片没显示时显示的文字）&quot; style=&quot;zoom: 一个百分数（控制大小）;&quot; /&gt; 图片描述也可以不要：&lt;img src=&quot;图片路径或网址&quot; style=&quot;zoom: 一个百分数（控制大小）;&quot; /&gt; 比如下面这张图片的代码是&lt;img src=&quot;http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20200706141931838.png&quot; style=&quot;zoom: 67%;&quot; /&gt; 方法3：根据上面插入图片的方法配置好，可以直接把图片复制粘贴到Typora，会自动上传阿里云并且编辑好方法2的格式，十分方便。 4.添加目录 利用vscode的“Markdown TOC”插件可以自动生成目录 5.文字居中 比如这样 上面语句的代码：&lt;div align=&quot;center&quot; &gt;比如这样&lt;/div&gt; 格式就是：&lt;div align=&quot;center&quot; &gt;这里添加需要居中的文本&lt;/div&gt; 6.实现页面内跳转 跳转起点添加语句：[跳转入口名字](#jump) 跳转终点添加语句：&lt;span id=&quot;jump&quot;&gt; &lt;/span&gt; 解释： （1）跳转入口名字: 就是像超链接一样，颜色一般是蓝色的，点击就会跳转，类似提示语 （2）jump：这里的jump是两个点连接的标识，可以称为id。jump只是我定义的id，你也可以用其他字母或者数字 （3）&lt;span id=&quot;jump&quot;&gt; &lt;/span&gt;中间可以加文本，会在终点显示","categories":[],"tags":[{"name":"博客搭建与运营","slug":"博客搭建与运营","permalink":"https://tetedetian.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/"}]},{"title":"Linux基础知识点","slug":"Linux基础知识点","date":"2020-09-06T03:24:06.962Z","updated":"2020-10-31T08:38:49.651Z","comments":true,"path":"2020/09/06/Linux基础知识点/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"————这里，有我学习linux时记录的一些基础知识点————","text":"————这里，有我学习linux时记录的一些基础知识点———— 前言 为什么学习 Linux 系统？ 可以看一下下图linux相对于windows的优势 Linux的这些优势就是需要学习Linux的部分原因 一、linux基础命令1.命令格式命令名称 [命令参数] [命令对象] 命令名称、命令参数、命令对象之间请用空格键分隔。命令对象一般是指要处理的文件、目录、用户等资源，而命令参数可以用长格式（完整的选项名称,例如：man --help）， 也可以用短格式（单个字母的缩写，例如：man -h）， 两者分别用--与-作为前缀 . 2.常用系统工作命令 man命令 man可以用来查看命令的帮助信息，比如我想了解date命令的帮助信息 1man date echo命令 格式:“echo [字符串 | $变量]”，echo 命令用于在终端输出字符串或变量提取后的值。 1.输出字符串“tiantian” 12tian@tian-virtual-machine:~$ echo tiantiantiantian 2.提取变量SHELL的值 12tian@tian-virtual-machine:~$ echo $SHELL&#x2F;bin&#x2F;bash date命令 格式：“date [选项] [+指定的格式]” ，date 命令用于显示及设置系统的时间或日期 。 reboot命令 reboot命令用于重启系统 poweroff命令 poweroff命令用于关闭系统 wget命令 ps命令 格式：“ps [参数]”，ps 命令用于查看系统中的进程状态， top命令 格式： top top 命令用于动态地监视进程活动与系统负载等信息 top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。 第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、 5分钟、 15 分钟内的平均值，数值越小意味着负载越低）。 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。（96.0id 意味着有 96.0%的 CPU 处理器资源处于空闲 ） 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。 pidof命令 格式：“pidof [参数] [服务名称]”， pidof 命令用于查询某个指定服务进程的 PID 值， 每个进程的进程号码值（PID）是唯一的，因此可以通过 PID 来区分不同的进程。 kill命令 格式：“kill [参数] [进程 PID]”， kill 命令用于终止某个指定 PID 的服务进程 killall 命令 格式：“killall [参数] [进程名称]”，killall 命令用于终止某个指定名称的服务所对应的全部进程。 2.系统状态检测命令 ifconfig 命令 ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。 输出如下，网卡名称、 inet 参数后面的 IP 地址、 ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、 TX 的接收数据包与发送数据包的个数及累计流量 ，都是重要参数 123456789101112131415161718root@tian-virtual-machine:~# ifconfigens33: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.231.130 netmask 255.255.255.0 broadcast 192.168.231.255 inet6 fe80::cce1:d7a5:4905:6f54 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:09:5b:2c txqueuelen 1000 (以太网) RX packets 2960 bytes 1124457 (1.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1266 bytes 186200 (186.2 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (本地环回) RX packets 516 bytes 41664 (41.6 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 516 bytes 41664 (41.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 uname命令 uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。 *uptime 命令 * uptime 用于查看系统的负载信息，格式为 uptime。 12root@tian-virtual-machine:~# uptime 14:47:03 up 1:35, 2 users, load average: 0.04, 0.01, 0.00 它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近 1 分钟、 5 分钟、 15 分钟内的压力情况，负载值越低越好 。 free 命令 free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。 1234root@tian-virtual-machine:~# free -h 总计 已用 空闲 共享 缓冲&#x2F;缓存 可用内存： 1.9G 929M 387M 7.0M 641M 865M交换： 2.0G 0B 2.0G 共享：进程共享的内存量。缓冲/缓存：磁盘缓存的内存量。可用：缓存的内存量。 （我的系统显示的是中文） who 命令 who 用于查看当前登入主机的用户终端信息，格式为“who [参数]”。 123root@tian-virtual-machine:~# whotian :0 2020-07-09 13:12 (:0)tian pts&#x2F;2 2020-07-09 13:15 (192.168.231.1) last 命令 last 命令用于查看所有系统的登录记录，格式为“last [参数]”。 history 命令 history 命令用于显示历史执行过的命令，格式为“history”，要清除记录，用history -c。还可以使用“!编码数字”的方式来重复执行某一次的命令。 1234567root@tian-virtual-machine:~# history 1 history 2 date 3 historyroot@tian-virtual-machine:~# !2date2020年 07月 09日 星期四 15:10:56 CST sosreport 命令 sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。 3.工作目录切换命令 pwd 命令 pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。 cd命令 cd 命令用于切换工作路径，格式为“cd [目录名称]”。 cd ~切换到根目录，cd -切换到上一次的目录. ls命令 ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。 ls -a看到全部文件（包括隐藏文件） ,ls -l查看文件的属性、大小等详细信息。 4.文本文件编辑命令 cat命令 cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。 *more 命令 * more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。 可以使用空格键或回车键向下翻页 head 命令 head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。 *tail 命令 * tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。 tr 命令 tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。 wc 命令 wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 stat 命令 stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。 cut 命令 cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。 diff 命令 diff 命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。 以使用–brief 参数来确认两个文件是否不同，还可以使用-c参数来详细比较出多个文件的差异之处， 5.文件目录管理命令touch 命令 touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。 创建tian.txt文件 1tian@tian-virtual-machine:~$ touch tian.txt mkdir 命令 mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。 创建tian文件夹 1tian@tian-virtual-machine:~$ mkdir tian cp 命令 cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。 参数 作用 -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -r 递归持续复制（用于目录） -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、 d、 r 为上述参数） 将tian.txt复制到tian文件夹 1tian@tian-virtual-machine:~$ cp tian.txt tian mv 命令 mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。 rm 命令 rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。 rm 命令后跟上-f 参数来强制删除。 想要删除一个目录，需要在 rm 命令后面一个-r 参数 dd 命令 dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。 file 命令 file 命令用于查看文件的类型，格式为“file 文件名”。 12tian@tian-virtual-machine:~&#x2F;tian$ file tian.txttian.txt: ASCII text 6.打包与压缩的命令 tar 命令 tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包内有哪些文件 -z 用 Gzip 压缩或解压 -j 用 bzip2 压缩或解压 -v 显示压缩或解压的过程 -f 目标文件名 -p 保留原始的权限与属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 将tian文件夹用 Gzip 压缩，并且显示压缩的过程，压缩文件命名为tian.gz 123tian@tian-virtual-machine:~$ tar -czvf tian.gz tiantian&#x2F;tian&#x2F;tian.txt grep 命令 grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。 参数 作用 -b 将可执行文件（binary）当作文本文件（text）来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择—仅列出没有“关键词”的行 在tian.txt文件中找“c”,结果只显示c的行数 12tian@tian-virtual-machine:~&#x2F;tian$ grep -n c tian.txt3:c find 命令 find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。 参数 作用 -name 匹配名称 -perm 匹配权限（mode 为完全匹配， -mode 为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n 指 n 天以内， +n 指 n 天以前） -atime -n +n 匹配访问文件的时间（-n 指 n 天以内， +n 指 n 天以前） -ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内， +n 指 n 天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件 –type b/d/c/p/l/f 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、 链接文件、文本文件） -size 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件） -prune 忽略某个目录 -exec …… {}; 后面可跟用于进一步处理搜索结果的命令（下文会有演示） 二、管道符、重定向与环境变量1.输入输出重定向输入重定向：把文件导入到命令中。 输出重定向：把原本要输出到屏幕的数据信息写入到指定文件中。 标准输出重定向: 错误信息不会被输出到重定向的文件里。 错误输出重定向: 错误信息也会输出到重定向的文件里。两者具体区别可以看下面的例子 ​ 输入重定向中用到的符号及其作用 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见分界符才停止 命令 &lt; 文件 1 &gt; 文件 2 将文件 1 作为命令的标准输入并将标准输出到文件 2 输出重定向中用到的符号及其作用 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的 后面） 例子： 1.将man ls的输出内容写到tian.txt文件里面去 1tian@tian-virtual-machine:~&#x2F;tian$ man ls &gt; tian.txt 2.用tian tian aaaa覆盖tian.txt里面的内容，tian tian bbbb追加在后面 123456tian@tian-virtual-machine:~&#x2F;tian$ echo &quot;tian tian aaaa&quot;&gt;tian.txttian@tian-virtual-machine:~&#x2F;tian$ cat tian.txttian tian aaaatian@tian-virtual-machine:~&#x2F;tian$ echo &quot;tian tian bbbb&quot;&gt;&gt;tian.txttian tian aaaatian tian bbbb 3.使用标准输出重定向（222是不存在的目录，瞎编的） 可以看到，第3行进行查看tian.txt，显示是空，说明错误提示并没有输入到tian.txt里 1234tian@tian-virtual-machine:~&#x2F;tian$ ls -l 222 &gt;tian.txtls: 无法访问&#39;222&#39;: 没有那个文件或目录tian@tian-virtual-machine:~&#x2F;tian$ cat tian.txttian@tian-virtual-machine:~&#x2F;tian$ 4.使用错误输出重定向（222是不存在的目录，瞎编的） 可以看到，第2行进行查看tian.txt，显示内容就是ls -l 222 2&gt;tian.txt的错误信息 1234tian@tian-virtual-machine:~&#x2F;tian$ ls -l 222 2&gt;tian.txttian@tian-virtual-machine:~&#x2F;tian$ cat tian.txtls: 无法访问&#39;222&#39;: 没有那个文件或目录tian@tian-virtual-machine:~&#x2F;tian$ 2.管道命令符（|）作用：把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入 3.命令行的通配符星号（*）：匹配零个或多个字符 问号（?）：代表匹配单个字符 [0-9] : 代表匹配 0～9之间的单个数字的字符,当然，括号里面的范围可以自己定义。 [abc] :则是代表匹配 a、 b、 c 三个字符中的任意一个字符。 4.常用的转义字符4 个最常用的转义字符如下所示。 反斜杠（\\）：使反斜杠后面的一个变量变为单纯的字符串。单引号（’’）：转义其中所有的变量为单纯的字符串。双引号（””）：保留其中的变量属性，不进行转义处理。反引号（``）：把其中的命令执行后返回结果。 例子： 1234tian@tian-virtual-machine:~&#x2F;tian$ echo uname -auname -atian@tian-virtual-machine:~&#x2F;tian$ echo &#96;uname -a&#96;Linux tian-virtual-machine 5.3.0-51-generic #44~18.04.2-Ubuntu SMP Thu Apr 23 14:27:18 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linux 5.重要的环境变量Linux 系统中最重要的 10 个环境变量 变量名称 作用 HOME 用户的主目录（即家目录） SHELL 用户在使用的 Shell 解释器名称 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 MAIL 邮件保存路径 LANG 系统语言、语系名称 RANDOM 生成一个随机数字 PS1 Bash 解释器的提示符 PATH 定义解释器搜索用户执行命令的路径 EDITOR 用户默认的文本编辑器 查看变量值，可以使用echo $变量,例如 1echo $PATH 我们完全可以自行创建变量，来满足工作需求。例如设置一个名称为 WORKDIR 的变量，方便用户更轻松地进入一个层次较深的目录： 12345tian@tian-virtual-machine:~$ mkdir tian&#x2F;zhu&#x2F;datian@tian-virtual-machine:~$ WORKDIR&#x3D;tian&#x2F;zhu&#x2F;datian@tian-virtual-machine:~$ cd $WORKDIRtian@tian-virtual-machine:~&#x2F;tian&#x2F;zhu&#x2F;da$ pwd&#x2F;home&#x2F;tian&#x2F;tian&#x2F;zhu&#x2F;da 三、Vim 编辑器与 Shell 命令脚本1.Vim 文本编辑器1.1三种模式 (1)命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。(2)输入模式：正常的文本录入。(3)末行模式：保存或退出文档，以及设置编辑环境。 在每次运行 Vim 编辑器时，默认进入命令模式 三种模式切换方法： 1.2 常用命令（1）命令模式中常用的一些命令 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的 5 行 yy 复制光标所在整行 5yy 复制从光标处开始的 5 行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 （2）末行模式中常用的一些命令 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档的修改内容） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个 one 替换成 two :s/one/two/g 将当前光标所在行的所有 one 替换成 two :%s/one/two/g 将全文中的所有 one 替换成 two ?字符串 在文本中从下至上搜索该字符串 /字符串 在文本中从上至下搜索该字符串 2.编写 Shell 脚本2.1编写一个简单脚本第一行的脚本声明（#!）用来告诉系统使用哪种 Shell 解释器来执行该脚本。 第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息。 第三、四行的可执行语句也就是我们平时执行的 Linux 命令了。 12345678910111213141516171819root@tian-virtual-machine:~# touch tiana.shroot@tian-virtual-machine:~# vim tiana.sh#!&#x2F;bin&#x2F;bash#一个简单脚本pwdls -a~~~~root@tian-virtual-machine:~# cat tiana.sh#!&#x2F;bin&#x2F;bash#一个简单脚本pwdls -aroot@tian-virtual-machine:~# bash tiana.sh&#x2F;root. .. .bash_history .bashrc .cache .gnupg .profile tiana.sh .viminforoot@tian-virtual-machine:~# 2.2 接收用户的参数一些字符的含义： $0 ：当前 Shell 脚本程序的名称 $#：参数总数 $*：对应的是所有位置的参数值 $?：对应的是显示上一次命令的执行返回值 $N：第 N 个位置的参数值 例子： 123456789101112131415161718tian@tian-virtual-machine:~$ vim tiana.sh#!&#x2F;bin&#x2F;bashecho &quot;当前脚本名称是$0&quot;echo &quot;当前总共有$#个参数，分别是$*&quot;echo &quot;第一个参数是$1&quot;~这里省略了一大堆“~”~&quot;tiana.sh&quot; [新] 8L, 123C 已写入 tian@tian-virtual-machine:~$ sh tiana.sh 1 2 3 4当前脚本名称是tiana.sh当前总共有4个参数，分别是1 2 3 4第一个参数是1tian@tian-virtual-machine:~$ 2.3判断用户的参数（1）文件判断 Shell 脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字 0，否则便返回其他随机数值。 条件测试语法的执行格式如下图所示，切记，条件表达式两边均应有一个空格。 运算符 作用 -d 测试文件是否为目录类型 -e 测试文件是否存在 -f 判断是否为一般文件 -r 测试当前用户是否有权限读取 -w 测试当前用户是否有权限写入 -x 测试当前用户是否有权限执行 文件测试所用参数表 （2）逻辑判断 还可以利用逻辑语句对测试结果进行逻辑分析，根据测试结果可实现不同的效果。 &amp;&amp;：表示当前面的命令执行成功后才会执行它后面的命令 。 || ：表示当前面的命令执行失败后才会执行它后面的命令 ！ ：表示把条件测试中的判断结果取相反值 例子(tian.sh是存在的，t.sh是不存在的)： 123456789101112root@tian-virtual-machine:~# ls -a. .. .bash_history .bashrc .cache .gnupg .profile tiana.sh tian.sh .viminforoot@tian-virtual-machine:~# [ -f tian.sh ]root@tian-virtual-machine:~# echo $?0root@tian-virtual-machine:~# [ -f tian.sh ] &amp;&amp; echo &quot;存在&quot;存在root@tian-virtual-machine:~# [ -f t.sh ] || echo &quot;存在&quot;存在root@tian-virtual-machine:~# [ ! -f tian.sh ] || echo &quot;存在&quot;存在root@tian-virtual-machine:~# 再来看一个复杂一点的例子： 12root@tian-virtual-machine:~# [ ! -f tian.sh ] &amp;&amp; echo &quot;不存在&quot; || echo &quot;存在&quot; 存在 （3）整数判断 整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作 运算符 作用 -eq 是否等于 -ne 是否不等于 -gt 是否大于 -lt 是否小于 -le 是否等于或小于 -ge 是否大于或等于 可用的整数比较运算符表 例子1： 12root@tian-virtual-machine:~# [ 10 -eq 10 ] &amp;&amp; echo &quot;10&#x3D;10&quot;10&#x3D;10 例子2：判断内存是否不足，小于1024内存不足 1234567891011121314151617181920root@tian-virtual-machine:~# free -m 总计 已用 空闲 共享 缓冲&#x2F;缓存 可用内存： 1958 878 442 9 638 914交换： 2047 0 2047root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot;内存： 1958 878 442 9 638 914root@tian-virtual-machine:~# free -m 总计 已用 空闲 共享 缓冲&#x2F;缓存 可用内存： 1958 878 442 9 638 914交换： 2047 0 2047root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot;内存： 1958 878 442 9 638 914root@tian-virtual-machine:~# free -m | grep &quot;内存：&quot; | awk &#39;&#123;print $4&#125;&#39;442root@tian-virtual-machine:~# FreeMem&#x3D;&#96;free -m | grep &quot;内存：&quot; | awk &#39;&#123;print $4&#125;&#39;&#96;root@tian-virtual-machine:~# echo $FreeMem441 root@tian-virtual-machine:~# [ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;内存不足&quot;内存不足root@tian-virtual-machine:~# free -m: 获取当前系统正在使用及可用的内存量信息，-m是以Mb显示。 grep &quot;内存：&quot;:只显示“内存”这一行。 awk &#39;{print $4}&#39;:只保留第四列 。 （4）.字符判断 运算符 作用 = 比较字符串内容是否相同 != 比较字符串内容是否不同 -z 判断字符串内容是否为空 例子： 123456root@tian-virtual-machine:~# [ fkjdk &#x3D; dslfk ]root@tian-virtual-machine:~# echo $?1root@tian-virtual-machine:~# [ ff &#x3D; ff ]root@tian-virtual-machine:~# echo $?0 2.4流程控制语句（1）if 条件测试语句 例子： 为了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据包的发送间隔，以及使用-W 参数定义等待超时时间 ，192.168.231.134是虚拟机ip地址 12345678910111213141516171819202122root@tian-virtual-machine:~# vim test_ping.sh#!bin&#x2F;bashping -c 3 -i 0.2 -w 3 $1 &amp;&gt; &#x2F;dev&#x2F;nullif [ $? -eq 0 ]then echo &quot;Host $1 is On-line&quot;else echo &quot;Host $1 is off-line&quot;fi~~~~~&quot;test_ping.sh&quot; 10L, 135C 已写入 root@tian-virtual-machine:~# bash test_ping.sh 192.168.231.134Host 192.168.231.134 is On-lineroot@tian-virtual-machine:~# bash test_ping.sh 192.168.231.133Host 192.168.231.133 is off-lineroot@tian-virtual-machine:~# （2）for 条件循环语句 例子：尝试让脚本从文本中自动读取主机列表（ip_test.txt），然后自动逐个测试这些主机是否在线。 $（命令）:执行括号或双引号括起来的命令。 /dev/null 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。 12345678910111213141516171819202122232425262728root@tian-virtual-machine:~# vim ip_test.txt192.168.231.134192.168.231.135192.168.231.136root@tian-virtual-machine:~# vim ip_test.sh#!&#x2F;bin&#x2F;bashHLIST&#x3D;$(cat ip_test.txt)for IP in $HLISTdo ping -c 3 -i 0.2 -w 3 $IP &amp;&gt; &#x2F;dev&#x2F;null if [ $? -eq 0 ] then echo &quot;HOST $IP is On-line&quot; else echo &quot;HOST $IP is off-line&quot; fidone~~&quot;ip_test.sh&quot; 13L, 197C 已写入 root@tian-virtual-machine:~# bash ip_test.shHOST 192.168.231.134 is off-lineHOST 192.168.231.135 is On-lineHOST 192.168.231.136 is off-lineroot@tian-virtual-machine:~# (3)while 条件循环语句 例子：编写一个用来猜测数值大小的脚本 guess.sh。 $RANDOM：调取出一个随机的数值（范围为 0～32767） expr：使用 expr 命令取得$RANDOM结果 read -p：读入用户输入的信息到后面的变量（INT），-p是添加提示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445root@tian-virtual-machine:~# vim guess.sh#!&#x2F;bin&#x2F;bashPRICE&#x3D;$(expr $RANDOM % 1000)TIMES&#x3D;0echo &quot;我这里有个宝贝价格在0~999之间，猜猜看是多少？&quot;while truedo read -p &quot;请输入你猜测的价格：&quot; INT let TIMES++ if [ $INT -eq $PRICE ] then echo &quot;恭喜你答对了！实际价格是$PRICE&quot; echo &quot;你共猜了$TIMES次&quot; exit 0 elif [ $INT -gt $PRICE ] then echo &quot;太高了！&quot; else echo &quot;太低了！&quot; fidone~~&quot;guess.sh&quot; 20L, 408C 已写入 root@tian-virtual-machine:~# bash guess.sh我这里有个宝贝价格在0~999之间，猜猜看是多少？请输入你猜测的价格：500太低了！请输入你猜测的价格：750太低了！请输入你猜测的价格：875太高了！请输入你猜测的价格：812太低了！请输入你猜测的价格：840太低了！请输入你猜测的价格：858太高了！请输入你猜测的价格：850太低了！请输入你猜测的价格：854太高了！请输入你猜测的价格：852恭喜你答对了！实际价格是852你共猜了9次 （4）case 条件测试语句 12345678910111213141516171819202122[root@linuxprobe ~]# vim Checkkeys.sh#!&#x2F;bin&#x2F;bashread -p &quot;请输入一个字符，并按 Enter 键确认： &quot; KEYcase &quot;$KEY&quot; in[a-z]|[A-Z])echo &quot;您输入的是 字母。 &quot;;;[0-9])echo &quot;您输入的是 数字。 &quot;;;*)echo &quot;您输入的是 空格、功能键或其他控制字符。 &quot;esac[root@linuxprobe ~]# bash Checkkeys.sh请输入一个字符，并按 Enter 键确认： 6您输入的是 数字。[root@linuxprobe ~]# bash Checkkeys.sh请输入一个字符，并按 Enter 键确认： p您输入的是 字母。[root@linuxprobe ~]# bash Checkkeys.sh请输入一个字符，并按 Enter 键确认： ^[[15~您输入的是 空格、功能键或其他控制字符。 2.5计划任务服务程序四、——用户身份与文件权限1.用户身份与能力1.1 useradd 命令useradd 命令用于创建新的用户，格式为“useradd [选项] 用户名”。 useradd 命令中的用户参数以及作用 参数 作用 -d 指定用户的家目录（默认为/home/username） -e 账户的到期时间，格式为 YYYY-MM-DD. -u 指定该用户的默认 UID -g 指定一个初始的用户基本组（必须已存在） -G 指定一个或多个扩展用户组 -N 不创建与用户同名的基本用户组 -s 指定该用户的默认 Shell 解释器 例子： 1234root@tian-virtual-machine:&#x2F;home&#x2F;tian# useradd -d &#x2F;tian&#x2F;zhu zhuroot@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhuuid&#x3D;1001(zhu) gid&#x3D;1001(zhu) 组&#x3D;1001(zhu)root@tian-virtual-machine:&#x2F;home&#x2F;tian# 1.2 groupadd 命令groupadd 命令用于创建用户组，格式为“groupadd [选项] 群组名”。 1.3usermod 命令usermod 命令用于修改用户的属性，格式为“usermod [选项] 用户名”。 usermod 命令中的参数及作用 参数 作用 -c 填写用户账户的备注信息 -d -m 参数-m 与参数-d 连用，可重新指定用户的家目录并自动把旧的数据转移过去 -e 账户的到期时间，格式为 YYYY-MM-DD -g 变更所属用户组 G 变更扩展用户组 -L 锁定用户禁止其登录系统 -U 解锁用户，允许其登录系统 -s 变更默认终端 -u 修改用户的 UID 例子：把用户zhu添加到root组 123root@tian-virtual-machine:&#x2F;home&#x2F;tian# usermod -G root zhuroot@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhuuid&#x3D;1001(zhu) gid&#x3D;1001(zhu) 组&#x3D;1001(zhu),0(root) 1.4passwd 命令passwd 命令用于修改用户密码、过期时间、认证信息等，格式为“passwd [选项] [用户名]”。 usermod 命令中的参数以及作用 参数 作用 -l 锁定用户，禁止其登录 -u 解除锁定，允许用户登录 –stdin 允许通过标准输入修改用户密码，如 echo “NewPassWord” | passwd –stdin Username -d 使该用户可用空密码登录系统 -e 强制用户在下次登录时修改密码 -S 显示用户的密码是否被锁定，以及密码所采用的加密算法名称 1.5userdel 命令userdel 命令用于删除用户，格式为“userdel [选项] 用户名” 。 userdel 命令的参数以及作用 参数 作用 -f 强制删除用户 -r 同时删除用户及用户家目录 例子： 123root@tian-virtual-machine:&#x2F;home&#x2F;tian# userdel zhuroot@tian-virtual-machine:&#x2F;home&#x2F;tian# id zhuid: &quot;zhu&quot;: no such user 2.文件权限与归属在 Linux 系统中，每个文件都有所属的所有者和所有组，并且规定了文件的所有者、所有组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。 文件的读、写、执行权限可以简写为 rwx，亦可分别用数字 4、 2、 1 来表示 。例如，若某个文件的权限为 7 则代表可读、可写、可执行（4+2+1）；若权限为 6 则代表可读、可写（4+2）。 例子： 12root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -l tian.txt-rw-rw-r-- 1 tian tian 14 7月 11 14:20 tian.txt 这里表示文件的所有者、所有组以及其他人对tian.txt的权限分别是读写、读写、读。 3.文件的特殊权限3.1 SUIDSUID 可以让二进制程序的执行者临时拥有属主的权限 （就是root） 平时用户的密码是存储在shadow文件中，通过查看可以发现，其他人对shadow三个权限都没有，那普通用户为什么可以通过passwd命令更改自己的密码呢？就是因为在passwd加上了SUID 特殊权限位 ，这样就可以使得普通用户在使用passwd命令时暂时地获得root权限，进行密码更改。 12root@tian-virtual-machine:~# ls -l &#x2F;etc&#x2F;shadow-rw-r----- 1 root shadow 1393 7月 14 23:26 &#x2F;etc&#x2F;shadow 3.2 SGIDSGID和SUID很像，只是SGID临时获得的是组的全线 SGID 主要实现如下两种功能： (1)让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）。(2)在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。 功能（1）例子：创建public_tian目录，并且更改目录权限 下面用到chmod 命令，能够用来设置文件或目录的权限，格式为“chmod [参数] 权限 文件或目录名称”。 12345678910111213# 创建public_tian目录root@tian-virtual-machine:&#x2F;home&#x2F;tian# mkdir public_tian# 查看权限root@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tiandrwxr-xr-x 2 root root 4096 7月 15 13:08 public_tian# 更改目录的权限为777，即rwxrwxrwx，root@tian-virtual-machine:&#x2F;home&#x2F;tian# chmod -Rf 777 public_tianroot@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tiandrwxrwxrwx 2 root root 4096 7月 15 13:08 public_tian# 添加SGID权限位root@tian-virtual-machine:&#x2F;home&#x2F;tian# chmod -Rf g+s public_tianroot@tian-virtual-machine:&#x2F;home&#x2F;tian# ls -ald public_tiandrwxrwsrwx 2 root root 4096 7月 15 13:08 public_tian 功能（2）例子： 使用命令为 chown，其格式为“chown [参数] 所有者:所属组 文件或目录名称”。 123456root@tian-virtual-machine:&#x2F;home# ls -ald zhudrwxrwxrwx 2 root root 4096 7月 15 14:02 zhu# 将目录zhu的所有者和所属组更改为zhuroot@tian-virtual-machine:&#x2F;home# chown zhu:zhu &#x2F;home&#x2F;zhuroot@tian-virtual-machine:&#x2F;home# ls -ald zhudrwxrwxrwx 2 zhu zhu 4096 7月 15 14:02 zhu 3.3 SBITSBIT 特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。 想对其他目录来设置 SBIT 特殊权限位，用 chmod 命令就可以了。对应的参数 o+t 代表设置 SBIT 粘滞位权限 例子： 12345root@tian-virtual-machine:&#x2F;home&#x2F;zhu# ls -ald newdrwxr-xr-x 2 root root 4096 7月 15 14:50 newroot@tian-virtual-machine:&#x2F;home&#x2F;zhu# chmod -R o+t newroot@tian-virtual-machine:&#x2F;home&#x2F;zhu# ls -ald newdrwxr-xr-t 2 root root 4096 7月 15 14:50 new 4.文件的隐藏属性4.1 chattr 命令chattr 命令用于设置文件的隐藏权限，格式为“chattr [参数] 文件”。 如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。 chattr 命令中用于隐藏权限的参数及其作用 参数 作用 i 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而 不能新建或删除文件 a 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only） S 文件内容在变更后立即同步到硬盘（sync） s 彻底从硬盘中删除，不可恢复（用 0 填充原文件所在硬盘区域） A 不再修改这个文件或目录的最后访问时间（atime） b 不再修改文件或目录的存取时间 D 检查压缩文件中的错误 d 使用 dump 命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复 t 让文件系统支持尾部合并（tail-merging） X 可以直接访问压缩文件中的内容 例子： 123456789101112131415# 查看目录，tian.txt存在root@tian-virtual-machine:&#x2F;home&#x2F;tian# lshh.txt public_tian tian tiana.sh tian.gz tian.txt users_test.txt zhu 公共的 模板 视频 图片 文档 下载 音乐 桌面# 使用chattr给tian.txt添加+a参数root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr +a tian.txt# 尝试删除，无法删除root@tian-virtual-machine:&#x2F;home&#x2F;tian# rm tian.txtrm: 无法删除&#39;tian.txt&#39;: 不允许的操作# 利用-a参数将限制去掉root@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr -a tian.txtroot@tian-virtual-machine:&#x2F;home&#x2F;tian# rm tian.txt# 查看目录，tian.txt已经被删除root@tian-virtual-machine:&#x2F;home&#x2F;tian# lshh.txt public_tian tian tiana.sh tian.gz users_test.txt zhu 公共的 模板 视频 图片 文档 下载 音乐 桌面root@tian-virtual-machine:&#x2F;home&#x2F;tian# 4.2 lsattr 命令lsattr 命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”。 例子： 1234567root@tian-virtual-machine:&#x2F;home&#x2F;tian# touch tian.txtroot@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr +a tian.txtroot@tian-virtual-machine:&#x2F;home&#x2F;tian# lsattr tian.txt-----a--------e--- tian.txtroot@tian-virtual-machine:&#x2F;home&#x2F;tian# chattr -a tian.txtroot@tian-virtual-machine:&#x2F;home&#x2F;tian# lsattr tian.txt--------------e--- tian.txt 5.文件访问控制列表如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。 5.1 setfacl 命令 setfacl 命令用于管理文件的 ACL 规则，格式为“setfacl [参数] 文件名称”。 使用 setfacl 命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。 针对目录文件需要使用-R 递归参数；针对普通文件则使用-m 参数；如果想要删除某个文件的 ACL，则可以使用-b 参数。 5.2 getfacl 命令getfacl 命令用于显示文件上设置的 ACL 信息，格式为“getfacl 文件名称”。 例子： 12345678root@tian-virtual-machine:~# getfacl &#x2F;home&#x2F;tian&#x2F;zhugetfacl: 从绝对路径名尾部去除&quot; &#x2F; &quot;字符。# file: home&#x2F;tian&#x2F;zhu# owner: root# group: rootuser::rwxgroup::r-xother::r-x 6. su 命令与 sudo 服务6.1 su 命令su 命令可以切换用户身份，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从 root 管理员切换至普通用户： 例子： 1234root@tian-virtual-machine:~# su - zhu$ su - root密码： root@tian-virtual-machine:~# 上面的 su 命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）。 6.2 sudo 服务普通用户可以完全切换到 root 管理员身份来完成相应工作，但这将暴露 root 管理员的密码，从而增大了系统密码被黑客获取的几率；这并不是最安全的方案。 sudo 命令用于给普通用户提供额外的权限来完成原本 root 管理员才能完成的任务，格式为“sudo [参数] 命令名称”。 sudo 服务中的可用参数以及作用 参数 作用 -h 列出帮助信息 -l 列出当前用户可执行的命令 -u 用户名或 UID 值 以指定的用户身份执行命令 -k 清空密码的有效时间，下次执行 sudo 时需要再次进行密码验证 -b 在后台执行指定的命令 -p 更改询问密码的提示语 五、存储结构与磁盘划分1.常见的目录 Linux 系统中常见的目录名称以及相应内容 目录名称 应放置文件的内容 /boot 开机所需文件—内核、开机菜单以及所需配置文件等 /dev 以文件形式存放任何设备与接口 /etc 配置文件 /home 用户家目录 /bin 存放单用户模式下还可以操作的命令 /lib 开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数 /sbin 开机过程中需要的命令 /media 用于挂载设备文件的目录 /opt 放置第三方的软件 /root 系统管理员的家目录 /srv 一些网络服务的数据文件目录 /tmp 任何人均可使用的“共享”临时目录 /proc 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等 /usr/local 用户自行安装的软件 /usr/sbin Linux 系统开机时不会使用到的软件/命令/脚本 /usr/share 帮助与说明文件，也可放置共享文件 /var 主要存放经常变化的文件，如日志 /lost+found 当文件系统发生错误时，将一些丢失的文件片段存放在这里 绝对路径指的是从根目录（/）开始写起的文件或目录名称 2.物理设备的命名规则常见的硬件设备及其文件名称 硬件设备 文件名称 IDE 设备 /dev/hd[a-d] SCSI/SATA/U 盘 /dev/sd[a-p] 软驱 /dev/fd[0-1] 打印机 /dev/lp[0-15] 光驱 /dev/cdrom 鼠标 /dev/mouse 磁带机 /dev/st0 或/dev/ht0 3.文件系统与数据资料这一章剩下的暂时省略，学下面的先 七、——使用 RAID 与 LVM 磁盘阵列技术也先省略 第八章——iptables 与 firewalld 防火墙","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://tetedetian.github.io/tags/Linux/"}]},{"title":"Hexo问题解决","slug":"Hexo问题解决","date":"2020-09-06T03:24:06.931Z","updated":"2020-09-26T06:20:49.342Z","comments":true,"path":"2020/09/06/Hexo问题解决/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/Hexo%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"这里有一些hexo功能的使用方法以及注意点（我踩过的坑...）","text":"这里有一些hexo功能的使用方法以及注意点（我踩过的坑...） 1.如何给文章添加标签1.1 方法一1.2 方法二建立一个标签配置文件 在博客文件夹下，执行下面的命令 1hexo new page tags 执行后，会在source文件夹里创建一个tags文件夹，tags文件夹里会生成一个index.md文件，这个文件是用来配置你的标签的，文件内容参考下面的样例进行更改 注意：冒号“:”后面要有一个空格 12345---title: 博客搭建与运营date: 2020-07-05 01:04:45type: &quot;tags&quot;--- 如上所示，title对应你的标签名，你想要啥名字就写啥。type: “tags”是用来说明这是在配置标签的，不要改动。 给文章添加标签 打开文章，在文章开头添加下列文本。这里的tags后面就是你希望这个文章打上的标签名 注意：冒号“:”后面要有一个空格，不然“tags: [博客搭建与运营]”会被当成文章内容显示，并且不会归类到[博客搭建与运营]标签上。 123---tags: [博客搭建与运营]--- 2. github打不开事情是这样的：本来博客是好好的，但是突然有一天我发现博客打不开了，错误提示如下： 谷歌浏览器： 搜狗浏览器： 后来发现，把电脑的DNS服务器地址改为某些地址时，博客就可以打开，例如：1.1.1.1。通过让朋友尝试发现，有的网络可以打开，有的不行。基于此，虽然不知道具体原因，但是知道大概是一些运营商网络无法访问到github服务器。于是，我找到了一个解决方法：使用vercel进行间接访问 教程在这篇博客：点这里 说明： 1.qq邮箱无法注册vercel,163邮箱和谷歌邮箱都可以，因此，如果你的github绑定的是你的qq邮箱，需要去github官网把邮箱换一下。 添加邮箱并设置为主要邮箱之后就可以使用github账号注册了。 2.如果没有自己的域名的话，那做完Deploy那一步也就可以了，之后，你就可以使用 vercel项目名.vercel.app进行访问你的博客了。之后你更新博客的话，一样是把你的博客推到github仓库，vercel会自动部署。 3.如何在一台电脑使用2个github账号部署2个博客请转至另一篇博客，点这里 4. 博客里某一篇文章打不开我曾经出现过这个问题，后来发现是文章的文件名（是文件名，不是文章的title）包含了特殊字符导致的（比如+），把文件名的一些特殊字符去掉就可以了。","categories":[],"tags":[{"name":"博客搭建与运营","slug":"博客搭建与运营","permalink":"https://tetedetian.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/"}]},{"title":"Welcome here","slug":"hello-world","date":"2020-09-06T03:24:06.917Z","updated":"2020-07-24T05:06:37.529Z","comments":true,"path":"2020/09/06/hello-world/","link":"","permalink":"https://tetedetian.github.io/2020/09/06/hello-world/","excerpt":"————欢迎来到我的博客~————","text":"————欢迎来到我的博客~————","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://tetedetian.github.io/tags/c/"},{"name":"Github","slug":"Github","permalink":"https://tetedetian.github.io/tags/Github/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://tetedetian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://tetedetian.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"博客搭建与运营","slug":"博客搭建与运营","permalink":"https://tetedetian.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/"},{"name":"数据库","slug":"数据库","permalink":"https://tetedetian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Linux","slug":"Linux","permalink":"https://tetedetian.github.io/tags/Linux/"}]}