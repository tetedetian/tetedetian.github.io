<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#3.0-beta1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
  <title>数据结构与算法题解 - 特特的天</title>
  

  
    <meta name="description" content="

——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  
  
</head>

<body>
  
  
  
  <div class="cover-wrapper">
    <cover class='cover post' style="display: none;">
      <div class='cover-body'>
  <div class='a'>
    
      <img class='logo' src='https://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/welcome_here.png'/>
    
    
      <p class="title">特特的天</p>
    
    
      <p class="subtitle">While there is life there is hope</p>
    
  </div>
  <div class='b'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="搜索" />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <ul class='cover-list-h'>
        
          
            <li>
              <a class="nav home"
                href="/"
                
                
                id="home">
                <i class='fas fa-rss fa-fw'></i>主页
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/archives/"
                
                
                id="archives">
                <i class='fas fa-archive fa-fw'></i>博文
              </a>
            </li>
          
            <li>
              <a class="nav home"
                href="/tags/"
                
                
                id="tags">
                <i class='fas fa-tags fa-fw'></i>标签
              </a>
            </li>
          
        
      </ul>
    </div>
  </div>
</div>

      <div class="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
    </cover>
    <header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h' id="pjax-header-nav-list">
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            特特的天
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=https://tetedetian.github.io/
                  
                  
                  
                    id="https:tetedetiangithubio"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=https://tetedetian.github.io/
                  
                  
                  
                    id="https:tetedetiangithubio"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

  </div>
  

  <div class="l_body nocover">
    <div class='body-wrapper' id="pjax-container">
      
        <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->



<div id="pjax-data" style="display: none">
  <div id="pjax-ispage">true</div>
  <div id="pjax-pageTitle">数据结构与算法题解</div>
  <div id="pjax-enable-cover">true</div>
  
  <div id="valine-path">none</div>
  <div id="valine-placeholder">none</div>
  
  
</div>


<script>
  // 处理封面 此时 jquery 还没加载
  if ("none" == "none") { // 移除封面
    document.getElementsByClassName('cover')[0].style.display = "none";
    document.getElementsByClassName('l_body')[0].classList.add("nocover");
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.add("show");
  } else {
    if ("none" == "blog") { // 半屏
      document.getElementsByClassName('cover')[0].classList.remove("full");
      document.getElementsByClassName('cover')[0].classList.add("half");
      document.getElementsByClassName('scroll-down')[0].style.display = "none";
    } else if ("none" == "docs") { // 全屏
      document.getElementsByClassName('cover')[0].classList.remove("half");
      document.getElementsByClassName('cover')[0].classList.add("full");
      document.getElementsByClassName('scroll-down')[0].style.display = "";
    }
    document.getElementsByClassName('cover')[0].style.display = "";
    document.getElementsByClassName('l_body', 'show')[0].classList.remove("nocover");
    document.getElementsByClassName('l_header', 'cover-wrapper')[0].classList.remove("show");
  }
</script>

      
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">
      数据结构与算法题解
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://tetedetian.github.io//" rel="nofollow">
    <img no-lazy src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>特特的天</p>
  </a>
</div>

            
          
            
              

            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Sep 6, 2020</p>
  </a>
</div>

            
          
            
              
  <div class="new-meta-item browse valine">
    <a class='notlink'>
      <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/" class="leancloud_visitors" data-flag-title="数据结构与算法题解">
      <p>
        <span class="leancloud-visitors-count"></span>
      </p>
      </span>
    </a>
  </div>


            
          
            
              
<div class="new-meta-item comments-count">
  
  <a href="/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/#comments">
    <i class="fas fa-comment-dots fa-fw"></i>
    <span class="valine-comment-count" data-xid="/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">0</span>
    <span class="leancloud-comments-count">&nbsp;</span>
  </a>
</div>


            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          
          <hr>
<hr>
<div align="center">——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——</div>



<a id="more"></a>



<h1 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h1><h2 id="1-无重复字符的最长子字符串"><a href="#1-无重复字符的最长子字符串" class="headerlink" title="1.无重复字符的最长子字符串"></a>1.无重复字符的最长子字符串</h2><p><strong>题目：</strong>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 :</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>思路很简单，就是从利用双指针+哈希表，先固定左指针，然后移动右指针，每次就判断右指针的字符是否存在于哈希表，不存在就把它投放到哈希表里，一直到到右指针碰到重复的字符，就记录左右指针之间不重复子串的长度。然后移动左指针，开始下一轮判断。</p>
<p>因为这是求最长子串的长度，自然子串的左端是字符串的其中一个字符，那我们不妨从第一个字符开始判断。</p>
<blockquote>
<p>1.定义两个变量，记录子串的左端点和右端点，右端点不断往右移动，直到遇到与左右端点之间重复的字符为止。</p>
<p>2.用一变量num记录下两端点之间不重复的字符串长度（其实就是用右变量减左变量）</p>
<p>3.将左端点向右移动一个字符，右端点保持不动，然后又开始判断左右端点间有没有重复，重复就右移，和上面的一样，最后更新num。</p>
</blockquote>
<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//哈希集合，存放字符，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="comment">//right记录右端点，设置初始值是0；num是记录最长子串长度的变量</span></span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//左端点向右移动一格（也就是i加1），从哈希集合里移除s[i-1]（因为现在s[i-1]已经不在左右端点之间了）</span></span><br><span class="line">                occ.erase(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*!occ.count(s[right])如果是0，代表哈希集合里面有s[right]，则while&#123;&#125;里的代码不会运行，也就是不会往			  里面添加字符。*/</span></span><br><span class="line">             <span class="keyword">while</span> (right&lt;s.<span class="built_in">size</span>()&amp;&amp; !occ.count(s[right]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//右指针往右移动了，往哈希集合里添加一个字符</span></span><br><span class="line">                occ.insert(s[right]);</span><br><span class="line">                <span class="comment">//右端点加1</span></span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新num</span></span><br><span class="line">            num=<span class="built_in">max</span>(num,right-i);<span class="comment">//num是前面所有子串中最大值，right是此次左右端点之间的差，也就是此次子串长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2.最长回文子串"></a>2.最长回文子串</h2><p><strong>题目：</strong>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p>示例 :</p>
<blockquote>
<p><strong>示例 1：</strong></p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
<p><strong>示例 2：</strong></p>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<p><strong>解题思路1：</strong></p>
<blockquote>
<p>使用<strong>动态规划,</strong>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 ababa，如果我们已经知道 bab 是回文串，那么ababa一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>
<p>根据这一思想总结：</p>
<p>1.我们可以把编程思路定为填写下面的表格的右上方（因为坐下方是非法的：右边界&lt;左边界），如果是回文串就填true（1），不是回文串就填false（0）。</p>
<p>2.因为ababa是不是回文的，可以根据bab 是不是回文串来决定，根据表格规律，可发现，某个空格应该填是1或0，是根据左下角来确定的。所以填表顺序应该是斜着来，从左上方斜往右下方。根据图表，可见斜线上的左右边界之间的差值是相等的。因此在写程序时，我们就可以先考虑填左右边界差值为0的，再到1的、2的。。。。</p>
<p>3.对角线都是只有一个字符，肯定是回文的，因此可以先全部填0。</p>
<p>根据上面的思路总结，可以得到下面的题解</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201118202850675.png" alt="image-20201118202850675" style="zoom:67%;" />


</blockquote>
<p><strong>题解：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();<span class="comment">//n为输入字符串的长度</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;<span class="comment">//定义一个二维数组dp，就是相当于上面的表格，用来存储判断结果的</span></span><br><span class="line">        <span class="built_in">string</span> ans;<span class="comment">//记录最终的返回结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;n;++l)<span class="comment">//定义l来代表左右边界之间的差值（这一点在上面有解释为什么）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+l&lt;n;++i)<span class="comment">//i是左边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//j是右边界</span></span><br><span class="line">                <span class="keyword">int</span> j=i+l;</span><br><span class="line">                <span class="comment">//l==0也就是只有一个字符，肯定是回文的</span></span><br><span class="line">                <span class="keyword">if</span>(l==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//l==1，也就是只有两个字符，是不是回文的，判断两个字符是否相等即可</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=(s[i]==s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//其他的点，判断是不是回文的，就要回归上面说的，需要根据数据的左下角以及左右边界来判断。左下角为真，且左右边界相等，那么就是回文的（真），这个逻辑关系可以用与或关系来表示。</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是回文的，长度（差值+1）又大于之前存储的ans的长度，就更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;(l+<span class="number">1</span>)&gt;ans.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    ans=s.substr(i,l+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-左旋转字符串"><a href="#3-左旋转字符串" class="headerlink" title="3.左旋转字符串"></a>3.左旋转字符串</h2><p><strong>题目</strong>：</p>
<p>把字符串前面的若干个字符转移到字符串的尾部</p>
<p><strong>示例</strong> 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>


<p><strong>示例</strong> 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>直接利用string容器的一些操作函数。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">News</span><span class="params">(s)</span></span>;<span class="comment">//创建新的string变量News，并调用有参构造，将s赋值给News</span></span><br><span class="line">        News.erase(<span class="number">0</span>,n);<span class="comment">//删除News位置为0到n的字符</span></span><br><span class="line">        News.append(s,<span class="number">0</span>,n);<span class="comment">//将s的0到n字符串拼接到News后面</span></span><br><span class="line">        <span class="keyword">return</span> News;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-翻转单词顺序"><a href="#4-翻转单词顺序" class="headerlink" title="4.翻转单词顺序"></a>4.翻转单词顺序</h2><p><strong>题目</strong>：</p>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>示例</strong>：</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>


<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>:</p>
<p>1.先把字符串首尾的空格去除。因为c++没有去除首尾字符串的内置函数，可以采用定义左边界left和右边界right的方法。把空格排除在边界外。</p>
<p>2.利用双指针，从左到右寻找单词的左右节点。</p>
<p>3.每一次双指针找到边界后，将单词拼接到新字符串上，并且拼接空格</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//left作为左端点，right作为右端点</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[left] == <span class="string">' '</span>) ++left;</span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s[right] == <span class="string">' '</span>) --right;</span><br><span class="line">        <span class="comment">//用来决定每次循环单词的边界的</span></span><br><span class="line">        <span class="keyword">int</span> i=right;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="built_in">string</span> Newstr;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//i向左移动，直到不是空格停止，也就是单词的右边界</span></span><br><span class="line">            <span class="keyword">while</span>((i&gt;=left)&amp;&amp;(s[i]==<span class="string">' '</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把右边界赋值给j</span></span><br><span class="line">            j=i;</span><br><span class="line">            <span class="comment">//i继续移动，直到碰到第一个空格的地方</span></span><br><span class="line">            <span class="keyword">while</span>((i&gt;=left)&amp;&amp;(s[i]!=<span class="string">' '</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i+1到j就是单词，把s字符串从i+1位置起j-i个字符拼接到Newstr末尾</span></span><br><span class="line">            Newstr.append(s,i+<span class="number">1</span>,j-i);</span><br><span class="line">            <span class="comment">//单词之间的空格</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=left) Newstr.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newstr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-字符串转换整数"><a href="#5-字符串转换整数" class="headerlink" title="5.字符串转换整数"></a>5.字符串转换整数</h2><p><strong>题目</strong>：</p>
<p>实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>1.如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</p>
<p>2.假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</p>
<p>3.该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</p>
<p><strong>注意</strong>：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示</strong>：本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p><strong>示例</strong>：</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>


<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。  因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p>
<p>换个说法，就是我们可以这样操作：定义一个类，可以实现根据上次的状态以及输入字符来决定这次的状态。然后根据这次的状态来决定这次的操作。</p>
<p>根据问题的描述，可以得到各个状态遇到不同字符之后会转变到什么状态。</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201213204811274.png" alt="image-20201213204811274" style="zoom: 50%;" />

<p>表示为图表，如下</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201213205258255.png" alt="image-20201213205258255" style="zoom:67%;" />

<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自动机类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automaton</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> state = <span class="string">"start"</span>;<span class="comment">//状态</span></span><br><span class="line">    <span class="comment">//定义一个unordered_map容器，键值为string类型，实值是vector类型。</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">"start"</span>, &#123;<span class="string">"start"</span>, <span class="string">"signed"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"signed"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"in_number"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"in_number"</span>, <span class="string">"end"</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"end"</span>, &#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//控制数值返回函数，会根据传递的字符参数返回对应的0-3控制数值（vector有四个元素）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_col</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//isspace（c）会检查c是不是空格</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//isdigit（c）会检查c是不是十进制数值1-9</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;<span class="comment">//决定正负的函数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//数值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = table[state][get_col(c)];<span class="comment">//根据字符c得到下一个状态</span></span><br><span class="line">        <span class="comment">//如果状态是“in_number”的话，说明可以开始录入数字了</span></span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">"in_number"</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + c - <span class="string">'0'</span>;<span class="comment">//c这时候还是字符，需要通过-‘0’来装换成整数</span></span><br><span class="line">            ans = sign == <span class="number">1</span> ? <span class="built_in">min</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MAX) : <span class="built_in">min</span>(ans, -(<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断正负</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">"signed"</span>)</span><br><span class="line">            sign = c == <span class="string">'+'</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        Automaton automaton;<span class="comment">//声明一个自动机对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            automaton.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h2><p><strong>题目</strong>：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>:</p>
<p>大体思路:其实很简单，就是和平时算数一样，从低位开始相加，然后定义变量记录每次相加的结果，再定义变量记录是由需要进位。并且定义新的节点类型记录每次的计算结果。</p>
<p><strong>具体思路</strong>：定义新的头节点指针head，定义记录每次两数相加的和的变量sum，定义变量carry记录是否需要进位，定义一个节点指针指向新链表的尾部（保持指向尾部）（用于创建新的节点来存储数据）。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*定义一个addTwoNumber函数，参数类型是两个节点指针（节点是力扣系统自己定义好的了）*/</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//定义一个名为head的头节点，节点值为-1，head-&gt;next=NULL</span></span><br><span class="line">        ListNode* h=head;<span class="comment">//定义一个移动指针</span></span><br><span class="line">        <span class="keyword">int</span> sum;<span class="comment">//用来记录每位的和</span></span><br><span class="line">        <span class="keyword">bool</span> carry=<span class="number">0</span>;<span class="comment">//控制进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)<span class="comment">//当l1或者l2为NULL的时候，已经没有数据了，自然需要停止了</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum=<span class="number">0</span>;<span class="comment">//每个循环都需要置零</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)<span class="comment">//l1就是个指针，第一轮循环指向的就是例子中的2</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l1-&gt;val;<span class="comment">//就是sum=l1-&gt;val+sum</span></span><br><span class="line">                l1=l1-&gt;next;<span class="comment">//将l1指向下一个节点，下一个循环可以用</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=l2-&gt;val;<span class="comment">//结合前面的if语句，这里其实sum=l1-&gt;val+l2-&gt;val</span></span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(carry) sum++;<span class="comment">//carry是记录进位的，第一轮的话没有进位，carry就是初始值0</span></span><br><span class="line">            h-&gt;next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//new ListNode(sum%10)开辟一个新节点，用来存储相加的结果</span></span><br><span class="line">            h=h-&gt;next;<span class="comment">//把h指针=刚才开辟的节点的next指针，方便下个循环接着这次开辟节点继续开辟</span></span><br><span class="line">            carry=sum&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;<span class="comment">//如果sum&gt;=10，carry=1，否则carry=0；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*这一步是在所有循环结束后的，如果最后carry=1，代表有进位，那么最高位应该增加一个1*/</span></span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;<span class="comment">//返回头节点</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2.合并两个有序链表"></a>2.合并两个有序链表</h2><p><strong>题目</strong>：</p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>可以使用递归的方法，非常简单巧妙的解决问题：先定义两个指针，指向l1和l2的头部，然后判断l1和l2谁的的第一个元素更加小，然后使小的一方的next指向mergeTwoLists(小的一方-&gt;next,大的一方)。有点难说明白，看代码吧</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="comment">//判断l1是否为0，为0的话就直接返回l2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val)<span class="comment">//判断大小</span></span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next=mergeTwoLists(l1-&gt;next,l2);<span class="comment">//使用递归</span></span><br><span class="line">            <span class="keyword">return</span> l1;<span class="comment">//因为这里是l1-&gt;val&lt;l2-&gt;val，所以l1才是头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3.反转链表"></a>3.反转链表</h2><p><strong>题目</strong>：</p>
<p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>使用递归的思想。题目的解决可以分为两个问题：1.找到反转后的头节点，也就是反转前的尾节点。2.将链表反转。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*head == NULL的情况时链表本来就是空的情况。head-&gt;next == NULL是到了最后一个节点的情况，例如例子中的5。还有就是下面会使用递归，这个条件就代表已经递归到最后一个节点了*/</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* Newhead = reverseList(head-&gt;next);<span class="comment">//定义一个名为Newhead的ListNode类型指针来作为新链表的头节点。</span></span><br><span class="line">    head-&gt;next-&gt;next = head;<span class="comment">//反转操作。在第一轮了，head就是4的节点。那head-&gt;next-&gt;next其实就是5-&gt;</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Newhead;<span class="comment">//返回新链表的头节点。这里的p，其实在递归的最深层已经决定了，就是5的节点。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4.两两交换链表中的节点"></a>4.两两交换链表中的节点</h2><p><strong>题目</strong>：</p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><strong>示例</strong>：</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>


<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>


<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链表中节点的数目在范围 [0, 100] 内</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>思路其实就是，每两个节点为一次操作。比如1-&gt;2-&gt;3-&gt;4，就要想办法将2-&gt;1,1-&gt;4,4-&gt;3。那就可以分解为。</p>
<p>1.定义两个节点指针指向1,2，然后操作2-&gt;1,1-&gt;3。</p>
<p>2.定义一个指针来指向1,到下一轮就操作这个指针的next指向新一轮的节点2。</p>
<p>3.重新head的指向。（head是用来判断是否到结尾以及确定下一轮节点指针1,2的指向的）</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;<span class="comment">//判断是否为空表，没有这句的话，一旦是空表，下面的head-&gt;next就不存在了，会报错</span></span><br><span class="line">        ListNode* Newhead = head-&gt;next;<span class="comment">//建立Newhead，指向第二个节点，后面不再改变Newhead，最后直接返回Newhead就可以</span></span><br><span class="line"></span><br><span class="line">        ListNode* curr = head;<span class="comment">//curr是用来指向每次换两两节点后排后面的节点，为了使得上一轮交换后排后面的节点能够指向正确的节点。在第一第二轮中，就是为了使得1能够指向4。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span> &amp;&amp; head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新建两个节点指针firstNote和secondNode,用于改变节点指向。</span></span><br><span class="line">            ListNode* firstNode = head;<span class="comment">//节点指针1指向每两个节点的第一个</span></span><br><span class="line">            ListNode* secondNode = head-&gt;next;<span class="comment">//节点指针2指向每两个节点的第二个</span></span><br><span class="line"></span><br><span class="line">            curr-&gt;next=secondNode;<span class="comment">//把上一轮交换后的后面节点指向新的节点2</span></span><br><span class="line">            </span><br><span class="line">            firstNode-&gt;next = secondNode-&gt;next;<span class="comment">//指向节点2的next（这只是为了后面重新安排新的head）</span></span><br><span class="line">            </span><br><span class="line">            secondNode-&gt;next = firstNode;</span><br><span class="line">            </span><br><span class="line">            curr = firstNode;<span class="comment">//回归curr的作用，curr自然是等于firstNode，因为firstNode排后面</span></span><br><span class="line">            </span><br><span class="line">            head = firstNode-&gt;next;<span class="comment">//重新安排下一轮的head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Newhead;<span class="comment">//Newhead就是指向第二个节点的指针，在第一轮就决定了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-删除链表中的节点"><a href="#5-删除链表中的节点" class="headerlink" title="5.删除链表中的节点"></a>5.删除链表中的节点</h2><p><strong>题目</strong>：</p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<p><strong>示例</strong>：</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>定义一个节点指针，然后使得指针逐一递增，并且判断，如果遇到要删除的节点的话就把需要删除的节点前一节点的指针指向下一节点。最后依旧返回head</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p1=head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;<span class="comment">//判断是不是第一个节点就是要删除的节点。</span></span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;next-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                p1-&gt;next=p1-&gt;next-&gt;next;<span class="comment">//把需要删除的节点前一节点的指针指向下一节点</span></span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><p><strong>题目</strong>：</p>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>可以利用递归，从最后一个节点逐一插入到一个数组里</p>
<p><strong>题解</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        &#x2F;&#x2F;利用递归，从尾部往回，每次往vector&lt;int&gt;类型的a插入元素，最后就得到结果了</span><br><span class="line">        if(!head) return &#123;&#125;;</span><br><span class="line">        vector&lt;int&gt; a&#x3D;reversePrint(head-&gt;next);</span><br><span class="line">        a.push_back(head-&gt;val);&#x2F;&#x2F;push_back(val)，尾部插入元素val</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="7-两个链表的第一个公共节点。"><a href="#7-两个链表的第一个公共节点。" class="headerlink" title="7.两个链表的第一个公共节点。"></a>7.两个链表的第一个公共节点。</h2><p><strong>题目</strong>：</p>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p><strong>示例</strong>：</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201207165154473.png" alt="image-20201207165154473" style="zoom: 80%;" />

<p>返回c1</p>
<p><strong>思路</strong>：</p>
<p>使用双指针法：定义指针p1指向链表A的头部，指针p2指向链表B的头部。然后两个逐一往后移动，同时判断两个指针是否相等。p1移动到A尾部后，就从B头部开始继续移动。同样，p2移动到B尾部后，就从A头部继续移动。这样，在下一轮两个指针就会在交点相遇。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* p1=headA;<span class="comment">//定义指针p1</span></span><br><span class="line">        ListNode* p2=headB;<span class="comment">//定义指针p2</span></span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=(p1!=<span class="literal">NULL</span>?p1-&gt;next:headB);<span class="comment">//语句的意思：如果p1！=NULL成立，p1=p1-&gt;next,否则p1=headB</span></span><br><span class="line">            p2=(p2!=<span class="literal">NULL</span>?p2-&gt;next:headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="8-链表中倒数第k个节点"><a href="#8-链表中倒数第k个节点" class="headerlink" title="8.链表中倒数第k个节点"></a>8.链表中倒数第k个节点</h2><p><strong>题目</strong>：</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>定义一个全局变量num，然后利用递归，递归操作为触底反弹后num++，如果num&lt;=k,就返回head</p>
<h2 id="9-复杂链表的复制"><a href="#9-复杂链表的复制" class="headerlink" title="9.复杂链表的复制"></a>9.复杂链表的复制</h2><p><strong>题目</strong>：</p>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p> <strong>示例</strong>：</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201208200353762.png" alt="image-20201208200353762" style="zoom: 80%;" />

<p><strong>思路</strong>：</p>
<p>（1）<strong>迭代</strong></p>
<p>1.先依次把每个节点拷贝并且插入到与下一个节点的中间。2.再给每个拷贝的节点的random赋值（因为新节点之间都是隔着一个旧节点，间隔是固定的，每次走两步，就能操作到每个新节点）。3.把新旧节点之间的next指向正确的节点。</p>
<p><strong>题解</strong>：</p>
<p>（1）<strong>迭代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//如果是空表，直接返回NULL</span></span><br><span class="line">        Node* cur=head;<span class="comment">//用来迭代操作的节点指针</span></span><br><span class="line">        <span class="comment">/*1.把每个节点拷贝并且插入到与下一个节点的中间*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* Newnode=<span class="keyword">new</span> Node(cur-&gt;val);<span class="comment">//创建一个节点指针，指向新创立的节点</span></span><br><span class="line">            <span class="comment">//新节点插入操作</span></span><br><span class="line">            Newnode-&gt;next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=Newnode;</span><br><span class="line">            <span class="comment">//重新赋值cur</span></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*2.拷贝新链表的random*/</span></span><br><span class="line">        cur=head;<span class="comment">//重新使cur回到头部</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//拷贝random。注意：cur-&gt;random可能是NULL（是NULL的话，就不存在cur-&gt;random-&gt;next了）。因此必须添加对cur-&gt;random是否等于NULL的判断。</span></span><br><span class="line">            cur-&gt;next-&gt;<span class="built_in">random</span>=(cur-&gt;<span class="built_in">random</span>!=<span class="literal">NULL</span>)?cur-&gt;<span class="built_in">random</span>-&gt;next:<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//对下一轮cur进行赋值</span></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*3.调整每个节点的next*/</span></span><br><span class="line">        Node* Newhead=head-&gt;next;<span class="comment">//新链表的头结点</span></span><br><span class="line">        Node* pur;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pur=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            cur=pur;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> Newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p><strong>题目</strong>：</p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>（1）<strong>暴力法</strong></p>
<p>暴力法很简单。就是不断地枚举nums中的元素，看看哪两个元素加起来等于target。</p>
<p>（2）<strong>哈希表</strong></p>
<p>利用哈希表，存储数组的元素以及对应的下标。然后检查数组的每一个元素x对应的target-x能否在哈希表里面找到。找到的话，数组元素对应的下标和哈希表元素对应的键值就是所求。（其实就是双数组思想）</p>
<p><strong>暴力法题解</strong>：</p>
<p><strong>哈希表解法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;<span class="comment">//定义一个哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);<span class="comment">//在哈希表里面寻找符合target-x的数，赋值给it</span></span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>())<span class="comment">//如果it != hashtable.end()，也就是哈希表里面存在target-x的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;<span class="comment">//那么返回&#123;it-&gt;second, i&#125;，it-&gt;second是迭代器指向对应的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;<span class="comment">//给哈希表赋值（注意，这题解是把nums数组的值赋给哈希的键值。（因为题目说明数组元素不会重复，这倒是无所谓））</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-数组中重复的值"><a href="#2-数组中重复的值" class="headerlink" title="2.数组中重复的值"></a>2.数组中重复的值</h2><p><strong>题目</strong>：</p>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>使用迭代，i=0到i&lt;nums.size(),判断nums[i]是否等于nums[nums[i]],等于的话，说明nums[i]肯定重复了。不等于的话，就把nums[i]放到nums[nums[i]]的位置。这样不断迭代下去，数值i就会不断被放到数组下标为i的位置。这样下去，当重复的数字被第二次归位，就会发现它的位置以及有“它”了，也就是nums[i]等于nums[nums[i]]。那么它就是要找的结果之一。</p>
<p>换个简单的描述就是，从头到尾，把数组的值nums[i]归位到数组下标为nums[i]的位置。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断nums[i]是否等于nums[nums[i]]，等于的话，说明nums[i]肯定重复了</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="comment">//如果上面判断不成立，就把nums[i]的值与nums[nums[i]]交换</span></span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp=nums[nums[i]];</span><br><span class="line">                nums[nums[i]]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="2-三数之和"><a href="#2-三数之和" class="headerlink" title="2.三数之和"></a>2.三数之和</h2><p><strong>题目</strong>：</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ，请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[  [-1, 0, 1],  [-1, -1, 2]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>为了避免重复，先将数组排序，然后开始三循环。在第一循环内（也就是a固定了）其实问题就有点类似两数之和了，target就是0-a。不过不同的是两数之和是没有重复的，所以符合条件的只有一个结果。因此，三数之和可以采用：第二第三循环使用双指针，一个指向循环的头，一个指向循环的尾，然后判断两者相加，如果大于0-a，就尾指针往回移，如果小于0-a，就头指针往后移动，这样可以避免重复枚举。另外，指针移动的时候，也需要判断移动前后指针指向的值是否相等，相等的话就直接跳过。</p>
<h1 id="四、哈希表"><a href="#四、哈希表" class="headerlink" title="四、哈希表"></a>四、哈希表</h1><h2 id="1-第一个只出现一次的字符"><a href="#1-第一个只出现一次的字符" class="headerlink" title="1.第一个只出现一次的字符"></a>1.第一个只出现一次的字符</h2><p><strong>题目</strong>：</p>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>建立一个哈希表dic，以字符作为键值。然后遍历字符串s，如果如果哈希表里能找到这个字符，就把此字符对应的数值改为0，找不到就赋值1。这样遍历一遍下来，重复的就会被赋值0，不重复的就是被赋值1。然后再遍历一次，找到第一个数值是1的就可以。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">        <span class="comment">//调用dic.find(c),如果在dic中找不到c，就会返回dic.end()。因此这一个for循环之后，重复字符在哈希表中对应的值都会变成0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">            dic[c] = dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>();</span><br><span class="line">        <span class="comment">//继续迭代判断，只要遇到dic[c]是1，就说明没有重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(dic[c]) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-无重复字符的最长子字符串"><a href="#2-无重复字符的最长子字符串" class="headerlink" title="2.无重复字符的最长子字符串"></a>2.无重复字符的最长子字符串</h2><p>和字符串的第一题一样。</p>
<h2 id="3-宝石与石头"><a href="#3-宝石与石头" class="headerlink" title="3.宝石与石头"></a>3.宝石与石头</h2><p><strong>题目</strong>：</p>
<p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<p>简单来说，就是给定字符串J和S，输出S中可以在J找到的字符的数目</p>
<p><strong>示例</strong>：</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>


<p>注意:</p>
<p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p>
<p><strong>思路</strong>：</p>
<p>定义用于记录输出的整数num，再把J的字符存到哈希表中，然后再遍历S的字符，并且判断每个字符是否能够在哈希表里找到，找到就num++</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">char</span>&gt; gemstone;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把J的字符存到哈希表里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:J)</span><br><span class="line">            gemstone.insert(c);</span><br><span class="line">        <span class="comment">//遍历S，检查每个字符在哈希表里是否存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:S)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gemstone.<span class="built_in">find</span>(c)!=gemstone.<span class="built_in">end</span>())</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="五、二叉树"><a href="#五、二叉树" class="headerlink" title="五、二叉树"></a>五、二叉树</h1><h2 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="1.翻转二叉树"></a>1.翻转二叉树</h2><p><strong>题目</strong>：</p>
<p>翻转一颗二叉树</p>
<p><strong>示例</strong>：</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4 </span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>利用递归</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件：如果传入的根节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">        <span class="comment">//每次递归的需要进行的操作。在这题，就是将两个子节点位置互换</span></span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="comment">//返回跟节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-合并二叉树"><a href="#2-合并二叉树" class="headerlink" title="2.合并二叉树"></a>2.合并二叉树</h2><p><strong>题目</strong>：</p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>


<p>注意: 合并必须从两个树的根节点开始。****</p>
<p><strong>思路</strong>：</p>
<p>利用深度优先遍历两个二叉树，同时不断构造需要输出的二叉树节点</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断t1或者t2有没有空节点，有的话就输出另一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创立新的节点，并且把t1和t2的值相加赋给新节点</span></span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        <span class="comment">//使用递归</span></span><br><span class="line">        merged-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        merged-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="3-二叉树的最大深度"><a href="#3-二叉树的最大深度" class="headerlink" title="3.二叉树的最大深度"></a>3.二叉树的最大深度</h2><p><strong>题目</strong>：</p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>使用递归。建立一个函数，给出一个根节点，就可以返回根节点的最大深度</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="4-将有序数组装换为二叉搜索树"><a href="#4-将有序数组装换为二叉搜索树" class="headerlink" title="4.将有序数组装换为二叉搜索树"></a>4.将有序数组装换为二叉搜索树</h2><p><strong>题目</strong>：</p>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例</strong>:</p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
-10  5</code></pre><p>  <strong>思路</strong>：</p>
<p>因为需要高度平衡，而且数组时升序的，因此可以将数组的中间节点作为根节点。然后继续把数组中间节点左右两边的数据作为树的左子树根节点以及右子树根节点。因此，可以使用递归的方法，不断把数组的元素填充到二叉搜索树中。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//这里因为(left+right)可能是奇数或者偶数，因此这里mid的处理，会导致树的不同。比如当(left+right)奇数时，会有两个数组元素处于中间位置，选择左边的还是右边的，会导致树不同。在下面这个写法里，因为int类型会向下取整，所以取的是左边的。如果想取右边的，可以写int mid=(left+right+1)/2</span></span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//new新的节点，并且把数组下标为mid的元素赋值给节点。</span></span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        <span class="comment">//利用递归，返回左右字数的节点</span></span><br><span class="line">        root-&gt;left=helper(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="5-二叉树的中序遍历"><a href="#5-二叉树的中序遍历" class="headerlink" title="5.二叉树的中序遍历"></a>5.二叉树的中序遍历</h2><p><strong>题目</strong>：</p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><strong>示例</strong>：</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201216202412684.png" alt="image-20201216202412684" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>思路其实很简单，利用递归算法中序遍历</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义一个函数，输入树的根节点以及空数组。在空数组中输出树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//中序遍历的算法。在两个递归之间进行操作。</span></span><br><span class="line">        inorder(root-&gt;left,nums);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        inorder(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="6-不同的二叉搜索树"><a href="#6-不同的二叉搜索树" class="headerlink" title="6.不同的二叉搜索树"></a>6.不同的二叉搜索树</h2><p><strong>题目</strong>：</p>
<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>可以看成一个数学问题。</p>
<p>首先，我们假设，给定整数n，会有G（n）种可能。分解来看，1~n，每个整数都可以作为根节点。</p>
<p>找规律：</p>
<p>比如节点1作为根节点，那么左子树剩下0个整数，也就只有G（0）种可能，右子树剩下2~n，共n-1个整数，就是有G（n-1）种可能。那么两个相乘，就是总的可能，即G（0）*G（n-1）。</p>
<p>那么节点2作为根节点，那么左子树剩下1个整数，也就只有G（1）种可能，右子树剩下3~n，共n-2个整数，就是有G（n-2）种可能。那么两个相乘，就是总的可能，即G（1）*G（n-2）。</p>
<p>其实已经可以发现规律，即当整数i（1=&lt;i&lt;=n）作为节点时，会有G（i-1）*G（n-i）种可能。那么，当给出整数1~n，总的可能如下</p>
<p><img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20201216223017188.png" alt="image-20201216223017188"></p>
<p>可以发现G（n）的值与G(0)~G（n-1）有关。而根据实际情况，我们可以知道，G（0）=0，G(1)=1。只要我们利用上面的公式，迭代从G（2）一直计算到G（n），就可以得到G（n）的值。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">G</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                G[i]+=G[j<span class="number">-1</span>]*G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="7-不同的二叉搜索树II"><a href="#7-不同的二叉搜索树II" class="headerlink" title="7.不同的二叉搜索树II"></a>7.不同的二叉搜索树II</h2><p><strong>题目</strong>：</p>
<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p><strong>大体思路</strong>：使用递归，定义一个函数，只要传入两个整数start和end，就会返回两整数之间元素能组成的所有二叉搜索树。</p>
<p><strong>细致思路</strong>：可以使用迭代，把逐一把整数i作为根节点。然后start<del>i-1作为左子树的节点，i+1</del>end作为右子树节点。此时，就可以使用递归，把start和i-1作为参数递归，i+1和end作为参数递归</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="comment">//定义一个节点数组，用来存储结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">//迭代，把start和end之间的每个节点轮流作为根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义左子树数组，并且使用递归得到结果</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftTrees=generateTrees(start,i<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//定义右子树数组，并且使用递归得到结果</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightTrees=generateTrees(i+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">            <span class="comment">//使用双层迭代，从左子树和右子树数组中逐一抽取子树进行组合，两个迭代完成后，就列举了所有此层递归左右子树数组的组合情况</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; left:leftTrees)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; right:rightTrees)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* currTree=<span class="keyword">new</span> TreeNode(i);<span class="comment">//将此时的根节点的值赋值给一个新节点</span></span><br><span class="line">                    currTree-&gt;left=left;</span><br><span class="line">                    currTree-&gt;right=right;</span><br><span class="line">                    allTrees.push_back(currTree);<span class="comment">//将组合完成的二叉搜索树假如到allTrees中。这里的allTrees，当递归往回退一层时，也就是被赋值到leftTrees或者rightTrees了</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="8-对称二叉树"><a href="#8-对称二叉树" class="headerlink" title="8.对称二叉树"></a>8.对称二叉树</h2><p><strong>题目</strong>：</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"> </span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>定义两个节点指针p1和p2，然后使用递归，不断判断拍p1-&gt;val是否等于p2-&gt;val。</p>
<p>整理成写代码思路，就是定义一个递归函数，输入参数类型是两个节点指针类型，函数会对p1-&gt;val是否等于p2-&gt;val进行判断。然后再递归p1的左节点与p2的右节点，以及p1的右节点与p2的左节点。因为需要每一次判断都是true，</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* p1,TreeNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//针对p1、p2都是指向空节点的情况，这时候应该返回true</span></span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">nullptr</span>&amp;&amp;p2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//针对p1、p2有其中一个指向空节点，但是有一个不是空的。这时候明显不对称了，应该返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!p1 || !p2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断p1-&gt;val==p2-&gt;val，以及递归操作</span></span><br><span class="line">        <span class="keyword">return</span> p1-&gt;val==p2-&gt;val&amp;&amp;check(p1-&gt;left,p2-&gt;right)&amp;&amp;check(p1-&gt;right,p2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="六、堆"><a href="#六、堆" class="headerlink" title="六、堆"></a>六、堆</h1><h1 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h1><h2 id="1-爬楼梯问题"><a href="#1-爬楼梯问题" class="headerlink" title="1.爬楼梯问题"></a>1.爬楼梯问题</h2><p><strong>题目</strong>：假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例</strong>：</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶</span><br><span class="line">2 阶</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶 + 1 阶</span><br><span class="line">1 阶 + 2 阶</span><br><span class="line">2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>简单题解：根据规律，可以知道n级台阶可以通过n-1级爬1级到达，或者n-2级爬2级到达。也就是发f(n)=f(n-1)+f(n-2)，那么就可以使用动态规划，依次把f(1)到f(n)算出来，就可以得到答案。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        int a&#x3D;0,b&#x3D;1,c&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c&#x3D;a+b;</span><br><span class="line">            a&#x3D;b;</span><br><span class="line">            b&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-最小路径和"><a href="#2-最小路径和" class="headerlink" title="2.最小路径和"></a>2.最小路径和</h2><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<img src="http://tetedetian.oss-cn-shenzhen.aliyuncs.com/img/image-20210302175737257.png" alt="image-20210302175737257" style="zoom:80%;" />

<p><strong>思路</strong>：</p>
<p>使用动态规划。</p>
<p>因为只可以往右移或者网下移动。那么容易知道，</p>
<p>第一行的状态转移方程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+dp[i][j-1]</span><br></pre></td></tr></table></figure>

<p>第一列的状态转移方程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+dp[i-1][j]</span><br></pre></td></tr></table></figure>

<p>其他的状态转移方程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;grid[i][j]+min(dp[i-1][j],dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p>题解:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>()==<span class="number">0</span>||grid[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(grid)</span></span>;<span class="comment">//定义一个数组存储结果</span></span><br><span class="line">        <span class="keyword">int</span> rows=grid.<span class="built_in">size</span>(),columns=grid[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//获取输入的行数和列数</span></span><br><span class="line">        <span class="comment">//算第一列的dp,i从1开始是因为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h1><p>简单常见的有冒泡排序，选择排序，快速排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])<span class="comment">//这里使用大于号的话，就是升序排序</span></span><br><span class="line">			&#123;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*选择排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>])</span><br><span class="line">				<span class="built_in">min</span> = j;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = arr[i];</span><br><span class="line">		arr[i] = arr[<span class="built_in">min</span>];</span><br><span class="line">		arr[<span class="built_in">min</span>] = temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*快速排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i, j, datum, temp;<span class="comment">//datum就是基准的数</span></span><br><span class="line">	i = left;</span><br><span class="line">	j = right;</span><br><span class="line">	datum = arr[left];<span class="comment">//一般最开始取首项为基准</span></span><br><span class="line">	<span class="keyword">while</span> (i!=j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (arr[j] &gt;= datum &amp;&amp; i &lt; j) j--;<span class="comment">//j从最右边开始往左移动，遇到小于基准数就停下</span></span><br><span class="line">		<span class="keyword">while</span> (arr[i] &lt;= datum &amp;&amp; i &lt; j) i++;<span class="comment">//i从最左边往右移动，遇到大于基准数的就停下</span></span><br><span class="line">		<span class="comment">//交换arr[i]和arr[j],因为快速排序的思想就是把小于基准的放左边，大于的放右边。</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//把这一轮停下来的arr[i]与datum交换。因为这时候arr[i]是比datum小的。</span></span><br><span class="line">	arr[left] = arr[i];<span class="comment">//交换一轮后，arr[i]的值会小于datum（自己操作下试试）</span></span><br><span class="line">	arr[i] = datum;</span><br><span class="line">	quicksort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">	quicksort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">size</span>(a);</span><br><span class="line">	selectsort(a, len);</span><br><span class="line">    <span class="comment">//bubblesort(a, len);</span></span><br><span class="line">	<span class="comment">//quicksort(a, 0, len-1);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h1><h2 id="1-买卖股票的最佳时机"><a href="#1-买卖股票的最佳时机" class="headerlink" title="1.买卖股票的最佳时机"></a>1.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：</p>
<p>既然可以无数次买入卖出，那么我每次买入卖出的时间间隔选择最小的时间间隔：1天，然后只要每次买入卖出的收益大于0，最终总的收益肯定是最大的</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>(),result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result+=<span class="built_in">max</span>(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-分发饼干"><a href="#2-分发饼干" class="headerlink" title="2.分发饼干"></a>2.分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>：把饼干从大到小分别分配给胃口大到小的人，换句话说就是“尽量不浪费饼干”，只要每次分配都是“最不浪费饼干”的做法，最后也会满足最多的孩子。这也是贪心算法的思想。</p>
<p><strong>题解</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/>https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-03-31T15:50:55+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Mar 31, 2021</p>
  </a>
</div>

        
      
        
          

        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/&title=数据结构与算法题解 - 特特的天&summary=

——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/&title=数据结构与算法题解 - 特特的天&summary=

——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://tetedetian.github.io/2020/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/&title=数据结构与算法题解 - 特特的天&summary=

——这记录了一些leetcode的高频考题以及题解，还有一些我对答案额外的解释——"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>计算机网络（更新中）</p>
                <p class='content'>————这里，有一些计算机网络的基础知识，希望对你有帮助^_^————

————（针对c++后台开发）————







前言第一章——计算机网络概述1.计算机网络性能
1. 速率：速率即...</p>
              </a>
            
            
              <a class='next' href='/2020/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/'>
                <p class='title'>操作系统基本知识点<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>————这里，有操作系统的一些基础知识点^_^————







前言操作系统是什么：
操作系统（Operating System， OS） 是指控制和管理整个计算机系统的硬件和软件资源， ...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    
  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      <section id="comments">
        <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

      </section>
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->


</div>
<aside class='l_side'>
  
  

  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、字符串"><span class="toc-text">一、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-无重复字符的最长子字符串"><span class="toc-text">1.无重复字符的最长子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-最长回文子串"><span class="toc-text">2.最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-左旋转字符串"><span class="toc-text">3.左旋转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-翻转单词顺序"><span class="toc-text">4.翻转单词顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-字符串转换整数"><span class="toc-text">5.字符串转换整数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、链表"><span class="toc-text">二、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数相加"><span class="toc-text">1.两数相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-合并两个有序链表"><span class="toc-text">2.合并两个有序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-反转链表"><span class="toc-text">3.反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-两两交换链表中的节点"><span class="toc-text">4.两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-删除链表中的节点"><span class="toc-text">5.删除链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-从尾到头打印链表"><span class="toc-text">6.从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-两个链表的第一个公共节点。"><span class="toc-text">7.两个链表的第一个公共节点。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-链表中倒数第k个节点"><span class="toc-text">8.链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-复杂链表的复制"><span class="toc-text">9.复杂链表的复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、数组"><span class="toc-text">三、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-两数之和"><span class="toc-text">1.两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数组中重复的值"><span class="toc-text">2.数组中重复的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-三数之和"><span class="toc-text">2.三数之和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、哈希表"><span class="toc-text">四、哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-第一个只出现一次的字符"><span class="toc-text">1.第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-无重复字符的最长子字符串"><span class="toc-text">2.无重复字符的最长子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-宝石与石头"><span class="toc-text">3.宝石与石头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、二叉树"><span class="toc-text">五、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-翻转二叉树"><span class="toc-text">1.翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-合并二叉树"><span class="toc-text">2.合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-二叉树的最大深度"><span class="toc-text">3.二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-将有序数组装换为二叉搜索树"><span class="toc-text">4.将有序数组装换为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-二叉树的中序遍历"><span class="toc-text">5.二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-不同的二叉搜索树"><span class="toc-text">6.不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-不同的二叉搜索树II"><span class="toc-text">7.不同的二叉搜索树II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-对称二叉树"><span class="toc-text">8.对称二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、堆"><span class="toc-text">六、堆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、动态规划"><span class="toc-text">七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-爬楼梯问题"><span class="toc-text">1.爬楼梯问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-最小路径和"><span class="toc-text">2.最小路径和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、排序"><span class="toc-text">八、排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九、贪心算法"><span class="toc-text">九、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-买卖股票的最佳时机"><span class="toc-text">1.买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-分发饼干"><span class="toc-text">2.分发饼干</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



    </div>
    
  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='5131789159'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:me@xaoxuu.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/xaoxuu"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=63035382"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://xaoxuu.com" target="_blank" rel="noopener">Copyright © 2017-2020 Mr. X</a></p>

        </div>
      
    
  </footer>


    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <div>
    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>



  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>





  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/BBC19066-E176-47C2-9D22-48C81EE5DF6B.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/35F12181-F0E9-45BD-B134-37E4B4A660CF.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg", "https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/B951AE18-D431-417F-B3FE-A382403FF21B.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('') {
          $('').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  


<!-- 评论 （PS：只对 valine 做了 Pjax 兼容） -->

  
  
<script src="/js/valine.js"></script>


<script>
  var GUEST_INFO = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link'.split(',').filter(function (item) {
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick', 'mail', 'link'];
  var requiredFields = 'nick,mail'.split(',').filter(function (item) {
    return REQUIRED_FIELDS.indexOf(item) > -1
  });

  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }

  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }

  function pjax_valine() {
    var valinePath = $.trim($('#valine-path').text()) === "none" ?
            window.location.pathname : $.trim($('#valine-path').text());

    var valinePlaceholder = $.trim($('#valine-placeholder').text()) === "none" ?
            "快来评论吧~" : $.trim($('#valine-placeholder').text());

    var ALLPATH = '';
    if(ALLPATH != '') valinePath = ALLPATH;

    var valine = new Valine();
    valine.init({
      el: '#valine_container',
      meta: meta,
      placeholder: valinePlaceholder,
      path: valinePath,
      appId: "dogUA2FSKGTo029M1SEwGROT-MdYXbMMI",
      appKey: "u0NdtQ8nvHoMdJPSYqm1LRxE",
      pageSize: '10',
      avatar: 'robohash',
      lang: 'zh-cn',
      visitor: 'true',
      highlight: 'true',
      mathJax: 'false',
      enableQQ: 'true',
      requiredFields: requiredFields,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
      emojiMaps: emojiMaps
    })
  }

  $(function () {
    pjax_valine();
  });
</script>




<!-- darkmodejs -->



<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
</script>


<!-- scrollreveal -->

  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    function pjax_scrollrebeal() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '32px',
        duration: '800',
        interval: '20',
        scale: '1',
        easing: 'ease-out'
      });
    }

    $(function () {
      pjax_scrollrebeal();
    });
  </script>

<!-- ******************************** -->

<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  function pjax_fancybox() {
    $(".article-entry").find("img").not('.inline').not('a img').each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".article-entry").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  $(function () {
    pjax_fancybox();
  });
</script>

<!-- ******************************** -->


  
<script src="/js/app.js"></script>




  
    
<script src="/js/search.js"></script>

  



  <script defer src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js" data-pjax></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function () {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>







    
      


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>

<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
    <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
    <div id="loading-bar-wrapper"><script>NProgress.configure({parent:"#loading-bar-wrapper",trickleSpeed: 100})</script></div>
    <script>
      window.ShowLoading = function() {
        NProgress.start();
      };
      window.HideLoading = function() {
        NProgress.done();
      }
    </script>
  
</div>

<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      window.stop(); // 相当于点击了浏览器的停止按钮
      var currentUrl = window.location.pathname;
      var targetUrl = e.triggerElement.href;
      var banUrl = [""];
      if (banUrl[0] != "") {
        banUrl.forEach(item => {
          if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
            window.location.href = targetUrl;
          }
        });
      }
      window.subData = null; // 移除标题（用于一二级导航栏切换处）
      $.fancybox.close();    // 关闭弹窗
      $('.nav-main').find('.list-v').not('.menu-phone').css("display","none"); // 移除小尾巴
      $('.menu-phone.list-v').css("display","none"); // 移除小尾巴
      $('.l_header .switcher .s-search').removeClass('active'); // 关闭移动端激活的搜索框
      $('.l_header').removeClass('z_search-open'); // 关闭移动端激活的搜索框
      $('.wrapper').removeClass('sub'); // 跳转页面时关闭二级导航

      $('.s-top').unbind('click');   // 解绑
      $('.menu a').unbind('click');  // 解绑
      $(window).unbind('resize');    // 解绑
      $(window).unbind('scroll');    // 解绑
      $(document).unbind('scroll');  // 解绑
      $(document).unbind('click');   // 解绑
      $('body').unbind('click');     // 解绑
      window.ShowLoading();
    });

    document.addEventListener('pjax:complete', function () {
      // 关于百度统计对 SPA 页面的处理：
      // 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
      // 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
      // 

      // 关于谷歌统计对 SPA 页面的处理：
      // 当应用以动态方式加载内容并更新地址栏中的网址时，也应该更新通过 gtag.js 存储的网页网址。
      // https://developers.google.cn/analytics/devguides/collection/gtagjs/single-page-applications?hl=zh-cn
      

      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });

      try{
        pjax_fancybox();
        
          
          if ('') {
            $('').backstretch("resize");
          } else {
            $.backstretch("resize");
          }
        
        
        
          pjax_scrollrebeal();
        
        
          pjax_initCopyCode();
        
        
          pjax_valine();
        
        
        
      } catch (e) {
        console.log(e);
      }
      window.HideLoading();
    });

    document.addEventListener('pjax:error', function (e) {
      window.HideLoading();
      window.location.href = e.triggerElement.href;
    });
</script>

    
  </div>
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>